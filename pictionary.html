<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PICTIONARY üé®</title>
    <script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-firestore-compat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;900&family=JetBrains+Mono&display=swap');

        :root {
            --bg: #1a1a2e; --panel: #16213e; --primary: #e94560; --accent: #0f3460;
            --text: #eaeaea; --border: #0f3460; --danger: #ff6b6b; --success: #4ecdc4;
            --gold: #ffd700; --silver: #c0c0c0; --bronze: #cd7f32;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text);
            margin: 0; padding: 0; min-height: 100vh; display: flex; flex-direction: column;
        }

        /* === ANIMAZIONI === */
        @keyframes slideDown { from { transform: translateY(-100%); } to { transform: translateY(0); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.1); opacity: 0.8; } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes confetti { 0% { transform: translateY(0) rotate(0deg); opacity: 1; } 100% { transform: translateY(100vh) rotate(720deg); opacity: 0; } }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        @keyframes glow { 0%, 100% { box-shadow: 0 0 20px var(--primary); } 50% { box-shadow: 0 0 40px var(--primary), 0 0 60px var(--primary); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes timerPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.15); } }

        /* === LAYOUT === */
        .app-container {
            width: 100%; max-width: 1000px; margin: 0 auto; min-height: 100vh;
            background: var(--panel); display: flex; flex-direction: column;
            box-shadow: 0 0 50px rgba(0,0,0,0.3); position: relative;
        }

        header {
            padding: 12px 20px; border-bottom: 2px solid var(--border);
            display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(135deg, var(--panel) 0%, var(--accent) 100%);
            position: sticky; top: 0; z-index: 100;
        }

        .header-left { display: flex; align-items: center; gap: 15px; }
        .room-tag { 
            font-size: 0.7rem; color: var(--primary); font-weight: 700; 
            letter-spacing: 2px; text-transform: uppercase;
            background: rgba(233, 69, 96, 0.2); padding: 4px 10px; border-radius: 4px;
        }
        .player-name { font-weight: 900; color: var(--text); font-size: 1rem; }
        
        #timer { 
            font-family: 'JetBrains Mono'; font-weight: bold; color: var(--danger); 
            font-size: 2rem; min-width: 60px; text-align: center;
            text-shadow: 0 0 20px var(--danger);
        }
        #timer.warning { animation: pulse 0.5s infinite; color: #ff0000; }

        /* === CANVAS AREA === */
        #game-area {
            flex: 1; display: flex; flex-direction: column; 
            padding: 15px; overflow: hidden; align-items: center; justify-content: center;
            background: radial-gradient(circle at center, #1e2a4a 0%, var(--bg) 100%);
        }

        .canvas-wrapper {
            width: 100%; max-width: 500px; display: flex; flex-direction: column; gap: 10px;
        }

        .canvas-container {
            width: 100%; aspect-ratio: 1 / 1;
            background: #fff; cursor: crosshair; touch-action: none; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.4); border-radius: 12px;
            border: 3px solid var(--primary); position: relative;
            overflow: hidden;
        }

        .canvas-badge {
            position: absolute; top: 10px; left: 10px; 
            background: linear-gradient(135deg, var(--primary) 0%, #ff6b9d 100%);
            color: white; padding: 8px 15px; border-radius: 8px; 
            font-size: 0.85rem; font-weight: 700;
            pointer-events: none; z-index: 20; text-transform: uppercase;
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }

        /* === MINIATURA RIFERIMENTO INGRANDIBILE === */
        .reference-thumbnail {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 100px;
            height: 100px;
            background: white;
            border: 3px solid var(--success);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            z-index: 25;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            overflow: hidden;
        }

        .reference-thumbnail:hover {
            transform: scale(3.5) translate(-35%, 15%);
            z-index: 100;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }

        .reference-thumbnail canvas {
            width: 100%;
            height: 100%;
        }

        .reference-thumbnail .label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--success);
            color: white;
            font-size: 0.5rem;
            font-weight: bold;
            text-align: center;
            padding: 2px;
            opacity: 1;
            transition: opacity 0.3s;
        }

        .reference-thumbnail:hover .label {
            opacity: 0;
        }

        canvas { width: 100%; height: 100%; display: block; border-radius: 10px; }

        /* === TOOLBAR === */
        .toolbar {
            padding: 15px; background: var(--panel); border-top: 2px solid var(--border);
            display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: center;
            position: sticky; bottom: 0; z-index: 100;
        }

        .color-palette { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; }
        .color-dot {
            width: 32px; height: 32px; border-radius: 8px; border: 3px solid transparent; 
            cursor: pointer; transition: all 0.2s;
        }
        .color-dot:hover { transform: scale(1.1); }
        .color-dot.active { 
            border-color: var(--text); transform: scale(1.2); 
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        .tools-group { 
            display: flex; gap: 5px; background: var(--bg); 
            padding: 5px; border-radius: 10px; 
        }
        
        .tool-btn {
            width: 44px; height: 44px; border: none; background: transparent; border-radius: 8px;
            cursor: pointer; display: flex; align-items: center; justify-content: center; 
            font-size: 1.3rem; color: var(--text); transition: all 0.2s;
        }
        .tool-btn:hover { background: var(--accent); }
        .tool-btn.active { 
            background: var(--primary); color: white; 
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }

        .btn {
            padding: 12px 25px; border-radius: 10px; border: none; font-family: inherit; 
            font-weight: 700; cursor: pointer; font-size: 0.9rem; transition: all 0.2s;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .btn:active { transform: scale(0.95); }
        .btn-primary { 
            background: linear-gradient(135deg, var(--primary) 0%, #ff6b9d 100%); 
            color: white; box-shadow: 0 4px 20px rgba(233, 69, 96, 0.4); 
        }
        .btn-primary:hover { box-shadow: 0 6px 30px rgba(233, 69, 96, 0.6); }
        .btn-success { 
            background: linear-gradient(135deg, var(--success) 0%, #26d0ce 100%); 
            color: white; 
        }
        .btn-secondary { background: var(--accent); color: var(--text); }
        .btn-danger { background: var(--danger); color: white; }
        .btn-gold { 
            background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%); 
            color: #1a1a2e; 
        }

        /* === OVERLAYS === */
        .overlay {
            position: fixed; inset: 0; background: var(--bg);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000; text-align: center; padding: 20px; overflow-y: auto;
        }
        .hidden { display: none !important; }

        .card {
            background: var(--panel); padding: 30px; border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4); width: 100%; max-width: 500px;
            display: flex; flex-direction: column; gap: 15px; 
            border: 2px solid var(--border); animation: fadeIn 0.3s ease;
        }

        h1 { font-size: 2rem; margin: 0; color: var(--primary); letter-spacing: -1px; }
        h2 { font-size: 1.5rem; margin: 0; color: var(--text); }
        
        input, select, textarea {
            width: 100%; padding: 14px; border-radius: 10px; border: 2px solid var(--border);
            background: var(--bg); font-family: 'JetBrains Mono', monospace; font-size: 1rem;
            outline: none; color: var(--text);
        }
        input:focus, select:focus, textarea:focus { border-color: var(--primary); }
        input::placeholder { color: #666; }

        .theme-box {
            background: linear-gradient(135deg, var(--primary) 0%, #ff6b9d 100%);
            padding: 25px; border-radius: 15px; margin: 15px 0;
            font-size: 1.8rem; font-weight: 900; color: white;
            text-transform: uppercase; letter-spacing: 2px;
            box-shadow: 0 10px 30px rgba(233, 69, 96, 0.4);
            animation: pulse 2s infinite;
        }

        /* === LOBBY === */
        .players-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px; margin: 15px 0;
        }

        .player-card {
            background: var(--bg); padding: 15px 10px; border-radius: 10px;
            text-align: center; border: 2px solid var(--border);
            transition: all 0.3s;
        }
        .player-card.ready { 
            border-color: var(--success); 
            background: rgba(78, 205, 196, 0.1);
        }
        .player-card.host::after { 
            content: 'üëë'; display: block; font-size: 1.2rem; margin-top: 5px;
        }
        .player-card .name { font-weight: 700; font-size: 0.9rem; }
        .player-card .status { font-size: 0.7rem; opacity: 0.7; margin-top: 5px; }

        /* === BANNER STILE RUZZLE === */
        .game-banner {
            position: fixed; top: 0; left: 0; right: 0;
            padding: 15px 20px; display: flex; justify-content: space-between;
            align-items: center; z-index: 9999; animation: slideDown 0.3s ease;
            flex-wrap: wrap; gap: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .banner-left { display: flex; align-items: center; gap: 12px; }
        .banner-right { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .banner-icon { font-size: 1.8rem; }
        .banner-title { font-weight: 900; font-size: 1.1rem; color: white; }
        .banner-subtitle { font-size: 0.8rem; opacity: 0.9; color: white; }

        /* ‚úÖ TIMER NEL BANNER - SEMPRE VISIBILE */
        .banner-timer {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            font-weight: 900;
            color: white;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 16px;
            border-radius: 10px;
            min-width: 90px;
            text-align: center;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.3);
        }
        .banner-timer.warning {
            background: rgba(255, 0, 0, 0.4);
            border-color: #ff0000;
            animation: timerPulse 0.5s infinite;
        }

        /* === GALLERIA === */
        .gallery-container {
            width: 100%; max-width: 1200px; padding: 20px;
        }

        .chain-card {
            background: var(--panel); border-radius: 15px; padding: 20px;
            margin-bottom: 30px; border: 2px solid var(--border);
        }

        .chain-header {
            display: flex; justify-content: space-between; align-items: center;
            padding-bottom: 15px; border-bottom: 2px solid var(--border);
            margin-bottom: 20px;
        }

        .chain-title { 
            font-size: 1.2rem; font-weight: 900; color: var(--primary);
            display: flex; align-items: center; gap: 10px;
        }

        .chain-flow {
            display: flex; overflow-x: auto; gap: 20px; padding: 10px 0;
            scroll-snap-type: x mandatory;
        }

        .chain-step {
            min-width: 200px; max-width: 200px; scroll-snap-align: start;
            background: var(--bg); border-radius: 12px; padding: 10px;
            display: flex; flex-direction: column; align-items: center;
            border: 2px solid var(--border); transition: all 0.3s;
            cursor: pointer;
        }
        .chain-step:hover { border-color: var(--primary); transform: translateY(-5px); }
        .chain-step.voted { border-color: var(--gold); box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }

        .step-canvas {
            width: 100%; aspect-ratio: 1/1; background: white;
            border-radius: 8px; overflow: hidden; margin-bottom: 10px;
        }
        .step-canvas canvas { width: 100%; height: 100%; }

        .step-info { text-align: center; width: 100%; }
        .step-player { font-weight: 700; font-size: 0.85rem; color: var(--primary); }
        .step-guess { 
            font-size: 0.75rem; color: var(--text); opacity: 0.8; 
            margin-top: 5px; font-style: italic;
        }

        .chain-arrow {
            display: flex; align-items: center; font-size: 2rem; color: var(--primary);
            min-width: 40px; justify-content: center;
        }

        /* === VOTAZIONE === */
        .vote-btn {
            margin-top: 10px; width: 100%; padding: 8px;
            background: var(--accent); border: none; border-radius: 6px;
            color: white; font-weight: 700; cursor: pointer; transition: all 0.2s;
        }
        .vote-btn:hover { background: var(--primary); }
        .vote-btn.voted { background: var(--gold); color: #1a1a2e; }
/* ‚úÖ Evidenzia i propri disegni durante la votazione */
.chain-step.my-drawing {
    border-color: var(--primary);
    background: rgba(233, 69, 96, 0.1);
    position: relative;
}

.chain-step.my-drawing::before {
    content: 'üë§ TUO';
    position: absolute;
    top: 5px;
    right: 5px;
    background: var(--primary);
    color: white;
    font-size: 0.6rem;
    font-weight: bold;
    padding: 3px 8px;
    border-radius: 10px;
    z-index: 10;
}
        /* === RISULTATI === */
        .results-container {
            width: 100%; max-width: 600px;
        }

        .podium {
            display: flex; justify-content: center; align-items: flex-end;
            gap: 20px; margin: 30px 0; height: 200px;
        }

        .podium-place {
            display: flex; flex-direction: column; align-items: center;
            animation: bounce 0.5s ease;
        }

        .podium-avatar {
            width: 60px; height: 60px; border-radius: 50%;
            background: var(--panel); display: flex; align-items: center;
            justify-content: center; font-size: 1.5rem; font-weight: 900;
            border: 3px solid;
        }

        .podium-bar {
            width: 80px; display: flex; flex-direction: column;
            align-items: center; justify-content: flex-end;
            padding: 10px; border-radius: 10px 10px 0 0;
            margin-top: 10px;
        }

        .place-1 .podium-bar { height: 120px; background: linear-gradient(180deg, var(--gold) 0%, #cc9900 100%); }
        .place-1 .podium-avatar { border-color: var(--gold); }
        .place-2 .podium-bar { height: 90px; background: linear-gradient(180deg, var(--silver) 0%, #999 100%); }
        .place-2 .podium-avatar { border-color: var(--silver); }
        .place-3 .podium-bar { height: 60px; background: linear-gradient(180deg, var(--bronze) 0%, #8b5a2b 100%); }
        .place-3 .podium-avatar { border-color: var(--bronze); }

        .podium-name { font-weight: 700; font-size: 0.8rem; margin-top: 5px; }
        .podium-score { font-size: 1.2rem; font-weight: 900; color: #1a1a2e; }

        .full-ranking {
            background: var(--panel); border-radius: 15px; padding: 20px;
            margin-top: 20px;
        }

        .ranking-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 15px; border-radius: 8px; margin-bottom: 8px;
            background: var(--bg);
        }
        .ranking-row.me { border: 2px solid var(--primary); }

        .ranking-position { 
            font-weight: 900; font-size: 1.1rem; min-width: 30px;
        }
        .ranking-name { flex: 1; margin-left: 15px; font-weight: 600; }
        .ranking-score { font-weight: 900; color: var(--primary); }

        /* === SPINNER === */
        .spinner {
            width: 30px; height: 30px; border: 3px solid white;
            border-top-color: transparent; border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* === CONFETTI === */
        .confetti {
            position: fixed; width: 10px; height: 10px;
            z-index: 9999; pointer-events: none;
            animation: confetti 3s forwards;
        }

        /* === LOADING SCREEN === */
        #loading-screen {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #loading-screen .spinner-big {
            width: 60px;
            height: 60px;
            border: 4px solid var(--primary);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        #loading-screen p {
            color: var(--text);
            font-size: 1.1rem;
            opacity: 0.8;
        }

        /* === PULSANTE HOME FISSO === */
        #fixed-home-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 99999;
            display: none;
        }

        #fixed-home-btn button {
            background: var(--panel);
            color: var(--text);
            border: 2px solid var(--primary);
            padding: 12px 20px;
            border-radius: 50px;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            transition: all 0.2s ease;
        }

        #fixed-home-btn button:hover {
            transform: scale(1.05);
            background: var(--primary);
            color: white;
            box-shadow: 0 6px 25px rgba(233, 69, 96, 0.4);
        }

        /* === RESPONSIVE === */
        @media (max-width: 600px) {
            .card { padding: 20px; }
            h1 { font-size: 1.5rem; }
            .theme-box { font-size: 1.3rem; padding: 20px; }
            .toolbar { padding: 10px; gap: 8px; }
            .color-dot { width: 28px; height: 28px; }
            .tool-btn { width: 38px; height: 38px; font-size: 1.1rem; }
            .btn { padding: 10px 18px; font-size: 0.8rem; }
            .game-banner { flex-direction: column; text-align: center; }
            .banner-left, .banner-right { justify-content: center; width: 100%; }
            .banner-timer { font-size: 1.5rem; padding: 6px 12px; }
            .reference-thumbnail:hover {
                transform: scale(2.5) translate(-20%, 10%);
            }
        }
    </style>
</head>
<body>

<!-- LOADING -->
<div id="loading-screen" class="overlay">
    <div class="spinner-big"></div>
    <p>Caricamento partita...</p>
</div>

<!-- LOBBY -->
<div id="lobby-screen" class="overlay hidden">
    <div class="card" style="max-width: 550px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h2>üè† LOBBY</h2>
        </div>

        <div style="font-size: 0.8rem; opacity: 0.7; text-align: center; margin-bottom: 15px;">
            In attesa che tutti i giocatori entrino dalla homepage
        </div>
        
        <div class="players-grid" id="lobby-players-list"></div>

        <div style="background: var(--bg); padding: 15px; border-radius: 12px;">
<div style="display: flex; flex-direction: column; gap: 10px;">
    <div style="text-align: center; padding: 10px; background: rgba(78, 205, 196, 0.1); border-radius: 8px;">
        <div style="font-size: 0.75rem; opacity: 0.7;">ROUND AUTOMATICI</div>
        <div style="font-size: 1.2rem; font-weight: 900; color: var(--success);">
            <span id="auto-rounds-display">2</span> round
        </div>
        <div style="font-size: 0.7rem; opacity: 0.5;">= numero giocatori</div>
    </div>
    <div>
        <label style="font-size: 0.75rem; font-weight: bold; display: block; margin-bottom: 5px; opacity: 0.7;">
            ‚è±Ô∏è TEMPO PER DISEGNO
        </label>
        <select id="lobby-time-select">
            <option value="30">30 secondi (Veloce)</option>
            <option value="45">45 secondi</option>
            <option value="60" selected>60 secondi (Standard)</option>
            <option value="90">90 secondi (Relax)</option>
        </select>
    </div>
</div>
        </div>

        <div id="lobby-status" style="padding: 15px; background: rgba(78, 205, 196, 0.1); 
             border-radius: 10px; border: 2px solid var(--success); display: none;">
            <div style="font-weight: bold; color: var(--success);">‚è≥ IN ATTESA</div>
            <div style="font-size: 0.85rem; opacity: 0.8;">
                Giocatori pronti: <span id="ready-count">0</span>/<span id="total-count">0</span>
            </div>
        </div>

        <button class="btn btn-primary" id="lobby-ready-btn" style="width: 100%; padding: 18px;" 
                onclick="toggleReady()">
            üöÄ SONO PRONTO!
        </button>
        
        <button class="btn btn-secondary" style="width: 100%;" onclick="leaveRoom()">
            üö™ ESCI
        </button>
    </div>
</div>

<!-- CANVAS -->
<div id="game-ui" class="app-container hidden">
    <header>
        <div class="header-left">
            <span class="room-tag" id="ui-round-info">ROUND 1/2</span>
            <span class="player-name" id="ui-player">PLAYER</span>
        </div>
        <div id="timer">60</div>
    </header>

    <div id="game-area">
        <div class="canvas-wrapper">
            <div class="canvas-container">
                <div class="canvas-badge" id="canvas-theme-badge">TEMA</div>
                <div class="reference-thumbnail" id="reference-thumbnail" style="display: none;">
                    <canvas id="reference-mini-canvas"></canvas>
                    <div class="label">üëÜ HOVER</div>
                </div>
                <canvas id="mainCanvas"></canvas>
            </div>
        </div>
    </div>

    <div class="toolbar">
        <div class="tools-group">
            <button class="tool-btn" onclick="undo()" title="Annulla">‚Ü©Ô∏è</button>
            <button class="tool-btn" id="tool-eraser" onclick="setTool('eraser')">üßπ</button>
            <button class="tool-btn active" id="tool-pen" onclick="setTool('pen')">‚úèÔ∏è</button>
            <button class="tool-btn" id="tool-bucket" onclick="setTool('bucket')">ü™£</button>
        </div>
        <div class="tools-group">
            <button class="tool-btn" id="size-4" onclick="setSize(4)">‚Ä¢</button>
            <button class="tool-btn active" id="size-8" onclick="setSize(8)">‚óè</button>
            <button class="tool-btn" id="size-16" onclick="setSize(16)">‚¨§</button>
            <button class="tool-btn" id="size-24" onclick="setSize(24)">üî¥</button>
        </div>
        <div class="color-palette" id="palette"></div>
        <div style="display: flex; gap: 10px;">
            <button class="btn btn-secondary" onclick="clearCanvas()">üóëÔ∏è RESET</button>
            <button class="btn btn-success" onclick="finishCurrentPhase()">‚úÖ FATTO</button>
        </div>
    </div>
</div>

<!-- ATTESA -->
<div id="waiting-screen" class="overlay hidden">
    <div class="card">
        <div class="spinner" style="margin: 0 auto;"></div>
        <h2 id="waiting-title">ATTESA</h2>
        <p id="waiting-message" style="opacity: 0.7;">Aspettando gli altri giocatori...</p>
        <div id="waiting-progress" style="margin-top: 15px; font-size: 1.2rem; color: var(--success);">
            <span id="done-count">0</span>/<span id="total-players">0</span>
        </div>
    </div>
</div>

<!-- GALLERIA + VOTAZIONE -->
<div id="gallery-screen" class="overlay hidden" style="justify-content: flex-start; padding: 0;">
    <header style="width: 100%; position: sticky; top: 0;">
        <div class="header-left">
            <span style="font-size: 1.5rem;">üñºÔ∏è</span>
            <span style="font-weight: 900;">GALLERIA</span>
        </div>
        <div id="vote-status" style="font-size: 0.85rem; opacity: 0.8;"></div>
    </header>
    
    <div class="gallery-container" id="gallery-container"></div>
    
    <div style="position: sticky; bottom: 0; width: 100%; padding: 15px; 
                background: var(--panel); border-top: 2px solid var(--border);">
        <button class="btn btn-gold" style="width: 100%; padding: 18px;" 
                onclick="confirmVotes()" id="confirm-votes-btn">
            ‚úÖ CONFERMA VOTI
        </button>
    </div>
</div>

<!-- RISULTATI -->
<div id="results-screen" class="overlay hidden">
    <div class="results-container">
        <div style="text-align: center; margin-bottom: 30px;">
            <div style="font-size: 4rem;">üèÜ</div>
            <h1 style="margin: 10px 0;">RISULTATI</h1>
        </div>
        
        <div class="podium" id="podium"></div>
        
        <div class="full-ranking" id="full-ranking"></div>
        
        <div style="display: flex; gap: 15px; margin-top: 30px;">
            <button class="btn btn-primary" style="flex: 1;" onclick="playAgain()">
                üîÑ RIVINCITA
            </button>
            <button class="btn btn-secondary" style="flex: 1;" onclick="goHome()">
                üè† HOME
            </button>
        </div>
    </div>
</div>

<div id="fixed-home-btn">
    <button onclick="tornaHome()">üè† HOME</button>
</div>

<script>
// ========================================
// FIREBASE CONFIG
// ========================================
const firebaseConfig = {
    apiKey: "AIzaSyCNo7o2Ft22JDEyJ97BspE3Kur5DNAPKQc",
    authDomain: "funatwork-cd237.firebaseapp.com",
    projectId: "funatwork-cd237",
    storageBucket: "funatwork-cd237.firebasestorage.app",
    messagingSenderId: "798226885203",
    appId: "1:798226885203:web:ce83f4d9e96b82266274a6"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// ========================================
// TEMI
// ========================================
const THEMES = [
    // ü§™ ASSURDIT√Ä PURE
    "Nonno che fa parkour", "Gatto con il monocolo", "Pizza che fa yoga",
    "Dinosauro in smart working", "Nonna rapper", "Cane che guida una Ferrari",
    "Pinguino in discoteca", "Broccolo bodybuilder", "Unicorno depresso",
    "Banana ninja", "Paperella gigante che attacca Tokyo", "Ges√π che fa surf",
    
    // üòÇ SITUAZIONI IMBARAZZANTI
    "Collega che ruba il pranzo dal frigo", "Riunione Zoom in mutande",
    "Caff√® che non funziona il luned√¨", "Excel che crasha prima di salvare",
    "Stampante posseduta dal demonio", "Mail mandata al capo per sbaglio",
    "Scorreggia silenziosa in ascensore", "Russare durante una call",
    
    // ü¶Ñ CREATURE IMPOSSIBILI
    "Drago che ha paura del fuoco", "Squalo vegano", "Zombie influencer",
    "Fantasma con gli occhiali", "Sirena con le gambe", "Centauro in monopattino",
    "Fenicottero punk", "Bradipo su Red Bull", "Polpo massaggiatore",
    
    // üé≠ PERSONAGGI ASSURDI
    "Batman al supermercato", "Shrek al primo appuntamento", "Thanos che fa giardinaggio",
    "Mario Bros in palestra", "Pikachu arrabbiato col capo", "Yoda che balla reggaeton",
    "Gollum che vince alla lotteria", "Darth Vader in vacanza",
    
    // üçï CIBO CHE FA COSE
    "Hamburger in terapia", "Sushi che fa karate", "Donut alla guida",
    "Pasta che corre la maratona", "Gelato al sole in panico", "Caff√® che medita",
    "Pollo arrosto che scappa", "Uovo che si allena per Pasqua",
    
    // üè¢ VITA DA UFFICIO ASSURDA
    "Meeting che poteva essere una mail", "Stapler posseduto",
    "Collega che scalda il pesce in microonde", "Capo trasformato in rospo",
    "Deadline che insegue", "Ferie cancellate personificate",
    "Bonus di fine anno (molto piccolo)", "Luned√¨ mattina",
    
    // üåç SCENE EPICHE
    "Mondiale di nascondino", "Gara di rutti spaziale", "Olimpiadi del divano",
    "Apocalisse dei post-it", "Invasione di piccioni giganti",
    "T-Rex che fa il DJ", "Vulcano di nutella", "Tornado di coriandoli",
    
    // üò± PAURE MODERNE
    "Notifica di lavoro alle 23", "Batteria al 1%", "WiFi che non va",
    "Aggiornamento Windows forzato", "Messaggio vocale di 5 minuti",
    "Suocera a sorpresa", "Dentista sadico", "Sveglia del luned√¨",
    
    // üé™ COMBO IMPOSSIBILI
    "Papa Francesco che skatea", "Regina Elisabetta al rave",
    "Einstein che fa TikTok", "Leonardo da Vinci su OnlyFans",
    "Napoleone che ordina da Glovo", "Cleopatra al centro commerciale",
    
    // üêæ ANIMALI IN SITUAZIONI UMANE
    "Gatto che paga le tasse", "Cane commercialista", "Piccione avvocato",
    "Mucca in palestra", "Gallina in smart working", "Pesce che guida Uber",
    "Ape influencer", "Lumaca corriere espresso", "Ragno architetto"
];

const COLORS = [
    '#000000', '#ffffff', '#808080', '#c0c0c0',
    '#ff0000', '#ff6b6b', '#ffa500', '#ffff00', 
    '#90ee90', '#00ff00', '#008000', '#00ffff',
    '#0000ff', '#4169e1', '#800080', '#ff00ff',
    '#ffc0cb', '#a52a2a', '#8b4513', '#f5deb3'
];

const LOGICAL_SIZE = 500;
const MIN_DIST = 4;

// ========================================
// STATO GLOBALE
// ========================================
let state = {
    roomId: null,
    playerName: null,
    isHost: false,
    roomData: null,
    myVotes: {},
    myCurrentTheme: null,
    receivedDrawing: null,
    isDrawing: false,
    myChainId: null,
    isAdvancing: false  // ‚úÖ Flag per evitare chiamate multiple
};

let canvas, ctx;
let isDrawing = false;
let currentTool = 'pen';
let currentColor = '#000000';
let currentSize = 8;
let history = [];
let timer = 60;
let timerInterval;
let unsubscribeRoom = null;

// ========================================
// UTILITY
// ========================================
function showScreen(id) {
    document.querySelectorAll('.overlay, .app-container').forEach(el => el.classList.add('hidden'));
    const target = document.getElementById(id);
    if (target) target.classList.remove('hidden');
}

function showBanner(options) {
    removeBanner();
    const banner = document.createElement('div');
    banner.id = 'game-banner';
    banner.className = 'game-banner';
    banner.style.background = `linear-gradient(135deg, ${options.color} 0%, ${adjustColor(options.color, -30)} 100%)`;
    
    let buttonsHtml = (options.buttons || []).map(btn => 
        `<button class="btn ${btn.class || 'btn-secondary'}" onclick="${btn.onclick}" 
                 style="padding: 10px 20px;">${btn.text}</button>`
    ).join('');
    
    let spinnerHtml = options.spinner ? '<div class="spinner"></div>' : '';
    let timerHtml = options.timer ? `<div class="banner-timer" id="banner-timer">${options.timer}s</div>` : '';
    
    banner.innerHTML = `
        <div class="banner-left">
            <span class="banner-icon">${options.icon}</span>
            <div>
                <div class="banner-title">${options.title}</div>
                <div class="banner-subtitle">${options.subtitle}</div>
            </div>
        </div>
        <div class="banner-right">${timerHtml}${buttonsHtml}${spinnerHtml}</div>
    `;
    
    document.body.appendChild(banner);
}

function removeBanner() {
    document.getElementById('game-banner')?.remove();
}

function adjustColor(hex, amount) {
    let c = hex.replace('#', '');
    if (c.length === 3) c = c[0]+c[0]+c[1]+c[1]+c[2]+c[2];
    const num = parseInt(c, 16);
    let r = Math.min(255, Math.max(0, (num >> 16) + amount));
    let g = Math.min(255, Math.max(0, ((num >> 8) & 0xFF) + amount));
    let b = Math.min(255, Math.max(0, (num & 0xFF) + amount));
    return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
}

function cyrb128(str) {
    let h = 1779033703;
    for (let i = 0; i < str.length; i++) h = Math.imul(h ^ str.charCodeAt(i), 597399067);
    return h >>> 0;
}

function sfc32(a) {
    return function() {
        a |= 0; a = a + 0x6D2B79F5 | 0;
        let t = Math.imul(a ^ a >>> 15, 1 | a);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}

function shuffleArray(arr, rng) {
    const copy = [...arr];
    for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy;
}

function fireConfetti() {
    const colors = ['#ff0000', '#ffff00', '#00ff00', '#00ffff', '#ff00ff', '#ffd700'];
    for (let i = 0; i < 100; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDuration = (2 + Math.random() * 2) + 's';
        confetti.style.animationDelay = Math.random() * 0.5 + 's';
        if (Math.random() > 0.5) confetti.style.borderRadius = '50%';
        document.body.appendChild(confetti);
        setTimeout(() => confetti.remove(), 5000);
    }
}

// ========================================
// LOBBY
// ========================================
function enterLobby() {
    removeBanner();
    showScreen('lobby-screen');
    showHomeButton();
    
    if (unsubscribeRoom) unsubscribeRoom();
    unsubscribeRoom = db.collection("pictionary_rooms").doc(state.roomId).onSnapshot(handleRoomUpdate);
}

function handleRoomUpdate(doc) {
    if (!doc.exists) {
        alert("Stanza chiusa!");
        location.reload();
        return;
    }
    
    const data = doc.data();
    const prevStato = state.roomData?.stato;
    const prevPhase = state.roomData?.currentPhase;
    
    state.roomData = data;
    state.isHost = data.host === state.playerName;
    
    // ‚úÖ SE STO DISEGNANDO, IGNORA COMPLETAMENTE
    if (state.isDrawing) {
        console.log("üìù Sto disegnando, ignoro update");
        return;
    }
    
    console.log(`üîÑ Update: stato=${data.stato}, fase=${data.currentPhase}, prev=${prevStato}/${prevPhase}`);
    
    // ‚úÖ GESTISCI IN BASE ALLO STATO CORRENTE
    switch(data.stato) {
        case 'lobby': 
            renderLobby(data); 
            break;
        case 'drawing': 
            handleDrawingPhase(data); 
            break;
        case 'voting': 
            handleVotingPhase(data); 
            break;
        case 'results': 
            handleResultsPhase(data); 
            break;
    }
}

function renderLobby(data) {
    removeBanner();
    showScreen('lobby-screen');
    
    const list = document.getElementById('lobby-players-list');
    list.innerHTML = '';
    data.players.forEach(p => {
        const card = document.createElement('div');
        card.className = `player-card ${data.ready.includes(p) ? 'ready' : ''} ${p === data.host ? 'host' : ''}`;
        card.innerHTML = `
            <div class="name">${p}</div>
            <div class="status">${data.ready.includes(p) ? '‚úÖ Pronto' : '‚è≥ In attesa'}</div>
        `;
        list.appendChild(card);
    });
    
    // ‚úÖ Aggiorna display round automatici
    const autoRoundsDisplay = document.getElementById('auto-rounds-display');
    if (autoRoundsDisplay) {
        autoRoundsDisplay.textContent = data.players.length;
    }
    
    // ‚úÖ Aggiorna selettore tempo
    const timeSelect = document.getElementById('lobby-time-select');
    if (timeSelect) {
        timeSelect.value = data.settings?.timePerRound || 60;
        
        const canEdit = state.isHost && !data.sfidaDiretta;
        timeSelect.disabled = !canEdit;
        
        if (canEdit) {
            timeSelect.onchange = () => updateSettings();
        } else {
            timeSelect.onchange = null;
        }
    }
    
    const readyBtn = document.getElementById('lobby-ready-btn');
    const statusDiv = document.getElementById('lobby-status');
    
    if (data.ready.includes(state.playerName)) {
        readyBtn.innerHTML = '‚è∏Ô∏è ANNULLA';
        readyBtn.className = 'btn btn-secondary';
        state.isReady = true;
    } else {
        readyBtn.innerHTML = 'üöÄ SONO PRONTO!';
        readyBtn.className = 'btn btn-primary';
        state.isReady = false;
    }
    
    if (data.ready.length > 0) {
        statusDiv.style.display = 'block';
        document.getElementById('ready-count').textContent = data.ready.length;
        document.getElementById('total-count').textContent = data.players.length;
    } else {
        statusDiv.style.display = 'none';
    }
    
    if (data.ready.length < data.players.length && data.players.length >= 2) {
        showBanner({
            icon: 'üé®',
            title: 'PICTIONARY - LOBBY',
            subtitle: `${data.ready.length}/${data.players.length} giocatori pronti`,
            color: '#9b59b6'
        });
    }
    
    if (data.ready.length >= data.players.length && data.players.length >= 2 && state.isHost) {
        startGame();
    }
}

async function updateSettings() {
    await db.collection("pictionary_rooms").doc(state.roomId).update({
        'settings.timePerRound': parseInt(document.getElementById('lobby-time-select').value)
    });
}

async function toggleReady() {
    const field = state.isReady ? 
        firebase.firestore.FieldValue.arrayRemove(state.playerName) :
        firebase.firestore.FieldValue.arrayUnion(state.playerName);
    
    await db.collection("pictionary_rooms").doc(state.roomId).update({ ready: field });
}

async function leaveRoom() {
    if (!confirm("Sicuro di voler uscire?")) return;
    
    if (state.isHost) {
        await db.collection("pictionary_rooms").doc(state.roomId).delete();
    } else {
        await db.collection("pictionary_rooms").doc(state.roomId).update({
            players: firebase.firestore.FieldValue.arrayRemove(state.playerName),
            ready: firebase.firestore.FieldValue.arrayRemove(state.playerName)
        });
    }
    
    location.reload();
}

// ========================================
// AVVIO GIOCO
// ========================================
async function startGame() {
    if (!state.isHost) return;
    
    const data = state.roomData;
    const players = data.players;
    const numPlayers = players.length;
    
    // ‚úÖ ROUND AUTOMATICI = numero giocatori
    const totalRounds = numPlayers;
    
    const seed = cyrb128(state.roomId + Date.now());
    const rng = sfc32(seed);
    const shuffledThemes = shuffleArray(THEMES, rng);
    
    // ‚úÖ Crea una catena per ogni tema (= numero giocatori)
    const chains = {};
    for (let i = 0; i < numPlayers; i++) {
        chains[i] = {
            themeIndex: i,
            originalTheme: shuffledThemes[i % shuffledThemes.length],
            steps: [],
            drawnBy: [] // Chi ha gi√† disegnato questo tema
        };
    }
    
    const scores = {};
    players.forEach(p => scores[p] = 0);
    
    await db.collection("pictionary_rooms").doc(state.roomId).update({
        stato: 'drawing',
        currentRound: 0,
        totalRounds: totalRounds,
        chains: chains,
        scores: scores,
        votes: {},
        completedRound: {},
        playerOrder: players // Ordine fisso per la rotazione
    });
}

// ========================================
// ‚úÖ FASE DISEGNO - CORRETTA
// ========================================
function handleDrawingPhase(data) {
    const currentRound = data.currentRound;
    const completed = data.completedRound?.[currentRound] || [];
    
    console.log(`üìù handleDrawingPhase: round=${currentRound}, completed=${completed.join(',')}`);
    
    // ‚úÖ Se ho gi√† completato questo round, mostra waiting
    if (completed.includes(state.playerName)) {
        showWaitingScreen(data);
        return;
    }
    
    // ‚úÖ CALCOLA QUALE TEMA DEVO DISEGNARE
    const players = data.playerOrder || data.players;
    const numPlayers = players.length;
    const myIdx = players.indexOf(state.playerName);
    
    // Round k ‚Üí Giocatore i disegna tema (i + k) % N
    const myChainId = (myIdx + currentRound) % numPlayers;
    const chain = data.chains[myChainId];
    
    let myTheme, referenceDrawing = null;
    
    if (currentRound === 0) {
        // ‚úÖ Round 0: Disegno il tema originale
        myTheme = chain.originalTheme;
    } else {
        // ‚úÖ Round 1+: Ridisegno guardando l'ultimo disegno della catena
        myTheme = "RIDISEGNALO!";
        const lastStep = chain.steps[chain.steps.length - 1];
        if (lastStep && lastStep.drawing) {
            referenceDrawing = lastStep.drawing;
        }
    }
    
    state.myCurrentTheme = currentRound === 0 ? chain.originalTheme : myTheme;
    state.originalTheme = chain.originalTheme; // Salva per riferimento
    state.receivedDrawing = referenceDrawing;
    state.myChainId = myChainId;
    
    console.log(`üéØ Round ${currentRound}: Disegno chain ${myChainId} ("${chain.originalTheme}"), hasRef=${!!referenceDrawing}`);
    
    launchCanvas(data);
}

function launchCanvas(data) {
    state.isDrawing = true;
    showScreen('game-ui');
    showHomeButton();
    
    canvas = document.getElementById('mainCanvas');
    ctx = canvas.getContext('2d', { willReadFrequently: true });
    setupCanvas(canvas);
    
    // ‚úÖ Mostra miniatura se presente riferimento
    const refThumbnail = document.getElementById('reference-thumbnail');
    const themeBadge = document.getElementById('canvas-theme-badge');
    
if (state.receivedDrawing) {
    refThumbnail.style.display = 'block';
    
    const miniCanvas = document.getElementById('reference-mini-canvas');
    miniCanvas.width = LOGICAL_SIZE;
    miniCanvas.height = LOGICAL_SIZE;
    const miniCtx = miniCanvas.getContext('2d');
    miniCtx.fillStyle = '#ffffff';
    miniCtx.fillRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
    
    const actions = decompressDrawing(state.receivedDrawing);
    actions.forEach(act => applyAction(act, miniCtx));
    
    themeBadge.textContent = "üé® COPIA QUESTO!";
    themeBadge.style.background = 'linear-gradient(135deg, #4ecdc4 0%, #26d0ce 100%)';
} else {
    if (refThumbnail) refThumbnail.style.display = 'none';
    themeBadge.textContent = state.myCurrentTheme;
    themeBadge.style.background = 'linear-gradient(135deg, #e94560 0%, #ff6b9d 100%)';
}
    
document.getElementById('ui-round-info').textContent = 
    `ROUND ${data.currentRound + 1}/${data.totalRounds}`;
    document.getElementById('ui-player').textContent = state.playerName;
    
    renderPalette();
    setTool('pen');
    setSize(8);
    history = [];
    
    timer = data.settings.timePerRound;
    document.getElementById('timer').textContent = timer;
    document.getElementById('timer').classList.remove('warning');
    
    startTimerWithBanner();
    attachCanvasListeners();
}

// ‚úÖ TIMER CON BANNER - CORRETTO
function startTimerWithBanner() {
    clearInterval(timerInterval);
    
    const data = state.roomData;
    const isRedraw = !!state.receivedDrawing;
    const fase = isRedraw ? 'RIDISEGNA' : 'DISEGNA';
    const tema = state.myCurrentTheme;
    const roundInfo = `Round ${data.currentRound + 1}/${data.totalRounds}`;
    
    // ‚úÖ BANNER CON TIMER VISIBILE
    showBanner({
        icon: isRedraw ? 'üé®' : '‚úèÔ∏è',
        title: `${fase}: ${tema}`,
        subtitle: roundInfo,
        color: isRedraw ? '#4ecdc4' : '#e94560',
        timer: timer
    });
    
    const timerEl = document.getElementById('timer');
    
    timerInterval = setInterval(() => {
        timer--;
        
        // Aggiorna header canvas
        if (timerEl) {
            timerEl.textContent = timer;
            if (timer <= 10) timerEl.classList.add('warning');
        }
        
        // ‚úÖ Aggiorna timer nel banner
        const bannerTimer = document.getElementById('banner-timer');
        if (bannerTimer) {
            bannerTimer.textContent = `${timer}s`;
            if (timer <= 10) {
                bannerTimer.classList.add('warning');
            }
        }
        
        if (timer <= 0) {
            clearInterval(timerInterval);
            finishCurrentPhase();
        }
    }, 1000);
}

// ‚úÖ FINISH PHASE - CORRETTO
async function finishCurrentPhase() {
    if (state.isAdvancing) return;
    
    clearInterval(timerInterval);
    removeBanner();
    state.isDrawing = false;
    
    const data = state.roomData;
    const currentRound = data.currentRound;
    const myChainId = state.myChainId;
    
    console.log(`‚úÖ finishCurrentPhase: round=${currentRound}, chain=${myChainId}`);
    
    const drawingData = compressDrawing(history);
    
    const step = {
        player: state.playerName,
        round: currentRound,
        drawing: drawingData
    };
    
    const chainPath = `chains.${myChainId}.steps`;
    const drawnByPath = `chains.${myChainId}.drawnBy`;
    const completedPath = `completedRound.${currentRound}`;
    
    await db.collection("pictionary_rooms").doc(state.roomId).update({
        [chainPath]: firebase.firestore.FieldValue.arrayUnion(step),
        [drawnByPath]: firebase.firestore.FieldValue.arrayUnion(state.playerName),
        [completedPath]: firebase.firestore.FieldValue.arrayUnion(state.playerName)
    });
    
    state.receivedDrawing = null;
    
    // Leggi dati freschi
    const freshDoc = await db.collection("pictionary_rooms").doc(state.roomId).get();
    const freshData = freshDoc.data();
    state.roomData = freshData;
    
    const completed = freshData.completedRound?.[currentRound] || [];
    const total = freshData.players.length;
    
    console.log(`üìä Completati: ${completed.length}/${total}, isHost=${state.isHost}`);
    
    if (completed.length >= total && state.isHost) {
        await advanceToNextRound(freshData);
    } else {
        showWaitingScreen(freshData);
    }
}

// ‚úÖ AVANZAMENTO FASE - CORRETTO
async function advanceToNextRound(data) {
    if (state.isAdvancing) {
        console.log("‚ö†Ô∏è Gi√† in avanzamento, skip");
        return;
    }
    
    state.isAdvancing = true;
    
    const currentRound = data.currentRound;
    const totalRounds = data.totalRounds;
    const nextRound = currentRound + 1;
    
    console.log(`üöÄ advanceToNextRound: ${currentRound} ‚Üí ${nextRound} (totale: ${totalRounds})`);
    
    try {
        if (nextRound >= totalRounds) {
            // ‚úÖ Tutti i round completati ‚Üí Votazione
            console.log("üó≥Ô∏è Passaggio a VOTAZIONE");
            await db.collection("pictionary_rooms").doc(state.roomId).update({
                stato: 'voting'
            });
        } else {
            // ‚úÖ Prossimo round
            console.log(`‚û°Ô∏è Passaggio a round ${nextRound}`);
            await db.collection("pictionary_rooms").doc(state.roomId).update({
                currentRound: nextRound,
                stato: 'drawing'
            });
        }
    } catch (e) {
        console.error("‚ùå Errore avanzamento round:", e);
    } finally {
        setTimeout(() => { state.isAdvancing = false; }, 2000);
    }
}

// ========================================
// ‚úÖ WAITING SCREEN - CORRETTO
// ========================================
function showWaitingScreen(data) {
    clearInterval(timerInterval);
    showScreen('waiting-screen');
    showHomeButton();
    
    const currentRound = data.currentRound;
    const completed = data.completedRound?.[currentRound] || [];
    const total = data.players.length;
    
    const remaining = data.players.filter(p => !completed.includes(p));
    
    document.getElementById('waiting-title').textContent = `‚úèÔ∏è ROUND ${currentRound + 1}/${data.totalRounds} COMPLETATO!`;
    document.getElementById('waiting-message').textContent = 
        remaining.length > 0 
            ? `In attesa di: ${remaining.join(', ')}`
            : 'Tutti hanno finito! Passaggio...';
    document.getElementById('done-count').textContent = completed.length;
    document.getElementById('total-players').textContent = total;
    
    showBanner({
        icon: '‚è≥',
        title: `ATTESA (${completed.length}/${total})`,
        subtitle: remaining.length > 0 ? `Manca: ${remaining.join(', ')}` : 'Passaggio in corso...',
        color: '#9b59b6',
        spinner: true
    });
    
    // ‚úÖ SE TUTTI HANNO FINITO E SONO HOST, AVANZA
    if (completed.length >= total && state.isHost && !state.isAdvancing) {
        console.log("‚úÖ Tutti finito in waiting, host avanza");
        advanceToNextRound(data);
    }
}

// ========================================
// VOTAZIONE
// ========================================
function handleVotingPhase(data) {
    removeBanner();
    showScreen('gallery-screen');
    showHomeButton();
    renderGallery(data);
    
    const votedCount = Object.keys(state.myVotes).length;
    const totalChains = Object.keys(data.chains).length;
    
    // ‚úÖ Controlla se ho gi√† votato (i miei voti sono su Firebase)
    const myVotesOnFirebase = data.votes?.[state.playerName];
    const confirmBtn = document.getElementById('confirm-votes-btn');
    
    if (myVotesOnFirebase && Object.keys(myVotesOnFirebase).length > 0) {
        // ‚úÖ Ho gi√† confermato i voti
        if (confirmBtn) {
            confirmBtn.disabled = true;
            confirmBtn.innerHTML = '‚úÖ VOTI INVIATI';
            confirmBtn.style.opacity = '0.6';
            confirmBtn.style.cursor = 'not-allowed';
            confirmBtn.style.background = 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)';
        }
        
        const votedPlayers = Object.keys(data.votes).length;
        const totalPlayers = data.players.length;
        
        showBanner({
            icon: '‚è≥',
            title: `ATTESA VOTI (${votedPlayers}/${totalPlayers})`,
            subtitle: 'Hai gi√† votato. Attendi gli altri...',
            color: '#27ae60',
            spinner: true
        });
        
        // ‚úÖ Host controlla se tutti hanno votato
        if (state.isHost && votedPlayers >= totalPlayers) {
            checkAndCalculateResults();
        }
    } else {
        // ‚úÖ Non ho ancora votato
        if (confirmBtn) {
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = '‚úÖ CONFERMA VOTI';
            confirmBtn.style.opacity = '1';
            confirmBtn.style.cursor = 'pointer';
            confirmBtn.style.background = 'linear-gradient(135deg, #ffd700 0%, #ffaa00 100%)';
        }
        
        showBanner({
            icon: 'üó≥Ô∏è',
            title: 'VOTAZIONE IN CORSO',
            subtitle: `Vota il disegno pi√π bello di ogni catena (${votedCount}/${totalChains})`,
            color: '#f39c12'
        });
    }
}

function renderGallery(data) {
    const container = document.getElementById('gallery-container');
    container.innerHTML = '';
    
    const myVotes = state.myVotes;
    const isVotingPhase = data.stato === 'voting';
    
    Object.entries(data.chains).forEach(([chainId, chain]) => {
        const card = document.createElement('div');
        card.className = 'chain-card';
        
        // ‚úÖ Durante la votazione NON mostrare chi ha creato il tema originale
        const headerInfo = isVotingPhase 
            ? `<div style="font-size: 0.8rem; opacity: 0.7;">üéØ Tema originale nascosto</div>`
            : `<div style="font-size: 0.8rem; opacity: 0.7;">di ${chain.steps[0]?.player || '?'}</div>`;
        
// ‚úÖ Tema sempre visibile
const themeDisplay = `<span>Tema: "${chain.originalTheme}"</span>`;
        
        card.innerHTML = `
            <div class="chain-header">
                <div class="chain-title">
                    <span>üé®</span>
                    ${themeDisplay}
                </div>
                ${headerInfo}
            </div>
            <div class="chain-flow" id="chain-flow-${chainId}"></div>
        `;
        
        const flowContainer = card.querySelector(`#chain-flow-${chainId}`);
        
        chain.steps.forEach((step, stepIdx) => {
            if (stepIdx > 0) {
                const arrow = document.createElement('div');
                arrow.className = 'chain-arrow';
                arrow.innerHTML = '‚û°Ô∏è';
                flowContainer.appendChild(arrow);
            }
            
            // ‚úÖ Controlla se questo disegno √® mio (non posso votarmi)
            const isMyDrawing = step.player === state.playerName;
            const isVoted = myVotes[chainId] === `${chainId}-${stepIdx}`;
            
            const stepCard = document.createElement('div');
            stepCard.className = `chain-step ${isVoted ? 'voted' : ''} ${isMyDrawing && isVotingPhase ? 'my-drawing' : ''}`;
            
            // ‚úÖ Durante votazione: nascondo nome, durante risultati: mostro nome
            const playerDisplay = isVotingPhase 
                ? `<div class="step-player" style="color: #888;">Disegno #${stepIdx + 1}</div>`
                : `<div class="step-player">${step.player}</div>`;
            
            // ‚úÖ Pulsante voto: disabilitato se √® il mio disegno
            let voteButton = '';
            if (isVotingPhase) {
                if (isMyDrawing) {
                    voteButton = `
                        <button class="vote-btn" disabled 
                                style="opacity: 0.4; cursor: not-allowed; background: #444;">
                            üö´ Tuo disegno
                        </button>`;
                } else {
                    voteButton = `
                        <button class="vote-btn ${isVoted ? 'voted' : ''}" 
                                onclick="voteFor('${chainId}', '${chainId}-${stepIdx}')">
                            ${isVoted ? '‚≠ê VOTATO' : 'üëç VOTA'}
                        </button>`;
                }
            }
            
            stepCard.innerHTML = `
                <div class="step-canvas"><canvas id="step-canvas-${chainId}-${stepIdx}"></canvas></div>
                <div class="step-info">
                    ${playerDisplay}
                    <div class="step-type" style="font-size: 0.65rem; opacity: 0.6;">
                        ${stepIdx === 0 ? 'üéØ Primo disegno' : `üîÑ Copia #${stepIdx}`}
                    </div>
                </div>
                ${voteButton}
            `;
            
            flowContainer.appendChild(stepCard);
            
            setTimeout(() => {
                const cvs = document.getElementById(`step-canvas-${chainId}-${stepIdx}`);
                if (cvs && step.drawing) {
                    cvs.width = LOGICAL_SIZE;
                    cvs.height = LOGICAL_SIZE;
                    const ctxCanvas = cvs.getContext('2d');
                    ctxCanvas.fillStyle = '#ffffff';
                    ctxCanvas.fillRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
                    const actions = decompressDrawing(step.drawing);
                    actions.forEach(act => applyAction(act, ctxCanvas));
                }
            }, 50);
        });
        
        container.appendChild(card);
    });
    
    // ‚úÖ Conta solo i voti validi (non i propri disegni)
    const validVotesCount = Object.keys(myVotes).length;
    const totalChains = Object.keys(data.chains).length;
    document.getElementById('vote-status').textContent = 
        `Voti: ${validVotesCount}/${totalChains}`;
}

function voteFor(chainId, uniqueVoteId) {
    // ‚úÖ Estrai stepIdx dal uniqueVoteId
    const stepIdx = parseInt(uniqueVoteId.split('-')[1]);
    const chain = state.roomData.chains[chainId];
    const step = chain.steps[stepIdx];
    
    // ‚úÖ Doppio controllo: non posso votare me stesso
    if (step.player === state.playerName) {
        alert("Non puoi votare il tuo disegno!");
        return;
    }
    
    // ‚úÖ Toggle voto (clicca di nuovo per deselezionare)
    if (state.myVotes[chainId] === uniqueVoteId) {
        delete state.myVotes[chainId];
    } else {
        state.myVotes[chainId] = uniqueVoteId;
    }
    
    renderGallery(state.roomData);
    
    const votedCount = Object.keys(state.myVotes).length;
    const totalChains = Object.keys(state.roomData.chains).length;
    
    showBanner({
        icon: 'üó≥Ô∏è',
        title: 'VOTAZIONE IN CORSO',
        subtitle: `Vota il disegno pi√π bello di ogni catena (${votedCount}/${totalChains})`,
        color: '#f39c12'
    });
}
async function confirmVotes() {
    const data = state.roomData;
    const totalChains = Object.keys(data.chains).length;
    
    if (Object.keys(state.myVotes).length < totalChains) {
        return alert(`Devi votare in tutte le ${totalChains} catene!`);
    }
    
    // ‚úÖ Disabilita subito il pulsante per evitare doppi click
    const confirmBtn = document.getElementById('confirm-votes-btn');
    if (confirmBtn) {
        confirmBtn.disabled = true;
        confirmBtn.innerHTML = '‚è≥ INVIO VOTI...';
        confirmBtn.style.opacity = '0.6';
        confirmBtn.style.cursor = 'not-allowed';
    }
    
    // ‚úÖ Converti voti in formato {chainId: playerName}
    const votesForFirebase = {};
    Object.entries(state.myVotes).forEach(([chainId, uniqueVoteId]) => {
        const stepIdx = parseInt(uniqueVoteId.split('-')[1]);
        const chain = data.chains[chainId];
        const votedPlayer = chain.steps[stepIdx].player;
        votesForFirebase[chainId] = votedPlayer;
    });
    
    try {
        await db.collection("pictionary_rooms").doc(state.roomId).update({
            [`votes.${state.playerName}`]: votesForFirebase
        });
        
        // ‚úÖ Aggiorna pulsante a stato "confermato"
        if (confirmBtn) {
            confirmBtn.innerHTML = '‚úÖ VOTI INVIATI';
            confirmBtn.style.background = 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)';
        }
        
        showBanner({
            icon: '‚è≥',
            title: 'VOTI CONFERMATI',
            subtitle: 'Attendi gli altri giocatori...',
            color: '#27ae60',
            spinner: true
        });
        
        // ‚úÖ Host controlla e calcola risultati
        if (state.isHost) {
            await checkAndCalculateResults();
        }
        
    } catch (e) {
        console.error("Errore invio voti:", e);
        // Riabilita in caso di errore
        if (confirmBtn) {
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = '‚úÖ CONFERMA VOTI';
            confirmBtn.style.opacity = '1';
            confirmBtn.style.cursor = 'pointer';
        }
        alert("Errore nell'invio dei voti. Riprova.");
    }
}

// ‚úÖ Funzione separata per calcolare risultati (chiamata anche dal listener)
async function checkAndCalculateResults() {
    const doc = await db.collection("pictionary_rooms").doc(state.roomId).get();
    const newData = doc.data();
    
    if (Object.keys(newData.votes).length >= newData.players.length) {
        const scores = {};
        newData.players.forEach(p => scores[p] = 0);
        
        Object.values(newData.votes).forEach(playerVotes => {
            Object.values(playerVotes).forEach(votedPlayer => {
                if (scores[votedPlayer] !== undefined) {
                    scores[votedPlayer]++;
                }
            });
        });
        
        await db.collection("pictionary_rooms").doc(state.roomId).update({
            scores: scores,
            stato: 'results'
        });
    }
}

// ========================================
// RISULTATI
// ========================================
function handleResultsPhase(data) {
    removeBanner();
    showScreen('results-screen');
    showHomeButton();
    fireConfetti();
    
    const sorted = Object.entries(data.scores).sort((a, b) => b[1] - a[1]);
    
    const podium = document.getElementById('podium');
    podium.innerHTML = '';
    
const podiumOrder = [1, 0, 2];
podiumOrder.forEach((idx) => {
    if (sorted[idx]) {
        const [player, score] = sorted[idx];
        const place = idx + 1;
        
        const div = document.createElement('div');
        div.className = `podium-place place-${place}`;
        div.style.animationDelay = `${idx * 0.2}s`;
        div.innerHTML = `
            <div class="podium-avatar">${place}¬∞</div>
            <div class="podium-bar">
                <div class="podium-score">${score}</div>
            </div>
            <div class="podium-name">${player}</div>
        `;
        podium.appendChild(div);
    }
});
    
    const ranking = document.getElementById('full-ranking');
    ranking.innerHTML = '<h3 style="margin-top: 0;">Classifica Completa</h3>';
    
    sorted.forEach(([player, score], idx) => {
        const row = document.createElement('div');
        row.className = `ranking-row ${player === state.playerName ? 'me' : ''}`;
        row.innerHTML = `
            <span class="ranking-position">${idx + 1}¬∞</span>
            <span class="ranking-name">${player}</span>
            <span class="ranking-score">${score} voti</span>
        `;
        ranking.appendChild(row);
    });
    // ‚úÖ Mostra tema originale di ogni catena nei risultati
    let chainsInfo = '';
    Object.entries(data.chains).forEach(([chainId, chain]) => {
        const firstPlayer = chain.steps[0]?.player || '?';
        chainsInfo += `\n‚Ä¢ "${chain.originalTheme}" (iniziato da ${firstPlayer})`;
    });    
    const isWinner = sorted[0]?.[0] === state.playerName;
    showBanner({
        icon: isWinner ? 'üëë' : 'üèÜ',
        title: isWinner ? 'HAI VINTO!' : 'PARTITA TERMINATA',
        subtitle: `Vincitore: ${sorted[0]?.[0] || '-'} con ${sorted[0]?.[1] || 0} voti`,
        color: isWinner ? '#ffd700' : '#27ae60'
    });
}

async function playAgain() {
    if (!state.isHost) {
        return alert("Solo l'host pu√≤ avviare una nuova partita!");
    }
    
    await db.collection("pictionary_rooms").doc(state.roomId).update({
        stato: 'lobby',
        currentRound: 0,
        totalRounds: 0,
        chains: {},
        votes: {},
        scores: {},
        completedRound: {},
        ready: [],
        playerOrder: []
    });
    
    state.myVotes = {};
    state.isAdvancing = false;
}

function goHome() {
    window.location.href = 'index.html';
}

// ========================================
// CANVAS FUNCTIONS
// ========================================
function setupCanvas(c) {
    c.width = LOGICAL_SIZE;
    c.height = LOGICAL_SIZE;
    const cx = c.getContext('2d');
    cx.lineCap = 'round';
    cx.lineJoin = 'round';
    cx.fillStyle = '#ffffff';
    cx.fillRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
}

function getPos(e, c) {
    const rect = c.getBoundingClientRect();
    const clientX = e.clientX ?? e.touches?.[0]?.clientX;
    const clientY = e.clientY ?? e.touches?.[0]?.clientY;
    return {
        x: Math.round(((clientX - rect.left) / rect.width) * LOGICAL_SIZE),
        y: Math.round(((clientY - rect.top) / rect.height) * LOGICAL_SIZE)
    };
}

function attachCanvasListeners() {
    const start = (e) => {
        e.preventDefault();
        const pos = getPos(e, canvas);
        
        if (currentTool === 'bucket') {
            const act = { type: 'fill', color: currentColor, x: pos.x, y: pos.y };
            history.push(act);
            applyAction(act, ctx);
        } else {
            isDrawing = true;
            const color = currentTool === 'eraser' ? '#ffffff' : currentColor;
            const act = { type: 'stroke', color: color, size: currentSize, points: [pos] };
            history.push(act);
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.arc(pos.x, pos.y, currentSize / 2, 0, Math.PI * 2);
            ctx.fill();
        }
    };
    
    const move = (e) => {
        if (!isDrawing) return;
        e.preventDefault();
        const pos = getPos(e, canvas);
        const stroke = history[history.length - 1];
        const last = stroke.points[stroke.points.length - 1];
        
        if (Math.hypot(pos.x - last.x, pos.y - last.y) > MIN_DIST) {
            stroke.points.push(pos);
            ctx.beginPath();
            ctx.strokeStyle = stroke.color;
            ctx.lineWidth = stroke.size;
            ctx.lineCap = 'round';
            ctx.moveTo(last.x, last.y);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        }
    };
    
    const end = () => { isDrawing = false; };
    
    canvas.onmousedown = start;
    canvas.onmousemove = move;
    window.onmouseup = end;
    canvas.ontouchstart = start;
    canvas.ontouchmove = move;
    window.ontouchend = end;
}

function applyAction(act, cx) {
    if (act.type === 'stroke') {
        if (act.points.length === 1) {
            cx.beginPath();
            cx.fillStyle = act.color;
            cx.arc(act.points[0].x, act.points[0].y, act.size / 2, 0, Math.PI * 2);
            cx.fill();
            return;
        }
        cx.beginPath();
        cx.strokeStyle = act.color;
        cx.lineWidth = act.size;
        cx.lineCap = 'round';
        cx.lineJoin = 'round';
        cx.moveTo(act.points[0].x, act.points[0].y);
        for (let i = 1; i < act.points.length; i++) {
            cx.lineTo(act.points[i].x, act.points[i].y);
        }
        cx.stroke();
    } else if (act.type === 'fill') {
        floodFill(act.x, act.y, act.color, cx);
    }
}

function undo() {
    history.pop();
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
    history.forEach(a => applyAction(a, ctx));
}

function clearCanvas() {
    if (confirm("Pulisci tutto?")) {
        history = [];
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
    }
}

function floodFill(x, y, color, cx) {
    const img = cx.getImageData(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
    const target = getPixel(img, x, y);
    const fill = hexToRgb(color);
    if (colorsMatch(target, fill)) return;
    
    const stack = [[x, y]];
    const visited = new Set();
    
    while (stack.length && stack.length < 100000) {
        const [cx2, cy] = stack.pop();
        const key = `${cx2},${cy}`;
        if (visited.has(key)) continue;
        if (cx2 < 0 || cx2 >= LOGICAL_SIZE || cy < 0 || cy >= LOGICAL_SIZE) continue;
        if (!colorsMatch(getPixel(img, cx2, cy), target)) continue;
        
        visited.add(key);
        setPixel(img, cx2, cy, fill);
        stack.push([cx2 + 1, cy], [cx2 - 1, cy], [cx2, cy + 1], [cx2, cy - 1]);
    }
    
    cx.putImageData(img, 0, 0);
}

function getPixel(d, x, y) {
    const i = (y * LOGICAL_SIZE + x) * 4;
    return [d.data[i], d.data[i+1], d.data[i+2]];
}

function setPixel(d, x, y, c) {
    const i = (y * LOGICAL_SIZE + x) * 4;
    d.data[i] = c[0]; d.data[i+1] = c[1]; d.data[i+2] = c[2]; d.data[i+3] = 255;
}

function colorsMatch(a, b) {
    return Math.abs(a[0]-b[0]) < 15 && Math.abs(a[1]-b[1]) < 15 && Math.abs(a[2]-b[2]) < 15;
}

function hexToRgb(h) {
    const n = parseInt(h.slice(1), 16);
    return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
}

function setTool(t) {
    currentTool = t;
    document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
    document.getElementById(`tool-${t}`)?.classList.add('active');
}

function setSize(s) {
    currentSize = s;
    document.querySelectorAll('[id^="size-"]').forEach(btn => btn.classList.remove('active'));
    document.getElementById(`size-${s}`)?.classList.add('active');
}

function renderPalette() {
    const p = document.getElementById('palette');
    p.innerHTML = '';
    COLORS.forEach(c => {
        const dot = document.createElement('div');
        dot.className = `color-dot ${c === currentColor ? 'active' : ''}`;
        dot.style.background = c;
        dot.onclick = () => { currentColor = c; renderPalette(); };
        p.appendChild(dot);
    });
}

// ========================================
// COMPRESSIONE
// ========================================
function compressDrawing(historyData) {
    return historyData.map(op => {
        const cIdx = COLORS.indexOf(op.color);
        const colorCode = cIdx >= 0 ? cIdx.toString(36) : op.color;
        
        if (op.type === 'stroke') {
            let prevX = 0, prevY = 0;
            const pts = op.points.map(p => {
                const dx = p.x - prevX, dy = p.y - prevY;
                prevX = p.x; prevY = p.y;
                return `${dx.toString(36)}.${dy.toString(36)}`;
            }).join(',');
            return `S${colorCode}|${op.size.toString(36)}|${pts}`;
        } else {
            return `F${colorCode}|${op.x.toString(36)}.${op.y.toString(36)}`;
        }
    }).join('~');
}

function decompressDrawing(str) {
    if (!str) return [];
    return str.split('~').map(s => {
        const type = s.charAt(0);
        const parts = s.substring(1).split('|');
        
        const colorCode = parts[0];
        const color = colorCode.length <= 2 ? 
            COLORS[parseInt(colorCode, 36)] || '#000000' : colorCode;
        
        if (type === 'S') {
            const size = parseInt(parts[1], 36);
            const pts = []; let cx = 0, cy = 0;
            parts[2].split(',').forEach(pt => {
                const [dx, dy] = pt.split('.').map(v => parseInt(v, 36));
                cx += dx; cy += dy; pts.push({x: cx, y: cy});
            });
            return { type: 'stroke', color, size, points: pts };
        } else {
            const [x, y] = parts[1].split('.').map(v => parseInt(v, 36));
            return { type: 'fill', color, x, y };
        }
    });
}

// ========================================
// INIT
// ========================================
window.onload = async () => {
    const urlParams = new URLSearchParams(window.location.search);
    const roomCode = urlParams.get('room');
    const mioNome = localStorage.getItem('mioNome');
    
    if (!roomCode || !mioNome) {
        alert("Accedi dalla homepage per giocare!");
        window.location.href = 'index.html';
        return;
    }
    
    state.playerName = mioNome;
    state.roomId = roomCode;
    
    showScreen('loading-screen');
    
    try {
        const doc = await db.collection("pictionary_rooms").doc(roomCode).get();
        
        if (!doc.exists) {
            alert("Stanza non trovata!");
            window.location.href = 'index.html';
            return;
        }
        
        const data = doc.data();
        
        if (data.players.includes(mioNome)) {
            state.isHost = data.host === mioNome;
            enterLobby();
        } else if (data.stato === 'lobby') {
            await db.collection("pictionary_rooms").doc(roomCode).update({
                players: firebase.firestore.FieldValue.arrayUnion(mioNome)
            });
            state.isHost = false;
            enterLobby();
        } else {
            alert("La partita √® gi√† iniziata!");
            window.location.href = 'index.html';
        }
        
    } catch (e) {
        console.error("Errore auto-join:", e);
        alert("Errore di connessione!");
        window.location.href = 'index.html';
    }
};

// ========================================
// NAVIGAZIONE
// ========================================
function tornaHome() {
    if (unsubscribeRoom) {
        unsubscribeRoom();
        unsubscribeRoom = null;
    }
    
    if (timerInterval) {
        clearInterval(timerInterval);
    }
    
    window.location.href = 'index.html';
}

function showHomeButton() {
    const btn = document.getElementById('fixed-home-btn');
    if (btn) btn.style.display = 'block';
}

function hideHomeButton() {
    const btn = document.getElementById('fixed-home-btn');
    if (btn) btn.style.display = 'none';
}
</script>

</body>
</html>
