<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PICTIONARY üé®</title>
    <script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-firestore-compat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;900&family=JetBrains+Mono&display=swap');

        :root {
            --bg: #1a1a2e; --panel: #16213e; --primary: #e94560; --accent: #0f3460;
            --text: #eaeaea; --border: #0f3460; --danger: #ff6b6b; --success: #4ecdc4;
            --gold: #ffd700; --silver: #c0c0c0; --bronze: #cd7f32;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text);
            margin: 0; padding: 0; min-height: 100vh; display: flex; flex-direction: column;
        }

        /* === ANIMAZIONI === */
        @keyframes slideDown { from { transform: translateY(-100%); } to { transform: translateY(0); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.1); opacity: 0.8; } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes confetti { 0% { transform: translateY(0) rotate(0deg); opacity: 1; } 100% { transform: translateY(100vh) rotate(720deg); opacity: 0; } }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        @keyframes glow { 0%, 100% { box-shadow: 0 0 20px var(--primary); } 50% { box-shadow: 0 0 40px var(--primary), 0 0 60px var(--primary); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes timerPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.15); } }

        /* === LAYOUT === */
        .app-container {
            width: 100%; max-width: 1000px; margin: 0 auto; min-height: 100vh;
            background: var(--panel); display: flex; flex-direction: column;
            box-shadow: 0 0 50px rgba(0,0,0,0.3); position: relative;
        }

        header {
            padding: 12px 20px; border-bottom: 2px solid var(--border);
            display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(135deg, var(--panel) 0%, var(--accent) 100%);
            position: sticky; top: 0; z-index: 100;
        }

        .header-left { display: flex; align-items: center; gap: 15px; }
        .room-tag { 
            font-size: 0.7rem; color: var(--primary); font-weight: 700; 
            letter-spacing: 2px; text-transform: uppercase;
            background: rgba(233, 69, 96, 0.2); padding: 4px 10px; border-radius: 4px;
        }
        .player-name { font-weight: 900; color: var(--text); font-size: 1rem; }
        
        #timer { 
            font-family: 'JetBrains Mono'; font-weight: bold; color: var(--danger); 
            font-size: 2rem; min-width: 60px; text-align: center;
            text-shadow: 0 0 20px var(--danger);
        }
        #timer.warning { animation: pulse 0.5s infinite; color: #ff0000; }

        /* === CANVAS AREA === */
        #game-area {
            flex: 1; display: flex; flex-direction: column; 
            padding: 15px; overflow: hidden; align-items: center; justify-content: center;
            background: radial-gradient(circle at center, #1e2a4a 0%, var(--bg) 100%);
        }

        .canvas-wrapper {
            width: 100%; max-width: 500px; display: flex; flex-direction: column; gap: 10px;
        }

        .canvas-container {
            width: 100%; aspect-ratio: 1 / 1;
            background: #fff; cursor: crosshair; touch-action: none; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.4); border-radius: 12px;
            border: 3px solid var(--primary); position: relative;
            overflow: hidden;
        }

        .canvas-badge {
            position: absolute; top: 10px; left: 10px; 
            background: linear-gradient(135deg, var(--primary) 0%, #ff6b9d 100%);
            color: white; padding: 8px 15px; border-radius: 8px; 
            font-size: 0.85rem; font-weight: 700;
            pointer-events: none; z-index: 20; text-transform: uppercase;
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }
/* Badge GuessIt con categoria */
#guessit-word-badge {
    text-align: center;
    line-height: 1.3;
    padding: 12px 25px;
}

#guessit-word-badge > div:first-child {
    font-size: 0.7rem;
    opacity: 0.85;
    margin-bottom: 4px;
    letter-spacing: 1px;
}

#guessit-word-badge > div:last-child {
    font-size: 1.1rem;
    font-weight: 900;
}
        /* === MINIATURA RIFERIMENTO INGRANDIBILE === */
        .reference-thumbnail {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 100px;
            height: 100px;
            background: white;
            border: 3px solid var(--success);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            z-index: 25;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            overflow: hidden;
        }

        .reference-thumbnail:hover {
            transform: scale(3.5) translate(-35%, 15%);
            z-index: 100;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }

        .reference-thumbnail canvas {
            width: 100%;
            height: 100%;
        }

        .reference-thumbnail .label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--success);
            color: white;
            font-size: 0.5rem;
            font-weight: bold;
            text-align: center;
            padding: 2px;
            opacity: 1;
            transition: opacity 0.3s;
        }

        .reference-thumbnail:hover .label {
            opacity: 0;
        }

        canvas { width: 100%; height: 100%; display: block; border-radius: 10px; }

        /* === TOOLBAR === */
        .toolbar {
            padding: 15px; background: var(--panel); border-top: 2px solid var(--border);
            display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: center;
            position: sticky; bottom: 0; z-index: 100;
        }

        .color-palette { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; }
        .color-dot {
            width: 32px; height: 32px; border-radius: 8px; border: 3px solid transparent; 
            cursor: pointer; transition: all 0.2s;
        }
        .color-dot:hover { transform: scale(1.1); }
        .color-dot.active { 
            border-color: var(--text); transform: scale(1.2); 
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        .tools-group { 
            display: flex; gap: 5px; background: var(--bg); 
            padding: 5px; border-radius: 10px; 
        }
        
        .tool-btn {
            width: 44px; height: 44px; border: none; background: transparent; border-radius: 8px;
            cursor: pointer; display: flex; align-items: center; justify-content: center; 
            font-size: 1.3rem; color: var(--text); transition: all 0.2s;
        }
        .tool-btn:hover { background: var(--accent); }
        .tool-btn.active { 
            background: var(--primary); color: white; 
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }

        .btn {
            padding: 12px 25px; border-radius: 10px; border: none; font-family: inherit; 
            font-weight: 700; cursor: pointer; font-size: 0.9rem; transition: all 0.2s;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .btn:active { transform: scale(0.95); }
        .btn-primary { 
            background: linear-gradient(135deg, var(--primary) 0%, #ff6b9d 100%); 
            color: white; box-shadow: 0 4px 20px rgba(233, 69, 96, 0.4); 
        }
        .btn-primary:hover { box-shadow: 0 6px 30px rgba(233, 69, 96, 0.6); }
        .btn-success { 
            background: linear-gradient(135deg, var(--success) 0%, #26d0ce 100%); 
            color: white; 
        }
        .btn-secondary { background: var(--accent); color: var(--text); }
        .btn-danger { background: var(--danger); color: white; }
        .btn-gold { 
            background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%); 
            color: #1a1a2e; 
        }

        /* === OVERLAYS === */
        .overlay {
            position: fixed; inset: 0; background: var(--bg);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000; text-align: center; padding: 20px; overflow-y: auto;
        }
        .hidden { display: none !important; }

        .card {
            background: var(--panel); padding: 30px; border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4); width: 100%; max-width: 500px;
            display: flex; flex-direction: column; gap: 15px; 
            border: 2px solid var(--border); animation: fadeIn 0.3s ease;
        }

        h1 { font-size: 2rem; margin: 0; color: var(--primary); letter-spacing: -1px; }
        h2 { font-size: 1.5rem; margin: 0; color: var(--text); }
        
        input, select, textarea {
            width: 100%; padding: 14px; border-radius: 10px; border: 2px solid var(--border);
            background: var(--bg); font-family: 'JetBrains Mono', monospace; font-size: 1rem;
            outline: none; color: var(--text);
        }
        input:focus, select:focus, textarea:focus { border-color: var(--primary); }
        input::placeholder { color: #666; }

        .theme-box {
            background: linear-gradient(135deg, var(--primary) 0%, #ff6b9d 100%);
            padding: 25px; border-radius: 15px; margin: 15px 0;
            font-size: 1.8rem; font-weight: 900; color: white;
            text-transform: uppercase; letter-spacing: 2px;
            box-shadow: 0 10px 30px rgba(233, 69, 96, 0.4);
            animation: pulse 2s infinite;
        }

        /* === LOBBY === */
        .players-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px; margin: 15px 0;
        }

        .player-card {
            background: var(--bg); padding: 15px 10px; border-radius: 10px;
            text-align: center; border: 2px solid var(--border);
            transition: all 0.3s;
        }
        .player-card.ready { 
            border-color: var(--success); 
            background: rgba(78, 205, 196, 0.1);
        }
        .player-card.host::after { 
            content: 'üëë'; display: block; font-size: 1.2rem; margin-top: 5px;
        }
        .player-card .name { font-weight: 700; font-size: 0.9rem; }
        .player-card .status { font-size: 0.7rem; opacity: 0.7; margin-top: 5px; }

        /* === BANNER STILE RUZZLE === */
        .game-banner {
            position: fixed; top: 0; left: 0; right: 0;
            padding: 15px 20px; display: flex; justify-content: space-between;
            align-items: center; z-index: 9999; animation: slideDown 0.3s ease;
            flex-wrap: wrap; gap: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .banner-left { display: flex; align-items: center; gap: 12px; }
        .banner-right { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .banner-icon { font-size: 1.8rem; }
        .banner-title { font-weight: 900; font-size: 1.1rem; color: white; }
        .banner-subtitle { font-size: 0.8rem; opacity: 0.9; color: white; }

        /* ‚úÖ TIMER NEL BANNER - SEMPRE VISIBILE */
        .banner-timer {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            font-weight: 900;
            color: white;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 16px;
            border-radius: 10px;
            min-width: 90px;
            text-align: center;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.3);
        }
        .banner-timer.warning {
            background: rgba(255, 0, 0, 0.4);
            border-color: #ff0000;
            animation: timerPulse 0.5s infinite;
        }

        /* === GALLERIA === */
        .gallery-container {
            width: 100%; max-width: 1200px; padding: 20px;
        }

        .chain-card {
            background: var(--panel); border-radius: 15px; padding: 20px;
            margin-bottom: 30px; border: 2px solid var(--border);
        }

        .chain-header {
            display: flex; justify-content: space-between; align-items: center;
            padding-bottom: 15px; border-bottom: 2px solid var(--border);
            margin-bottom: 20px;
        }

        .chain-title { 
            font-size: 1.2rem; font-weight: 900; color: var(--primary);
            display: flex; align-items: center; gap: 10px;
        }

        .chain-flow {
            display: flex; overflow-x: auto; gap: 20px; padding: 10px 0;
            scroll-snap-type: x mandatory;
        }

        .chain-step {
            min-width: 200px; max-width: 200px; scroll-snap-align: start;
            background: var(--bg); border-radius: 12px; padding: 10px;
            display: flex; flex-direction: column; align-items: center;
            border: 2px solid var(--border); transition: all 0.3s;
            cursor: pointer;
        }
        .chain-step:hover { border-color: var(--primary); transform: translateY(-5px); }
        .chain-step.voted { border-color: var(--gold); box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }

        .step-canvas {
            width: 100%; aspect-ratio: 1/1; background: white;
            border-radius: 8px; overflow: hidden; margin-bottom: 10px;
        }
        .step-canvas canvas { width: 100%; height: 100%; }

        .step-info { text-align: center; width: 100%; }
        .step-player { font-weight: 700; font-size: 0.85rem; color: var(--primary); }
        .step-guess { 
            font-size: 0.75rem; color: var(--text); opacity: 0.8; 
            margin-top: 5px; font-style: italic;
        }

        .chain-arrow {
            display: flex; align-items: center; font-size: 2rem; color: var(--primary);
            min-width: 40px; justify-content: center;
        }

        /* === VOTAZIONE === */
        .vote-btn {
            margin-top: 10px; width: 100%; padding: 8px;
            background: var(--accent); border: none; border-radius: 6px;
            color: white; font-weight: 700; cursor: pointer; transition: all 0.2s;
        }
        .vote-btn:hover { background: var(--primary); }
        .vote-btn.voted { background: var(--gold); color: #1a1a2e; }
/* ‚úÖ Evidenzia i propri disegni durante la votazione */
.chain-step.my-drawing {
    border-color: var(--primary);
    background: rgba(233, 69, 96, 0.1);
    position: relative;
}

.chain-step.my-drawing::before {
    content: 'üë§ TUO';
    position: absolute;
    top: 5px;
    right: 5px;
    background: var(--primary);
    color: white;
    font-size: 0.6rem;
    font-weight: bold;
    padding: 3px 8px;
    border-radius: 10px;
    z-index: 10;
}
        /* === RISULTATI === */
        .results-container {
            width: 100%; max-width: 600px;
        }

        .podium {
            display: flex; justify-content: center; align-items: flex-end;
            gap: 20px; margin: 30px 0; height: 200px;
        }

        .podium-place {
            display: flex; flex-direction: column; align-items: center;
            animation: bounce 0.5s ease;
        }

        .podium-avatar {
            width: 60px; height: 60px; border-radius: 50%;
            background: var(--panel); display: flex; align-items: center;
            justify-content: center; font-size: 1.5rem; font-weight: 900;
            border: 3px solid;
        }

        .podium-bar {
            width: 80px; display: flex; flex-direction: column;
            align-items: center; justify-content: flex-end;
            padding: 10px; border-radius: 10px 10px 0 0;
            margin-top: 10px;
        }

        .place-1 .podium-bar { height: 120px; background: linear-gradient(180deg, var(--gold) 0%, #cc9900 100%); }
        .place-1 .podium-avatar { border-color: var(--gold); }
        .place-2 .podium-bar { height: 90px; background: linear-gradient(180deg, var(--silver) 0%, #999 100%); }
        .place-2 .podium-avatar { border-color: var(--silver); }
        .place-3 .podium-bar { height: 60px; background: linear-gradient(180deg, var(--bronze) 0%, #8b5a2b 100%); }
        .place-3 .podium-avatar { border-color: var(--bronze); }

        .podium-name { font-weight: 700; font-size: 0.8rem; margin-top: 5px; }
        .podium-score { font-size: 1.2rem; font-weight: 900; color: #1a1a2e; }

        .full-ranking {
            background: var(--panel); border-radius: 15px; padding: 20px;
            margin-top: 20px;
        }

        .ranking-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 15px; border-radius: 8px; margin-bottom: 8px;
            background: var(--bg);
        }
        .ranking-row.me { border: 2px solid var(--primary); }

        .ranking-position { 
            font-weight: 900; font-size: 1.1rem; min-width: 30px;
        }
        .ranking-name { flex: 1; margin-left: 15px; font-weight: 600; }
        .ranking-score { font-weight: 900; color: var(--primary); }

        /* === SPINNER === */
        .spinner {
            width: 30px; height: 30px; border: 3px solid white;
            border-top-color: transparent; border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* === CONFETTI === */
        .confetti {
            position: fixed; width: 10px; height: 10px;
            z-index: 9999; pointer-events: none;
            animation: confetti 3s forwards;
        }

        /* === LOADING SCREEN === */
        #loading-screen {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #loading-screen .spinner-big {
            width: 60px;
            height: 60px;
            border: 4px solid var(--primary);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        #loading-screen p {
            color: var(--text);
            font-size: 1.1rem;
            opacity: 0.8;
        }

        /* === PULSANTE HOME FISSO === */
#fixed-home-btn {
    position: fixed;
    bottom: 20px;
    left: 20px;  /* ‚úÖ Spostato a sinistra */
    z-index: 99999;
    display: none;
}

/* ‚úÖ In GuessIt, sposta ancora pi√π a sinistra */
#guessit-screen ~ #fixed-home-btn,
body:has(#guessit-screen:not(.hidden)) #fixed-home-btn {
    left: 110px;
    bottom: 20px;
}

        #fixed-home-btn button {
            background: var(--panel);
            color: var(--text);
            border: 2px solid var(--primary);
            padding: 12px 20px;
            border-radius: 50px;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            transition: all 0.2s ease;
        }

        #fixed-home-btn button:hover {
            transform: scale(1.05);
            background: var(--primary);
            color: white;
            box-shadow: 0 6px 25px rgba(233, 69, 96, 0.4);
        }

        /* === RESPONSIVE === */
        @media (max-width: 600px) {
            .card { padding: 20px; }
            h1 { font-size: 1.5rem; }
            .theme-box { font-size: 1.3rem; padding: 20px; }
            .toolbar { padding: 10px; gap: 8px; }
            .color-dot { width: 28px; height: 28px; }
            .tool-btn { width: 38px; height: 38px; font-size: 1.1rem; }
            .btn { padding: 10px 18px; font-size: 0.8rem; }
            .game-banner { flex-direction: column; text-align: center; }
            .banner-left, .banner-right { justify-content: center; width: 100%; }
            .banner-timer { font-size: 1.5rem; padding: 6px 12px; }
            .reference-thumbnail:hover {
                transform: scale(2.5) translate(-20%, 10%);
            }
        }
/* ========================================
   LAYOUT FULLSCREEN CANVAS - FIXED
   ======================================== */

#game-ui {
    position: fixed !important;
    inset: 0;
    display: flex !important;
    background: var(--bg);
    z-index: 500;
}

.toolbar-left {
    width: 90px;
    min-width: 90px;
    background: var(--panel);
    border-right: 2px solid var(--border);
    display: flex;
    flex-direction: column;
    padding: 15px 10px;
    gap: 20px;
    overflow-y: auto;
    z-index: 100;
}

.tool-section {
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: center;
    padding-bottom: 15px;
    border-bottom: 1px solid var(--border);
}

.tool-section:last-child {
    border-bottom: none;
    margin-top: auto;
    padding-bottom: 0;
}

.tool-label {
    font-size: 0.65rem;
    font-weight: bold;
    opacity: 0.7;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    text-align: center;
    margin-bottom: 5px;
}

.toolbar-left .tool-btn {
    width: 50px;
    height: 50px;
    font-size: 1.3rem;
    border: 2px solid var(--border);
    border-radius: 10px;
    background: var(--bg);
    color: var(--text);
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
}

.toolbar-left .tool-btn:hover {
    background: var(--accent);
    border-color: var(--primary);
}

.toolbar-left .tool-btn.active {
    background: var(--primary);
    border-color: var(--primary);
    color: white;
    box-shadow: 0 0 15px rgba(233, 69, 96, 0.4);
}

/* Slider dimensione pennello */
.size-slider-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    width: 100%;
}

.size-slider {
    width: 70px;
    height: 8px;
    -webkit-appearance: none;
    appearance: none;
    background: var(--bg);
    border-radius: 4px;
    outline: none;
    cursor: pointer;
}

.size-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: var(--primary);
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid white;
}

.size-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: var(--primary);
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid white;
}

.size-preview {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: var(--bg);
    border: 2px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
}

.size-preview-dot {
    border-radius: 50%;
    background: currentColor;
    transition: all 0.1s;
}

.size-preview-text {
    position: absolute;
    bottom: 2px;
    font-size: 0.6rem;
    font-weight: bold;
    color: var(--text);
    opacity: 0.7;
}

/* Color picker */
.color-picker-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    width: 100%;
}

.color-wheel {
    width: 60px;
    height: 60px;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    background: transparent;
    padding: 0;
    overflow: hidden;
}

.color-wheel::-webkit-color-swatch-wrapper {
    padding: 0;
}

.color-wheel::-webkit-color-swatch {
    border-radius: 50%;
    border: 3px solid var(--border);
}

.color-wheel::-moz-color-swatch {
    border-radius: 50%;
    border: 3px solid var(--border);
}

.quick-colors {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 4px;
    width: 100%;
}

.qcolor {
    width: 100%;
    aspect-ratio: 1;
    border-radius: 4px;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.15s;
}

.qcolor:hover {
    transform: scale(1.15);
    border-color: white;
    z-index: 10;
}

.qcolor.active {
    border-color: white;
    box-shadow: 0 0 10px rgba(255,255,255,0.5);
}
/* Pulsanti dimensione */
.size-dot {
    display: block;
    background: currentColor;
    border-radius: 50%;
}

.size-btn {
    display: flex !important;
    align-items: center;
    justify-content: center;
}

.size-btn.active .size-dot {
    background: white;
}
/* ========================================
   CANVAS AREA - QUADRATO PIENA ALTEZZA
   ======================================== */

.canvas-area-fullscreen {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    background: #1a1a2e;
    overflow: hidden;
    padding: 20px;
}

/* Container per mantenere il canvas quadrato */
.canvas-square-container {
    position: relative;
    height: calc(100vh - 40px);
    width: calc(100vh - 40px);
    max-width: calc(100vw - 250px);
    max-height: calc(100vw - 250px);
}

.canvas-square-container canvas#mainCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100% !important;
    height: 100% !important;
    background: white;
    border-radius: 12px;
    border: 4px solid var(--primary);
    box-shadow: 0 10px 50px rgba(0,0,0,0.5);
    cursor: crosshair;
    touch-action: none;
}

.canvas-badge-fullscreen {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, var(--primary) 0%, #ff6b9d 100%);
    color: white;
    padding: 10px 25px;
    border-radius: 25px;
    font-size: 1rem;
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: 0 5px 20px rgba(233, 69, 96, 0.5);
    z-index: 50;
    white-space: nowrap;
    max-width: 90%;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Miniatura riferimento */
.reference-thumbnail-fullscreen {
    position: absolute;
    top: 60px;
    right: 20px;
    width: 120px;
    height: 120px;
    background: white;
    border: 3px solid var(--success);
    border-radius: 10px;
    box-shadow: 0 5px 25px rgba(0,0,0,0.4);
    z-index: 50;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    overflow: hidden;
}

.reference-thumbnail-fullscreen:hover {
    transform: scale(2.5) translate(-30%, 20%);
    z-index: 200;
    box-shadow: 0 15px 50px rgba(0,0,0,0.6);
}

.reference-thumbnail-fullscreen canvas {
    width: 100%;
    height: calc(100% - 20px);
    display: block;
}

.reference-thumbnail-fullscreen .ref-label {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--success);
    color: white;
    font-size: 0.5rem;
    font-weight: bold;
    text-align: center;
    padding: 3px;
    transition: opacity 0.2s;
}

.reference-thumbnail-fullscreen:hover .ref-label {
    opacity: 0;
}

/* ========================================
   INFO BAR DESTRA
   ======================================== */

.info-bar-right {
    width: 100px;
    min-width: 100px;
    background: var(--panel);
    border-left: 2px solid var(--border);
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px 10px;
    gap: 25px;
}

.timer-box {
    text-align: center;
    padding: 15px 10px;
    background: var(--bg);
    border-radius: 12px;
    width: 100%;
}

.timer-label {
    font-size: 0.7rem;
    opacity: 0.7;
    margin-bottom: 8px;
    text-transform: uppercase;
}

.timer-display {
    font-family: 'JetBrains Mono', monospace;
    font-size: 2.2rem;
    font-weight: 900;
    color: var(--success);
    text-shadow: 0 0 20px var(--success);
    line-height: 1;
}

.timer-display.warning {
    color: var(--danger) !important;
    text-shadow: 0 0 20px var(--danger) !important;
    animation: pulse 0.5s infinite;
}

.round-info {
    font-size: 0.7rem;
    font-weight: bold;
    color: var(--primary);
    text-align: center;
    padding: 10px 5px;
    background: rgba(233, 69, 96, 0.15);
    border-radius: 8px;
    width: 100%;
    line-height: 1.3;
}

.player-info {
    font-size: 0.75rem;
    font-weight: 900;
    text-align: center;
    word-break: break-all;
    padding: 10px 5px;
    background: var(--bg);
    border-radius: 8px;
    width: 100%;
}

/* ========================================
   RESPONSIVE
   ======================================== */

@media (max-width: 768px) {
    .toolbar-left {
        width: 70px;
        min-width: 70px;
        padding: 10px 5px;
        gap: 15px;
    }
    
    .toolbar-left .tool-btn {
        width: 40px;
        height: 40px;
        font-size: 1.1rem;
    }
    
    .size-slider {
        width: 55px;
    }
    
    .size-preview {
        width: 40px;
        height: 40px;
    }
    
    .color-wheel {
        width: 45px;
        height: 45px;
    }
    
    .info-bar-right {
        width: 70px;
        min-width: 70px;
        padding: 15px 5px;
    }
    
    .timer-display {
        font-size: 1.6rem;
    }
    
    .canvas-square-container {
        height: calc(100vh - 30px);
        width: calc(100vh - 30px);
        max-width: calc(100vw - 160px);
        max-height: calc(100vw - 160px);
    }
    
    .reference-thumbnail-fullscreen {
        width: 80px;
        height: 80px;
        top: 50px;
        right: 10px;
    }
    
    .canvas-badge-fullscreen {
        font-size: 0.8rem;
        padding: 8px 15px;
    }
}

@media (max-width: 500px) {
    .toolbar-left {
        width: 55px;
        min-width: 55px;
    }
    
    .toolbar-left .tool-btn {
        width: 35px;
        height: 35px;
        font-size: 1rem;
    }
    
    .info-bar-right {
        width: 55px;
        min-width: 55px;
    }
    
    .timer-display {
        font-size: 1.3rem;
    }
    
    .canvas-square-container {
        max-width: calc(100vw - 130px);
        max-height: calc(100vw - 130px);
    }
}
    </style>
</head>
<body>

<!-- LOADING -->
<div id="loading-screen" class="overlay">
    <div class="spinner-big"></div>
    <p>Caricamento partita...</p>
</div>

<!-- LOBBY (gestita solo da banner, background neutro) -->
<div id="lobby-screen" class="overlay hidden" style="justify-content: center; align-items: center;">
    <div style="text-align: center; padding: 40px;">
        <div style="font-size: 5rem; margin-bottom: 20px;">üé®</div>
        <h1 style="margin-bottom: 10px;">PICTIONARY</h1>
        <p style="opacity: 0.7; margin-bottom: 30px;">In attesa nella lobby...</p>
        
        <div id="lobby-players-display" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 30px;"></div>
        
        <div style="background: var(--panel); padding: 20px; border-radius: 15px; max-width: 300px; margin: 0 auto;">
            <div style="text-align: center; padding: 10px; background: rgba(78, 205, 196, 0.1); border-radius: 8px; margin-bottom: 15px;">
                <div style="font-size: 0.75rem; opacity: 0.7;">ROUND AUTOMATICI</div>
                <div style="font-size: 1.5rem; font-weight: 900; color: var(--success);">
                    <span id="auto-rounds-display">2</span> round
                </div>
            </div>
        </div>
    </div>
</div>

<!-- CANVAS FULLSCREEN -->
<div id="game-ui" class="hidden">
    
    <!-- TOOLBAR SINISTRA -->
    <div class="toolbar-left">
        <!-- Strumenti -->
        <div class="tool-section">
            <div class="tool-label">Strumenti</div>
            <button class="tool-btn active" id="tool-pen" onclick="setTool('pen')" title="Pennello">‚úèÔ∏è</button>
            <button class="tool-btn" id="tool-eraser" onclick="setTool('eraser')" title="Gomma">üßπ</button>
            <button class="tool-btn" id="tool-bucket" onclick="setTool('bucket')" title="Riempi">ü™£</button>
        </div>
        
        <!-- Azioni -->
        <div class="tool-section">
            <div class="tool-label">Azioni</div>
            <button class="tool-btn" onclick="undo()" title="Annulla">‚Ü©Ô∏è</button>
            <button class="tool-btn" onclick="clearCanvas()" title="Pulisci">üóëÔ∏è</button>
        </div>
        
<!-- Dimensione -->
<div class="tool-section">
    <div class="tool-label">Dimensione</div>
    <button class="tool-btn size-btn" id="size-small" onclick="setSize(6)" title="Piccolo">
        <span class="size-dot" style="width: 6px; height: 6px;"></span>
    </button>
    <button class="tool-btn size-btn active" id="size-medium" onclick="setSize(10)" title="Medio">
        <span class="size-dot" style="width: 10px; height: 10px;"></span>
    </button>
    <button class="tool-btn size-btn" id="size-large" onclick="setSize(16)" title="Grande">
        <span class="size-dot" style="width: 16px; height: 16px;"></span>
    </button>
</div>
        
        <!-- Colore -->
        <div class="tool-section">
            <div class="tool-label">Colore</div>
            <div class="color-picker-container">
                <input type="color" id="color-picker" class="color-wheel" value="#000000" 
                       oninput="setColorFromPicker(this.value)">
                <div class="quick-colors" id="quick-colors"></div>
            </div>
        </div>
        
        <!-- Pulsante FATTO -->
        <div class="tool-section">
            <button class="btn btn-success" onclick="finishCurrentPhase()" 
                    style="width: 100%; padding: 12px 8px; font-size: 0.8rem;">
                ‚úÖ FATTO
            </button>
        </div>
    </div>
    
    <!-- AREA CANVAS CENTRALE -->
    <div class="canvas-area-fullscreen">
        <!-- Badge tema -->
        <div class="canvas-badge-fullscreen" id="canvas-theme-badge">TEMA</div>
        
        <!-- Miniatura riferimento -->
        <div class="reference-thumbnail-fullscreen" id="reference-thumbnail" style="display: none;">
            <canvas id="reference-mini-canvas"></canvas>
            <div class="ref-label">üëÜ HOVER</div>
        </div>
        
        <!-- Container quadrato per il canvas -->
        <div class="canvas-square-container">
            <canvas id="mainCanvas"></canvas>
        </div>
    </div>
    
    <!-- INFO BAR DESTRA -->
    <div class="info-bar-right">
        <div class="timer-box">
            <div class="timer-label">‚è±Ô∏è Tempo</div>
            <div id="timer" class="timer-display">60</div>
        </div>
        <div class="round-info" id="ui-round-info">ROUND 1/2</div>
        <div class="player-info" id="ui-player">PLAYER</div>
    </div>
</div>

<!-- ATTESA -->
<div id="waiting-screen" class="overlay hidden">
    <div class="card">
        <div class="spinner" style="margin: 0 auto;"></div>
        <h2 id="waiting-title">ATTESA</h2>
        <p id="waiting-message" style="opacity: 0.7;">Aspettando gli altri giocatori...</p>
        <div id="waiting-progress" style="margin-top: 15px; font-size: 1.2rem; color: var(--success);">
            <span id="done-count">0</span>/<span id="total-players">0</span>
        </div>
    </div>
</div>

<!-- GALLERIA + VOTAZIONE -->
<div id="gallery-screen" class="overlay hidden" style="justify-content: flex-start; padding: 0;">
    <header style="width: 100%; position: sticky; top: 0;">
        <div class="header-left">
            <span style="font-size: 1.5rem;">üñºÔ∏è</span>
            <span style="font-weight: 900;">GALLERIA</span>
        </div>
        <div id="vote-status" style="font-size: 0.85rem; opacity: 0.8;"></div>
    </header>
    
    <div class="gallery-container" id="gallery-container"></div>
    
    <div style="position: sticky; bottom: 0; width: 100%; padding: 15px; 
                background: var(--panel); border-top: 2px solid var(--border);">
        <button class="btn btn-gold" style="width: 100%; padding: 18px;" 
                onclick="confirmVotes()" id="confirm-votes-btn">
            ‚úÖ CONFERMA VOTI
        </button>
    </div>
</div>

<!-- RISULTATI -->
<div id="results-screen" class="overlay hidden">
    <div class="results-container">
        <div style="text-align: center; margin-bottom: 30px;">
            <div style="font-size: 4rem;">üèÜ</div>
            <h1 style="margin: 10px 0;">RISULTATI</h1>
        </div>
        
        <div class="podium" id="podium"></div>
        
        <div class="full-ranking" id="full-ranking"></div>
        
        <div style="display: flex; gap: 15px; margin-top: 30px;">
            <button class="btn btn-primary" style="flex: 1;" onclick="playAgain()">
                üîÑ RIVINCITA
            </button>
            <button class="btn btn-secondary" style="flex: 1;" onclick="goHome()">
                üè† HOME
            </button>
        </div>
    </div>
</div>

<!-- GUESS IT - LAYOUT UGUALE A CLASSICO -->
<div id="guessit-screen" class="hidden">
    <div style="position: fixed; inset: 0; display: flex; background: var(--bg); z-index: 500;">
        
        <!-- TOOLBAR SINISTRA (solo per disegnatore) -->
        <div class="toolbar-left" id="guessit-toolbar-left" style="display: none;">
            <!-- Strumenti -->
            <div class="tool-section">
                <div class="tool-label">Strumenti</div>
                <button class="tool-btn active" id="gi-tool-pen" onclick="setGuessItTool('pen')" title="Pennello">‚úèÔ∏è</button>
                <button class="tool-btn" id="gi-tool-eraser" onclick="setGuessItTool('eraser')" title="Gomma">üßπ</button>
                <button class="tool-btn" id="gi-tool-bucket" onclick="setGuessItTool('bucket')" title="Riempi">ü™£</button>
            </div>
            
            <!-- Azioni -->
            <div class="tool-section">
                <div class="tool-label">Azioni</div>
                <button class="tool-btn" onclick="undoGuessIt()" title="Annulla">‚Ü©Ô∏è</button>
                <button class="tool-btn" onclick="clearGuessItCanvas()" title="Pulisci">üóëÔ∏è</button>
            </div>
            
            <!-- Dimensione -->
            <div class="tool-section">
                <div class="tool-label">Dimensione</div>
                <button class="tool-btn size-btn" id="gi-size-small" onclick="setGuessItSize(4)" title="Piccolo">
                    <span class="size-dot" style="width: 8px; height: 8px;"></span>
                </button>
                <button class="tool-btn size-btn active" id="gi-size-medium" onclick="setGuessItSize(12)" title="Medio">
                    <span class="size-dot" style="width: 16px; height: 16px;"></span>
                </button>
                <button class="tool-btn size-btn" id="gi-size-large" onclick="setGuessItSize(28)" title="Grande">
                    <span class="size-dot" style="width: 28px; height: 28px;"></span>
                </button>
            </div>
            
            <!-- Colore -->
            <div class="tool-section">
                <div class="tool-label">Colore</div>
                <div class="color-picker-container">
                    <input type="color" id="gi-color-picker" class="color-wheel" value="#000000" 
                           oninput="setGuessItColor(this.value)">
                    <div class="quick-colors" id="gi-quick-colors"></div>
                </div>
            </div>
        </div>
        
        <!-- PLACEHOLDER SINISTRA (per indovinatori) -->
        <div id="guessit-placeholder-left" style="
            width: 90px; min-width: 90px; background: var(--panel);
            border-right: 2px solid var(--border); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            padding: 20px;">
            <div style="font-size: 3rem; margin-bottom: 15px;">üîÆ</div>
            <div style="text-align: center; font-size: 0.75rem; opacity: 0.7; line-height: 1.4;">
                Indovina<br>cosa sta<br>disegnando!
            </div>
        </div>
        
        <!-- AREA CANVAS CENTRALE -->
        <div class="canvas-area-fullscreen">
            <!-- Badge parola (solo disegnatore) -->
            <div class="canvas-badge-fullscreen" id="guessit-word-badge" style="display: none;">
                DISEGNA: ???
            </div>
            
            <!-- Info chi disegna (solo indovinatori) -->
            <div id="guessit-drawer-info" style="
                position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
                background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
                color: white; padding: 10px 25px; border-radius: 25px;
                font-size: 1rem; font-weight: 900; text-transform: uppercase;
                box-shadow: 0 5px 20px rgba(155, 89, 182, 0.5);
                z-index: 50; display: none;">
                üé® ??? STA DISEGNANDO...
            </div>
            
            <!-- Container quadrato per il canvas -->
            <div class="canvas-square-container">
                <canvas id="guessitCanvas" style="
                    position: absolute; top: 0; left: 0;
                    width: 100% !important; height: 100% !important;
                    background: white; border-radius: 12px;
                    border: 4px solid var(--primary);
                    box-shadow: 0 10px 50px rgba(0,0,0,0.5);
                    touch-action: none;
                "></canvas>
            </div>
        </div>
        
        <!-- INFO BAR DESTRA -->
        <div class="info-bar-right" style="width: 110px; min-width: 110px;">
            <div class="timer-box">
                <div class="timer-label">‚è±Ô∏è Tempo</div>
                <div id="guessit-timer" class="timer-display">60</div>
            </div>
            
            <div class="round-info" id="guessit-round-info">ROUND 1/5</div>
            
            <div style="text-align: center; padding: 10px 5px; background: var(--bg); border-radius: 8px; width: 100%;">
                <div style="font-size: 0.65rem; opacity: 0.7;">TU</div>
                <div id="guessit-my-score" style="font-size: 1.5rem; font-weight: 900; color: var(--success);">0</div>
            </div>
            
            <div style="text-align: center; padding: 8px 5px; background: rgba(233, 69, 96, 0.15); border-radius: 8px; width: 100%;">
                <div style="font-size: 0.6rem; opacity: 0.7;">üé® DRAWER</div>
                <div id="guessit-drawer-score" style="font-size: 1.2rem; font-weight: 900; color: var(--primary);">0</div>
            </div>
        </div>
        
        <!-- SIDEBAR RISPOSTE -->
        <div id="guessit-answers-sidebar" style="
            width: 260px; min-width: 260px; background: var(--panel);
            border-left: 2px solid var(--border);
            display: none; flex-direction: column;">
            
            <div style="padding: 12px; border-bottom: 2px solid var(--border); text-align: center;">
                <div style="font-weight: 900; font-size: 0.95rem;">üí¨ RISPOSTE</div>
            </div>
            
            <div id="guessit-feed" style="flex: 1; overflow-y: auto; padding: 10px;">
                <div style="text-align: center; opacity: 0.5; padding: 20px; font-size: 0.8rem;">
                    Le risposte appariranno qui...
                </div>
            </div>
            
            <!-- Avviso disegnatore -->
            <div id="guessit-drawer-notice" style="
                padding: 15px; text-align: center; display: none;
                background: rgba(233, 69, 96, 0.1); border-top: 2px solid var(--border);">
                <div style="font-size: 0.85rem; opacity: 0.8;">
                    Sei il disegnatore!<br>
                    <span style="font-size: 0.75rem;">Clicca ‚úÖ ACCETTA per approvare risposte simili</span>
                </div>
            </div>
            
            <!-- Input risposta (solo indovinatori) -->
            <div id="guessit-input-area" style="padding: 12px; border-top: 2px solid var(--border); display: none;">
                <input type="text" id="guessit-input" placeholder="Cosa pensi sia?" 
                       autocomplete="off" autocorrect="off" spellcheck="false"
                       style="margin-bottom: 8px; font-size: 0.95rem; text-align: center; padding: 10px;">
                <button class="btn btn-primary" onclick="submitGuessItAnswer()" style="width: 100%; padding: 12px;">
                    üéØ INDOVINA!
                </button>
            </div>
        </div>
        
    </div>
</div>
<div id="fixed-home-btn">
    <button onclick="tornaHome()">üè† HOME</button>
</div>

<script>
// ========================================
// FIREBASE CONFIG
// ========================================
const firebaseConfig = {
    apiKey: "AIzaSyCNo7o2Ft22JDEyJ97BspE3Kur5DNAPKQc",
    authDomain: "funatwork-cd237.firebaseapp.com",
    projectId: "funatwork-cd237",
    storageBucket: "funatwork-cd237.firebasestorage.app",
    messagingSenderId: "798226885203",
    appId: "1:798226885203:web:ce83f4d9e96b82266274a6"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// ========================================
// DATABASE TEMI PICTIONARY - 500+ PAROLE
// ========================================

const THEMES_DATABASE = {
    
    // ========================================
    // üé≠ ALL PLAY (AP) - Parole/Frasi generiche
    // ========================================
    allPlay: [
        // Concetti astratti
        "Libert√†", "Amore", "Felicit√†", "Paura", "Rabbia", "Gelosia", "Nostalgia",
        "Sogno", "Incubo", "Speranza", "Destino", "Fortuna", "Sfortuna", "Caos",
        "Pace", "Guerra", "Silenzio", "Rumore", "Infinito", "Eternit√†",
        
        // Espressioni idiomatiche
        "Avere le mani in pasta", "Essere al settimo cielo", "Avere la testa fra le nuvole",
        "Prendere due piccioni con una fava", "Non avere peli sulla lingua",
        "Avere un diavolo per capello", "Essere in alto mare", "Fare il passo pi√π lungo della gamba",
        "Mettere il carro davanti ai buoi", "Piangere sul latte versato",
        "Cercare un ago in un pagliaio", "Avere le farfalle nello stomaco",
        "Essere come cane e gatto", "Avere la coda di paglia", "Fare orecchie da mercante",
        "Scoprire l'acqua calda", "Vendere fumo", "Avere il pollice verde",
        "Essere al verde", "Vedere tutto rosa", "Essere nero dalla rabbia",
        
        // Proverbi famosi
        "Chi dorme non piglia pesci", "Chi va piano va sano e va lontano",
        "Meglio un uovo oggi che una gallina domani", "Il lupo perde il pelo ma non il vizio",
        "Tra il dire e il fare c'√® di mezzo il mare", "L'erba del vicino √® sempre pi√π verde",
        "Non √® tutto oro quel che luccica", "Chi trova un amico trova un tesoro",
        
        // Situazioni di vita
        "Primo appuntamento", "Colloquio di lavoro", "Esame universitario",
        "Matrimonio", "Divorzio", "Trasloco", "Vacanza rovinata",
        "Cena di Natale", "Capodanno", "Compleanno a sorpresa",
        "Riunione di famiglia", "Laurea", "Pensionamento",
        
        // Momenti della giornata
        "Sveglia del luned√¨", "Pausa caff√®", "Ora di punta", "Cena romantica",
        "Notte insonne", "Domenica pigra", "Venerd√¨ sera", "Luned√¨ mattina",
        
        // Emozioni complesse
        "Imbarazzo", "Vergogna", "Orgoglio", "Gratitudine", "Compassione",
        "Invidia", "Stupore", "Meraviglia", "Disgusto", "Terrore",
        "Euforia", "Malinconia", "Serenit√†", "Ansia", "Paranoia"
    ],
    
    // ========================================
    // üíÄ DIFFICULT (D) - Parole difficili
    // ========================================
    difficult: [
        // Concetti filosofici
        "Esistenzialismo", "Nichilismo", "Karma", "D√©j√† vu", "Paradosso",
        "Utopia", "Distopia", "Metamorfosi", "Reincarnazione", "Trascendenza",
        "Relativismo", "Determinismo", "Libero arbitrio", "Coscienza",
        
        // Termini tecnici/scientifici
        "Fotosintesi", "Gravit√†", "Magnetismo", "Evoluzione", "Big Bang",
        "Buco nero", "Galassia", "Atomo", "Molecola", "DNA",
        "Ecosistema", "Biodiversit√†", "Cambiamento climatico",
        
        // Parole straniere usate in italiano
        "Serendipit√†", "Zeitgeist", "Wanderlust", "Hygge", "Saudade",
        "Mamihlapinatapai", "Schadenfreude", "Ubuntu", "Ikigai",
        
        // Concetti astratti difficili
        "Ironia della sorte", "Effetto farfalla", "Profezia autoavverante",
        "Dissonanza cognitiva", "Sindrome dell'impostore", "Zona di comfort",
        "Punto di non ritorno", "Momento eureka", "Epifania",
        
        // Espressioni complesse
        "Silenzio assordante", "Dolce far niente", "Amor proprio",
        "Male di vivere", "Flusso di coscienza", "Crisi di mezza et√†",
        "Sindrome di Peter Pan", "Complesso di inferiorit√†",
        
        // Fenomeni naturali complessi
        "Aurora boreale", "Eclissi solare", "Tsunami", "Terremoto",
        "Eruzione vulcanica", "Tornado", "Miraggio", "Arcobaleno doppio",
        
        // Termini artistici/culturali
        "Chiaroscuro", "Prospettiva", "Surrealismo", "Impressionismo",
        "Minimalismo", "Barocco", "Rinascimento", "Art Nouveau"
    ],
    
    // ========================================
    // üèÉ ACTIONS (A) - Verbi e azioni
    // ========================================
    actions: [
        // Azioni quotidiane
        "Svegliarsi", "Dormire", "Mangiare", "Bere", "Camminare", "Correre",
        "Saltare", "Nuotare", "Volare", "Guidare", "Cucinare", "Pulire",
        "Lavare", "Stirare", "Studiare", "Lavorare", "Leggere", "Scrivere",
        
        // Azioni sportive
        "Sciare", "Pattinare", "Arrampicarsi", "Tuffarsi", "Remare",
        "Pedalare", "Boxare", "Sollevare pesi", "Fare yoga", "Fare stretching",
        "Palleggiare", "Tirare in porta", "Schiacciare", "Servire",
        
        // Azioni espressive
        "Ridere", "Piangere", "Urlare", "Sussurrare", "Cantare", "Ballare",
        "Applaudire", "Fischiare", "Sbadigliare", "Starnutire", "Tossire",
        "Russare", "Singhiozzare", "Sospirare", "Gemere",
        
        // Azioni comunicative
        "Parlare", "Ascoltare", "Spiegare", "Discutere", "Litigare",
        "Fare pace", "Confessare", "Mentire", "Promettere", "Giurare",
        "Pregare", "Supplicare", "Ordinare", "Chiedere", "Rispondere",
        
        // Azioni manuali
        "Tagliare", "Incollare", "Cucire", "Dipingere", "Disegnare",
        "Scolpire", "Costruire", "Demolire", "Riparare", "Rompere",
        "Piegare", "Stendere", "Avvolgere", "Svolgere", "Annodare",
        
        // Azioni di movimento
        "Strisciare", "Gattonare", "Rotolare", "Scivolare", "Inciampare",
        "Cadere", "Alzarsi", "Sedersi", "Sdraiarsi", "Inginocchiarsi",
        "Accovacciarsi", "Chinarsi", "Allungarsi", "Stiracchiarsi",
        
        // Azioni sociali
        "Abbracciare", "Baciare", "Stringere la mano", "Salutare",
        "Fare l'occhiolino", "Fare le corna", "Fare il dito medio",
        "Fare la linguaccia", "Fare la faccia arrabbiata",
        
        // Azioni lavorative
        "Digitare", "Fotocopiare", "Stampare", "Telefonare", "Videochiamare",
        "Presentare", "Negoziare", "Firmare", "Timbrare", "Archiviare",
        
        // Azioni domestiche
        "Spolverare", "Aspirare", "Lavare i piatti", "Fare il bucato",
        "Stendere i panni", "Fare il letto", "Apparecchiare", "Sparecchiare",
        "Innaffiare", "Potare", "Falciare", "Rastrellare"
    ],
    
    // ========================================
    // üë§ PERSON/PLACE/ANIMAL (P) - Nomi propri e creature
    // ========================================
    personPlaceAnimal: [
        // Professioni
        "Medico", "Infermiere", "Pompiere", "Poliziotto", "Avvocato",
        "Giudice", "Insegnante", "Professore", "Chef", "Cameriere",
        "Barista", "Meccanico", "Elettricista", "Idraulico", "Muratore",
        "Architetto", "Ingegnere", "Pilota", "Astronauta", "Scienziato",
        "Archeologo", "Psicologo", "Dentista", "Veterinario", "Farmacista",
        "Giornalista", "Fotografo", "Regista", "Attore", "Cantante",
        "Ballerino", "Pittore", "Scultore", "Scrittore", "Poeta",
        "Contadino", "Pescatore", "Cacciatore", "Giardiniere", "Fiorista",
        "Parrucchiere", "Estetista", "Sarto", "Calzolaio", "Orologiaio",
        "Postino", "Corriere", "Tassista", "Autista", "Capitano",
        "Sommelier", "Pasticcere", "Panettiere", "Macellaio", "Pescivendolo",
        
        // Personaggi storici/famosi
        "Leonardo da Vinci", "Michelangelo", "Galileo Galilei", "Dante Alighieri",
        "Giuseppe Garibaldi", "Giulio Cesare", "Marco Polo", "Cristoforo Colombo",
        "Napoleone", "Cleopatra", "Einstein", "Mozart", "Beethoven",
        "Shakespeare", "Van Gogh", "Picasso", "Frida Kahlo",
        
        // Personaggi di fantasia italiani
        "Pinocchio", "Geppetto", "La Fata Turchina", "Il Grillo Parlante",
        "Pulcinella", "Arlecchino", "Colombina", "Pantalone",
        "La Befana", "Babbo Natale",
        
        // Personaggi di fantasia internazionali
        "Superman", "Batman", "Spider-Man", "Wonder Woman", "Hulk",
        "Topolino", "Paperino", "Pippo", "Pluto", "Minnie",
        "Bugs Bunny", "Tom e Jerry", "Scooby-Doo", "I Puffi",
        "Harry Potter", "Gandalf", "Frodo", "Darth Vader", "Yoda",
        "Shrek", "Fiona", "Ciuchino", "Elsa", "Anna",
        
        // Animali comuni
        "Cane", "Gatto", "Cavallo", "Mucca", "Maiale", "Pecora", "Capra",
        "Gallina", "Gallo", "Anatra", "Oca", "Tacchino", "Coniglio",
        "Topo", "Ratto", "Criceto", "Porcellino d'India", "Furetto",
        
        // Animali selvatici
        "Leone", "Tigre", "Elefante", "Giraffa", "Zebra", "Ippopotamo",
        "Rinoceronte", "Coccodrillo", "Alligatore", "Serpente", "Lucertola",
        "Tartaruga", "Rana", "Rospo", "Salamandra", "Camaleonte",
        "Orso", "Lupo", "Volpe", "Cervo", "Cinghiale", "Lepre",
        "Scoiattolo", "Castoro", "Lontra", "Foca", "Delfino", "Balena",
        "Squalo", "Polpo", "Medusa", "Granchio", "Aragosta", "Gambero",
        
        // Uccelli
        "Aquila", "Falco", "Gufo", "Civetta", "Corvo", "Gazza",
        "Piccione", "Colomba", "Rondine", "Passero", "Pettirosso",
        "Pappagallo", "Tucano", "Fenicottero", "Cigno", "Pellicano",
        "Pinguino", "Struzzo", "Pavone", "Fagiano", "Quaglia",
        
        // Insetti
        "Farfalla", "Ape", "Vespa", "Formica", "Mosca", "Zanzara",
        "Ragno", "Scorpione", "Scarafaggio", "Coccinella", "Libellula",
        "Cavalletta", "Grillo", "Cicala", "Bruco", "Lombrico",
        
        // Luoghi italiani
        "Roma", "Milano", "Napoli", "Firenze", "Venezia", "Torino",
        "Bologna", "Genova", "Palermo", "Verona", "Pisa", "Siena",
        "Colosseo", "Torre di Pisa", "Duomo di Milano", "Ponte Vecchio",
        "Fontana di Trevi", "Piazza San Marco", "Vaticano", "Pompei",
        "Costiera Amalfitana", "Cinque Terre", "Lago di Como", "Dolomiti",
        
        // Luoghi del mondo
        "Parigi", "Londra", "New York", "Tokyo", "Pechino", "Sydney",
        "Rio de Janeiro", "Dubai", "Las Vegas", "Los Angeles",
        "Torre Eiffel", "Big Ben", "Statua della Libert√†", "Grande Muraglia",
        "Piramidi", "Machu Picchu", "Taj Mahal", "Cristo Redentore",
        
        // Ambienti
        "Spiaggia", "Montagna", "Foresta", "Deserto", "Giungla",
        "Isola", "Vulcano", "Cascata", "Fiume", "Lago", "Mare", "Oceano",
        "Grotta", "Canyon", "Ghiacciaio", "Oasi", "Palude", "Savana"
    ],
    
    // ========================================
    // üì¶ OBJECTS (O) - Oggetti inanimati
    // ========================================
    objects: [
        // Oggetti domestici
        "Televisione", "Telecomando", "Computer", "Telefono", "Tablet",
        "Frigorifero", "Forno", "Microonde", "Lavastoviglie", "Lavatrice",
        "Asciugatrice", "Aspirapolvere", "Ferro da stiro", "Ventilatore",
        "Condizionatore", "Termosifone", "Stufa", "Camino",
        "Divano", "Poltrona", "Sedia", "Tavolo", "Scrivania", "Letto",
        "Armadio", "Cassettiera", "Libreria", "Specchio", "Lampada",
        "Tende", "Tappeto", "Cuscino", "Coperta", "Materasso",
        
        // Utensili da cucina
        "Pentola", "Padella", "Casseruola", "Teglia", "Pirofila",
        "Coltello", "Forchetta", "Cucchiaio", "Mestolo", "Spatola",
        "Frusta", "Mattarello", "Tagliere", "Grattugia", "Spremiagrumi",
        "Cavatappi", "Apriscatole", "Scolapasta", "Colino", "Imbuto",
        "Piatto", "Tazza", "Bicchiere", "Brocca", "Bottiglia",
        
        // Abbigliamento
        "Camicia", "Maglietta", "Maglione", "Felpa", "Giacca", "Cappotto",
        "Pantaloni", "Jeans", "Gonna", "Vestito", "Abito", "Smoking",
        "Pigiama", "Accappatoio", "Costume da bagno", "Bikini",
        "Calzini", "Scarpe", "Stivali", "Sandali", "Ciabatte", "Tacchi",
        "Cappello", "Berretto", "Sciarpa", "Guanti", "Cintura", "Cravatta",
        "Occhiali", "Occhiali da sole", "Orologio", "Anello", "Collana",
        "Orecchini", "Braccialetto", "Borsa", "Zaino", "Valigia",
        
        // Strumenti musicali
        "Pianoforte", "Chitarra", "Violino", "Violoncello", "Contrabbasso",
        "Flauto", "Clarinetto", "Sassofono", "Tromba", "Trombone",
        "Batteria", "Tamburo", "Xilofono", "Arpa", "Fisarmonica",
        "Armonica", "Ukulele", "Banjo", "Mandolino", "Organo",
        
        // Mezzi di trasporto
        "Automobile", "Moto", "Bicicletta", "Monopattino", "Skateboard",
        "Autobus", "Tram", "Metropolitana", "Treno", "Alta velocit√†",
        "Aereo", "Elicottero", "Mongolfiera", "Dirigibile", "Razzo",
        "Nave", "Barca", "Canoa", "Kayak", "Yacht", "Sottomarino",
        "Ambulanza", "Camion dei pompieri", "Volante della polizia",
        "Taxi", "Camion", "Furgone", "Camper", "Roulotte",
        
        // Attrezzi e utensili
        "Martello", "Cacciavite", "Pinza", "Chiave inglese", "Sega",
        "Trapano", "Scala", "Secchio", "Scopa", "Paletta", "Rastrello",
        "Vanga", "Zappa", "Forcone", "Carriola", "Innaffiatoio",
        
        // Oggetti scolastici/ufficio
        "Libro", "Quaderno", "Penna", "Matita", "Gomma", "Temperino",
        "Righello", "Compasso", "Calcolatrice", "Dizionario", "Atlante",
        "Globo", "Lavagna", "Gesso", "Pennarello", "Evidenziatore",
        "Graffetta", "Spillatrice", "Forbici", "Colla", "Scotch",
        
        // Cibo e bevande
        "Pizza", "Pasta", "Spaghetti", "Lasagna", "Risotto", "Gnocchi",
        "Pane", "Focaccia", "Grissini", "Brioche", "Croissant",
        "Torta", "Biscotti", "Cioccolato", "Gelato", "Tiramis√π",
        "Mela", "Pera", "Banana", "Arancia", "Limone", "Fragola",
        "Anguria", "Melone", "Uva", "Pesca", "Albicocca", "Ciliegia",
        "Pomodoro", "Patata", "Carota", "Cipolla", "Aglio", "Peperone",
        "Melanzana", "Zucchina", "Broccoli", "Cavolfiore", "Insalata",
        "Formaggio", "Mozzarella", "Parmigiano", "Prosciutto", "Salame",
        "Uovo", "Latte", "Burro", "Yogurt", "Caff√®", "T√®",
        "Vino", "Birra", "Acqua", "Succo", "Coca-Cola",
        
        // Oggetti vari
        "Ombrello", "Portafoglio", "Chiavi", "Accendino", "Sigaretta",
        "Candela", "Fiammifero", "Torcia", "Bussola", "Mappa",
        "Binocolo", "Telescopio", "Microscopio", "Lente d'ingrandimento",
        "Fotocamera", "Videocamera", "Drone", "Stampante", "Scanner",
        "Cuffie", "Altoparlante", "Microfono", "Proiettore", "Schermo",
        
        // Giocattoli
        "Bambola", "Peluche", "Pallone", "Bicicletta", "Triciclo",
        "Monopattino", "Pattini", "Aquilone", "Frisbee", "Hula hoop",
        "Puzzle", "Lego", "Cubo di Rubik", "Yo-yo", "Trottola",
        "Carte da gioco", "Dadi", "Scacchi", "Dama", "Monopoly"
    ],
    
    // ========================================
    // ü§™ BONUS - Temi divertenti/assurdi
    // ========================================
    funny: [
        // Situazioni assurde
        "Nonno che fa parkour", "Gatto con il monocolo", "Pizza che fa yoga",
        "Dinosauro in smart working", "Nonna rapper", "Cane che guida una Ferrari",
        "Pinguino in discoteca", "Broccolo bodybuilder", "Unicorno depresso",
        "Banana ninja", "Paperella gigante che attacca Tokyo", "Ges√π che fa surf",
        
        // Situazioni imbarazzanti
        "Collega che ruba il pranzo dal frigo", "Riunione Zoom in mutande",
        "Caff√® che non funziona il luned√¨", "Excel che crasha prima di salvare",
        "Stampante posseduta dal demonio", "Mail mandata al capo per sbaglio",
        "Scorreggia silenziosa in ascensore", "Russare durante una call",
        
        // Creature impossibili
        "Drago che ha paura del fuoco", "Squalo vegano", "Zombie influencer",
        "Fantasma con gli occhiali", "Sirena con le gambe", "Centauro in monopattino",
        "Fenicottero punk", "Bradipo su Red Bull", "Polpo massaggiatore",
        
        // Personaggi famosi in situazioni strane
        "Batman al supermercato", "Shrek al primo appuntamento", "Thanos che fa giardinaggio",
        "Mario Bros in palestra", "Pikachu arrabbiato col capo", "Yoda che balla reggaeton",
        "Gollum che vince alla lotteria", "Darth Vader in vacanza",
        
        // Cibo animato
        "Hamburger in terapia", "Sushi che fa karate", "Donut alla guida",
        "Pasta che corre la maratona", "Gelato al sole in panico", "Caff√® che medita",
        "Pollo arrosto che scappa", "Uovo che si allena per Pasqua",
        
        // Vita da ufficio assurda
        "Meeting che poteva essere una mail", "Stapler posseduto",
        "Collega che scalda il pesce in microonde", "Capo trasformato in rospo",
        "Deadline che insegue", "Ferie cancellate personificate",
        "Bonus di fine anno (molto piccolo)", "Luned√¨ mattina come mostro",
        
        // Scene epiche
        "Mondiale di nascondino", "Gara di rutti spaziale", "Olimpiadi del divano",
        "Apocalisse dei post-it", "Invasione di piccioni giganti",
        "T-Rex che fa il DJ", "Vulcano di nutella", "Tornado di coriandoli",
        
        // Paure moderne
        "Notifica di lavoro alle 23", "Batteria al 1%", "WiFi che non va",
        "Aggiornamento Windows forzato", "Messaggio vocale di 5 minuti",
        "Suocera a sorpresa", "Dentista sadico", "Sveglia del luned√¨",
        
        // Combo impossibili
        "Papa Francesco che skatea", "Regina Elisabetta al rave",
        "Einstein che fa TikTok", "Leonardo da Vinci su OnlyFans",
        "Napoleone che ordina da Glovo", "Cleopatra al centro commerciale",
        
        // Animali in situazioni umane
        "Gatto che paga le tasse", "Cane commercialista", "Piccione avvocato",
        "Mucca in palestra", "Gallina in smart working", "Pesce che guida Uber",
        "Ape influencer", "Lumaca corriere espresso", "Ragno architetto",
        
        // Assurdit√† varie
        "Capelli ribelli che prendono vita", "Calzino che scappa dalla lavatrice",
        "Frigorifero che giudica le tue scelte", "Sveglia sadica",
        "Ascensore claustrofobico", "Porta girevole infinita",
        "Coda alle poste eterna", "Parcheggio introvabile",
        "Telefonata con il call center", "IKEA senza uscita"
    ]
};
// ========================================
// FUNZIONE PER OTTENERE TEMA + CATEGORIA
// ========================================

function getRandomTheme() {
    // Ottieni tutte le categorie
    const categories = Object.keys(THEMES_DATABASE);
    
    // Scegli categoria casuale
    const category = categories[Math.floor(Math.random() * categories.length)];
    
    // Scegli parola casuale dalla categoria
    const words = THEMES_DATABASE[category];
    const word = words[Math.floor(Math.random() * words.length)];
    
    return {
        word: word,
        category: category
    };
}

// ‚úÖ Array THEMES per compatibilit√† (flatten di tutto)
const THEMES = Object.values(THEMES_DATABASE).flat();

console.log(`üìö Caricati ${THEMES.length} temi in ${Object.keys(THEMES_DATABASE).length} categorie!`);
const COLORS = [
    '#000000', '#ffffff', '#808080', '#c0c0c0',
    '#ff0000', '#ff6b6b', '#ffa500', '#ffff00', 
    '#90ee90', '#00ff00', '#008000', '#00ffff',
    '#0000ff', '#4169e1', '#800080', '#ff00ff',
    '#ffc0cb', '#a52a2a', '#8b4513', '#f5deb3'
];

const LOGICAL_SIZE = 500;
const MIN_DIST = 4;

// ========================================
// STATO GLOBALE
// ========================================
let state = {
    roomId: null,
    playerName: null,
    isHost: false,
    roomData: null,
    myVotes: {},
    myCurrentTheme: null,
    receivedDrawing: null,
    isDrawing: false,
    myChainId: null,
    isAdvancing: false  // ‚úÖ Flag per evitare chiamate multiple
};

let canvas, ctx;
let isDrawing = false;
let currentTool = 'pen';
let currentColor = '#000000';
let currentSize = 8;
let history = [];
let timer = 60;
let timerInterval;
let unsubscribeRoom = null;

// ========================================
// UTILITY
// ========================================
function showScreen(id) {
    document.querySelectorAll('.overlay, .app-container').forEach(el => el.classList.add('hidden'));
    const target = document.getElementById(id);
    if (target) target.classList.remove('hidden');
}

function showBanner(options) {
    removeBanner();
    const banner = document.createElement('div');
    banner.id = 'game-banner';
    banner.className = 'game-banner';
    banner.style.background = `linear-gradient(135deg, ${options.color} 0%, ${adjustColor(options.color, -30)} 100%)`;
    
    let buttonsHtml = (options.buttons || []).map(btn => 
        `<button class="btn ${btn.class || 'btn-secondary'}" onclick="${btn.onclick}" 
                 style="padding: 10px 20px;">${btn.text}</button>`
    ).join('');
    
    let spinnerHtml = options.spinner ? '<div class="spinner"></div>' : '';
    let timerHtml = options.timer ? `<div class="banner-timer" id="banner-timer">${options.timer}s</div>` : '';
    
    banner.innerHTML = `
        <div class="banner-left">
            <span class="banner-icon">${options.icon}</span>
            <div>
                <div class="banner-title">${options.title}</div>
                <div class="banner-subtitle">${options.subtitle}</div>
            </div>
        </div>
        <div class="banner-right">${timerHtml}${buttonsHtml}${spinnerHtml}</div>
    `;
    
    document.body.appendChild(banner);
}

function removeBanner() {
    document.getElementById('game-banner')?.remove();
}
function updateBannerText(title, subtitle) {
    const bannerTitle = document.querySelector('#game-banner .banner-title');
    const bannerSubtitle = document.querySelector('#game-banner .banner-subtitle');
    
    if (bannerTitle) bannerTitle.textContent = title;
    if (bannerSubtitle) bannerSubtitle.textContent = subtitle;
}
function adjustColor(hex, amount) {
    if (!hex || hex === 'transparent') return '#000000';
    
    let c = hex.replace('#', '');
    if (c.length === 3) c = c[0]+c[0]+c[1]+c[1]+c[2]+c[2];
    
    const num = parseInt(c, 16);
    if (isNaN(num)) return hex; // ‚úÖ Protezione
    
    let r = Math.min(255, Math.max(0, (num >> 16) + amount));
    let g = Math.min(255, Math.max(0, ((num >> 8) & 0xFF) + amount));
    let b = Math.min(255, Math.max(0, (num & 0xFF) + amount));
    
    return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
}

function cyrb128(str) {
    let h = 1779033703;
    for (let i = 0; i < str.length; i++) h = Math.imul(h ^ str.charCodeAt(i), 597399067);
    return h >>> 0;
}

function sfc32(a) {
    return function() {
        a |= 0; a = a + 0x6D2B79F5 | 0;
        let t = Math.imul(a ^ a >>> 15, 1 | a);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}

function shuffleArray(arr, rng) {
    const copy = [...arr];
    for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy;
}

function fireConfetti() {
    const colors = ['#ff0000', '#ffff00', '#00ff00', '#00ffff', '#ff00ff', '#ffd700'];
    for (let i = 0; i < 100; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDuration = (2 + Math.random() * 2) + 's';
        confetti.style.animationDelay = Math.random() * 0.5 + 's';
        if (Math.random() > 0.5) confetti.style.borderRadius = '50%';
        document.body.appendChild(confetti);
        setTimeout(() => confetti.remove(), 5000);
    }
}

// ========================================
// LOBBY
// ========================================
function enterLobby() {
    removeBanner();
    showScreen('lobby-screen');
    showHomeButton();
    
    if (unsubscribeRoom) unsubscribeRoom();
    unsubscribeRoom = db.collection("pictionary_rooms").doc(state.roomId).onSnapshot(handleRoomUpdate);
}

function handleRoomUpdate(doc) {
    if (!doc.exists) {
        if (unsubscribeRoom) {
            unsubscribeRoom();
            unsubscribeRoom = null;
        }
        window.location.href = 'index.html';
        return;
    }
    
    const data = doc.data();
    const prevStato = state.roomData?.stato;
    
    state.roomData = data;
    state.isHost = data.host === state.playerName;
    
    // ‚úÖ GUESS IT: Gestito internamente da handleGuessItPhase
    if (data.stato === 'guessit') {
        handleGuessItPhase(data);
        return; // ‚Üê Non eseguire altro
    }
    
    // ‚úÖ Ignora se sto disegnando (modalit√† classica)
    if (state.isDrawing) {
        console.log("üìù Sto disegnando, ignoro update");
        return;
    }
    
    console.log(`üîÑ Update: stato=${data.stato}, prev=${prevStato}`);
    
    switch(data.stato) {
        case 'lobby': 
            renderLobby(data); 
            break;
        case 'drawing': 
            handleDrawingPhase(data); 
            break;
        case 'voting': 
            handleVotingPhase(data); 
            break;
        case 'results': 
            handleResultsPhase(data); 
            break;
        default:
            console.error('Stato non riconosciuto:', data.stato);
    }
}

function renderLobby(data) {
    showScreen('lobby-screen');
    showHomeButton();
    
    // ‚úÖ Aggiorna display giocatori
    const playersDisplay = document.getElementById('lobby-players-display');
    if (playersDisplay) {
        playersDisplay.innerHTML = data.players.map(p => `
            <div style="
                background: ${data.ready.includes(p) ? 'var(--success)' : 'var(--accent)'};
                color: white;
                padding: 10px 20px;
                border-radius: 25px;
                font-weight: bold;
                display: flex;
                align-items: center;
                gap: 8px;
            ">
                ${p === data.host ? 'üëë' : ''}
                ${p}
                ${data.ready.includes(p) ? '‚úÖ' : '‚è≥'}
            </div>
        `).join('');
    }
    
    // ‚úÖ Aggiorna rounds display
    const autoRoundsDisplay = document.getElementById('auto-rounds-display');
    if (autoRoundsDisplay) {
        autoRoundsDisplay.textContent = data.players.length;
    }
    
    // ‚úÖ Costruisci bottoni per il banner
    const buttons = [];
    
    if (data.ready.includes(state.playerName)) {
        buttons.push({
            text: '‚è∏Ô∏è ANNULLA',
            onclick: 'toggleReady()',
            class: 'btn-secondary'
        });
    } else {
        buttons.push({
            text: 'üöÄ SONO PRONTO!',
            onclick: 'toggleReady()',
            class: 'btn-primary'
        });
    }
    
    // ‚úÖ Selettore tempo (solo host)
    let timeSelector = '';
    if (state.isHost && !data.sfidaDiretta) {
        const currentTime = data.settings?.timePerRound || 60;
        timeSelector = `
            <select onchange="updateSettings()" id="banner-time-select" style="
                padding: 8px 12px;
                border-radius: 8px;
                border: none;
                font-weight: bold;
                cursor: pointer;
            ">
                <option value="30" ${currentTime == 30 ? 'selected' : ''}>30s</option>
                <option value="45" ${currentTime == 45 ? 'selected' : ''}>45s</option>
                <option value="60" ${currentTime == 60 ? 'selected' : ''}>60s</option>
                <option value="90" ${currentTime == 90 ? 'selected' : ''}>90s</option>
                <option value="120" ${currentTime == 120 ? 'selected' : ''}>120s</option>
            </select>
        `;
    }
    
    buttons.push({
        text: 'üö™ ESCI',
        onclick: 'leaveRoom()',
        class: 'btn-danger'
    });
    
    // ‚úÖ Banner stile Ruzzle
    removeBanner();
    const banner = document.createElement('div');
    banner.id = 'game-banner';
    banner.className = 'game-banner';
    banner.style.background = 'linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%)';
    
    banner.innerHTML = `
        <div class="banner-left">
            <span class="banner-icon">üé®</span>
            <div>
                <div class="banner-title">PICTIONARY - LOBBY</div>
                <div class="banner-subtitle">${data.ready.length}/${data.players.length} pronti ‚Ä¢ ${data.players.length} round</div>
            </div>
        </div>
        <div class="banner-right">
            ${timeSelector}
            ${buttons.map(btn => `
                <button class="btn ${btn.class}" onclick="${btn.onclick}" style="padding: 10px 20px;">
                    ${btn.text}
                </button>
            `).join('')}
        </div>
    `;
    
    document.body.appendChild(banner);
    
    // ‚úÖ Avvio automatico quando tutti pronti
    if (data.ready.length >= data.players.length && data.players.length >= 2 && state.isHost) {
        startGame();
    }
}

async function updateSettings() {
    const timeSelect = document.getElementById('banner-time-select') || document.getElementById('lobby-time-select');
    if (timeSelect) {
        await db.collection("pictionary_rooms").doc(state.roomId).update({
            'settings.timePerRound': parseInt(timeSelect.value)
        });
    }
}

async function toggleReady() {
const data = state.roomData;
    const isCurrentlyReady = data.ready.includes(state.playerName);
    
    const field = isCurrentlyReady ? 
        firebase.firestore.FieldValue.arrayRemove(state.playerName) :
        firebase.firestore.FieldValue.arrayUnion(state.playerName);
    
    await db.collection("pictionary_rooms").doc(state.roomId).update({ ready: field });
}

async function leaveRoom() {
    if (!confirm("Sicuro di voler uscire?")) return;
    
    if (state.isHost) {
        await db.collection("pictionary_rooms").doc(state.roomId).delete();
    } else {
        await db.collection("pictionary_rooms").doc(state.roomId).update({
            players: firebase.firestore.FieldValue.arrayRemove(state.playerName),
            ready: firebase.firestore.FieldValue.arrayRemove(state.playerName)
        });
    }
    
    location.reload();
}

// ========================================
// AVVIO GIOCO
// ========================================
async function startGame() {
    if (!state.isHost) return;
    
    const data = state.roomData;
    const players = data.players;
    const numPlayers = players.length;
    const gameMode = data.settings?.mode || 'classic';
    
if (gameMode === 'guessit') {
    const firstDrawer = players[Math.floor(Math.random() * players.length)];
    const theme = getRandomTheme(); // ‚úÖ Usa la nuova funzione
    
    const initialScores = {};
    players.forEach(p => initialScores[p] = 0);
    
    await db.collection("pictionary_rooms").doc(state.roomId).update({
        stato: 'guessit',
        guessIt: {
            round: 0,
            totalRounds: players.length * 2,
            currentDrawer: firstDrawer,
            currentWord: theme.word,       // ‚úÖ Parola
            currentCategory: theme.category, // ‚úÖ Categoria
            canvasData: null,
            guesses: {},
            scores: initialScores,
            roundWinner: null,
            timePerRound: data.settings?.timePerRound || 60
        }
    });
    return;
}
    
    // ‚úÖ MODALIT√Ä CLASSICA (codice esistente)
    const totalRounds = numPlayers;
    
    const seed = cyrb128(state.roomId + Date.now());
    const rng = sfc32(seed);
// Genera temi con categoria
const themesWithCategory = [];
for (let i = 0; i < numPlayers; i++) {
    themesWithCategory.push(getRandomTheme());
}

const chains = {};
for (let i = 0; i < numPlayers; i++) {
    chains[i] = {
        themeIndex: i,
        originalTheme: themesWithCategory[i].word,
        originalCategory: themesWithCategory[i].category, // ‚úÖ Aggiungi categoria
        steps: [],
        drawnBy: []
    };
}
    const scores = {};
    players.forEach(p => scores[p] = 0);
    
    await db.collection("pictionary_rooms").doc(state.roomId).update({
        stato: 'drawing',
        currentRound: 0,
        totalRounds: totalRounds,
        chains: chains,
        scores: scores,
        votes: {},
        completedRound: {},
        playerOrder: players // Ordine fisso per la rotazione
    });
}

// ========================================
// ‚úÖ FASE DISEGNO - CORRETTA
// ========================================
function handleDrawingPhase(data) {
    const currentRound = data.currentRound;
    const completed = data.completedRound?.[currentRound] || [];
    
    console.log(`üìù handleDrawingPhase: round=${currentRound}, completed=${completed.join(',')}`);
    
    // ‚úÖ Se ho gi√† completato questo round, mostra waiting
    if (completed.includes(state.playerName)) {
        showWaitingScreen(data);
        return;
    }
    
    // ‚úÖ CALCOLA QUALE TEMA DEVO DISEGNARE
    const players = data.playerOrder || data.players;
    const numPlayers = players.length;
    const myIdx = players.indexOf(state.playerName);
    
    // Round k ‚Üí Giocatore i disegna tema (i + k) % N
    const myChainId = (myIdx + currentRound) % numPlayers;
    const chain = data.chains[myChainId];
    
    let myTheme, referenceDrawing = null;
    
    if (currentRound === 0) {
        // ‚úÖ Round 0: Disegno il tema originale
        myTheme = chain.originalTheme;
    } else {
        // ‚úÖ Round 1+: Ridisegno guardando l'ultimo disegno della catena
        myTheme = "RIDISEGNALO!";
        const lastStep = chain.steps[chain.steps.length - 1];
        if (lastStep && lastStep.drawing) {
            referenceDrawing = lastStep.drawing;
        }
    }
    
    state.myCurrentTheme = currentRound === 0 ? chain.originalTheme : myTheme;
    state.originalTheme = chain.originalTheme; // Salva per riferimento
    state.receivedDrawing = referenceDrawing;
    state.myChainId = myChainId;
    
    console.log(`üéØ Round ${currentRound}: Disegno chain ${myChainId} ("${chain.originalTheme}"), hasRef=${!!referenceDrawing}`);
    
    launchCanvas(data);
}

function launchCanvas(data) {
    state.isDrawing = true;
    showScreen('game-ui');
    showHomeButton();
    
    canvas = document.getElementById('mainCanvas');
    ctx = canvas.getContext('2d', { willReadFrequently: true });
    setupCanvas(canvas);
    
    // Render quick colors
    renderQuickColors();
    
    // Reset tools
    currentColor = '#000000';
    currentSize = 8;
    currentTool = 'pen';
    
    setTool('pen');
    setColorFromPicker('#000000');
    setSize(8);
    
    // ‚úÖ Mostra miniatura se presente riferimento
    const refThumbnail = document.getElementById('reference-thumbnail');
    const themeBadge = document.getElementById('canvas-theme-badge');
    
    if (state.receivedDrawing) {
        if (refThumbnail) {
            refThumbnail.style.display = 'block';
            
            const miniCanvas = document.getElementById('reference-mini-canvas');
            miniCanvas.width = LOGICAL_SIZE;
            miniCanvas.height = LOGICAL_SIZE;
            const miniCtx = miniCanvas.getContext('2d');
            miniCtx.fillStyle = '#ffffff';
            miniCtx.fillRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
            
            const actions = decompressDrawing(state.receivedDrawing);
            actions.forEach(act => applyAction(act, miniCtx));
        }
        
        if (themeBadge) {
            themeBadge.textContent = "üé® COPIA QUESTO!";
            themeBadge.style.background = 'linear-gradient(135deg, #4ecdc4 0%, #26d0ce 100%)';
        }
    } else {
        if (refThumbnail) refThumbnail.style.display = 'none';
if (themeBadge) {
    const category = state.roomData?.chains?.[state.myChainId]?.originalCategory || 'üé® Tema';
    themeBadge.innerHTML = `
        <div style="font-size: 0.65rem; opacity: 0.8; margin-bottom: 2px;">
            ${category}
        </div>
        <div>
            ${state.myCurrentTheme}
        </div>
    `;
    }
    
    document.getElementById('ui-round-info').textContent = 
        `ROUND ${data.currentRound + 1}/${data.totalRounds}`;
    document.getElementById('ui-player').textContent = state.playerName;
    
    timer = data.settings?.timePerRound || 60;
    document.getElementById('timer').textContent = timer;
    document.getElementById('timer').classList.remove('warning');
    
    // Attach listeners
    attachCanvasListeners();
    
    // Start timer
    startTimerWithBanner();
}

function startTimerWithBanner() {
    clearInterval(timerInterval);
    removeBanner();
    
    const timerEl = document.getElementById('timer');
    
    timerInterval = setInterval(() => {
        timer--;
        
        if (timerEl) {
            timerEl.textContent = timer;
            if (timer <= 10) timerEl.classList.add('warning');
        }
        
        if (timer <= 0) {
            clearInterval(timerInterval);
            finishCurrentPhase();
        }
    }, 1000);
}

// ‚úÖ FINISH PHASE - CORRETTO
async function finishCurrentPhase() {
    if (state.isAdvancing) return;
    
    clearInterval(timerInterval);
    removeBanner();
    state.isDrawing = false;
    
    const data = state.roomData;
    const currentRound = data.currentRound;
    const myChainId = state.myChainId;
    
    console.log(`‚úÖ finishCurrentPhase: round=${currentRound}, chain=${myChainId}`);
    
    const drawingData = compressDrawing(history);
    
    const step = {
        player: state.playerName,
        round: currentRound,
        drawing: drawingData
    };
    
    const chainPath = `chains.${myChainId}.steps`;
    const drawnByPath = `chains.${myChainId}.drawnBy`;
    const completedPath = `completedRound.${currentRound}`;
    
    await db.collection("pictionary_rooms").doc(state.roomId).update({
        [chainPath]: firebase.firestore.FieldValue.arrayUnion(step),
        [drawnByPath]: firebase.firestore.FieldValue.arrayUnion(state.playerName),
        [completedPath]: firebase.firestore.FieldValue.arrayUnion(state.playerName)
    });
    
    state.receivedDrawing = null;
    
    // Leggi dati freschi
    const freshDoc = await db.collection("pictionary_rooms").doc(state.roomId).get();
    const freshData = freshDoc.data();
    state.roomData = freshData;
    
    const completed = freshData.completedRound?.[currentRound] || [];
    const total = freshData.players.length;
    
    console.log(`üìä Completati: ${completed.length}/${total}, isHost=${state.isHost}`);
    
    if (completed.length >= total && state.isHost) {
        await advanceToNextRound(freshData);
    } else {
        showWaitingScreen(freshData);
    }
}

// ‚úÖ AVANZAMENTO FASE - CORRETTO
async function advanceToNextRound(data) {
    if (state.isAdvancing) {
        console.log("‚ö†Ô∏è Gi√† in avanzamento, skip");
        return;
    }
    
    state.isAdvancing = true;
    
    const currentRound = data.currentRound;
    const totalRounds = data.totalRounds;
    const nextRound = currentRound + 1;
    
    console.log(`üöÄ advanceToNextRound: ${currentRound} ‚Üí ${nextRound} (totale: ${totalRounds})`);
    
    try {
        if (nextRound >= totalRounds) {
            // ‚úÖ Tutti i round completati ‚Üí Votazione
            console.log("üó≥Ô∏è Passaggio a VOTAZIONE");
            await db.collection("pictionary_rooms").doc(state.roomId).update({
                stato: 'voting'
            });
        } else {
            // ‚úÖ Prossimo round
            console.log(`‚û°Ô∏è Passaggio a round ${nextRound}`);
            await db.collection("pictionary_rooms").doc(state.roomId).update({
                currentRound: nextRound,
                stato: 'drawing'
            });
        }
    } catch (e) {
        console.error("‚ùå Errore avanzamento round:", e);
    } finally {
        setTimeout(() => { state.isAdvancing = false; }, 2000);
    }
}

// ========================================
// ‚úÖ WAITING SCREEN - CORRETTO
// ========================================
function showWaitingScreen(data) {
    clearInterval(timerInterval);
    showScreen('waiting-screen');
    showHomeButton();
    
    const currentRound = data.currentRound;
    const completed = data.completedRound?.[currentRound] || [];
    const total = data.players.length;
    
    const remaining = data.players.filter(p => !completed.includes(p));
    
    document.getElementById('waiting-title').textContent = `‚úèÔ∏è ROUND ${currentRound + 1}/${data.totalRounds} COMPLETATO!`;
    document.getElementById('waiting-message').textContent = 
        remaining.length > 0 
            ? `In attesa di: ${remaining.join(', ')}`
            : 'Tutti hanno finito! Passaggio...';
    document.getElementById('done-count').textContent = completed.length;
    document.getElementById('total-players').textContent = total;
    
    showBanner({
        icon: '‚è≥',
        title: `ATTESA (${completed.length}/${total})`,
        subtitle: remaining.length > 0 ? `Manca: ${remaining.join(', ')}` : 'Passaggio in corso...',
        color: '#9b59b6',
        spinner: true
    });
    
    // ‚úÖ SE TUTTI HANNO FINITO E SONO HOST, AVANZA
    if (completed.length >= total && state.isHost && !state.isAdvancing) {
        console.log("‚úÖ Tutti finito in waiting, host avanza");
        advanceToNextRound(data);
    }
}

// ========================================
// VOTAZIONE
// ========================================
function handleVotingPhase(data) {
    removeBanner();
    showScreen('gallery-screen');
    showHomeButton();
    renderGallery(data);
    
    const votedCount = Object.keys(state.myVotes).length;
    const totalChains = Object.keys(data.chains).length;
    
    // ‚úÖ Controlla se ho gi√† votato (i miei voti sono su Firebase)
    const myVotesOnFirebase = data.votes?.[state.playerName];
    const confirmBtn = document.getElementById('confirm-votes-btn');
    
    if (myVotesOnFirebase && Object.keys(myVotesOnFirebase).length > 0) {
        // ‚úÖ Ho gi√† confermato i voti
        if (confirmBtn) {
            confirmBtn.disabled = true;
            confirmBtn.innerHTML = '‚úÖ VOTI INVIATI';
            confirmBtn.style.opacity = '0.6';
            confirmBtn.style.cursor = 'not-allowed';
            confirmBtn.style.background = 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)';
        }
        
        const votedPlayers = Object.keys(data.votes).length;
        const totalPlayers = data.players.length;
        
        showBanner({
            icon: '‚è≥',
            title: `ATTESA VOTI (${votedPlayers}/${totalPlayers})`,
            subtitle: 'Hai gi√† votato. Attendi gli altri...',
            color: '#27ae60',
            spinner: true
        });
        
        // ‚úÖ Host controlla se tutti hanno votato
        if (state.isHost && votedPlayers >= totalPlayers) {
            checkAndCalculateResults();
        }
    } else {
        // ‚úÖ Non ho ancora votato
        if (confirmBtn) {
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = '‚úÖ CONFERMA VOTI';
            confirmBtn.style.opacity = '1';
            confirmBtn.style.cursor = 'pointer';
            confirmBtn.style.background = 'linear-gradient(135deg, #ffd700 0%, #ffaa00 100%)';
        }
        
        showBanner({
            icon: 'üó≥Ô∏è',
            title: 'VOTAZIONE IN CORSO',
            subtitle: `Vota il disegno pi√π bello di ogni catena (${votedCount}/${totalChains})`,
            color: '#f39c12'
        });
    }
}

function renderGallery(data) {
    const container = document.getElementById('gallery-container');
    container.innerHTML = '';
    
    const myVotes = state.myVotes;
    const isVotingPhase = data.stato === 'voting';
    
    Object.entries(data.chains).forEach(([chainId, chain]) => {
        const card = document.createElement('div');
        card.className = 'chain-card';
        
        // ‚úÖ Durante la votazione NON mostrare chi ha creato il tema originale
        const headerInfo = isVotingPhase 
            ? `<div style="font-size: 0.8rem; opacity: 0.7;">üéØ Tema originale nascosto</div>`
            : `<div style="font-size: 0.8rem; opacity: 0.7;">di ${chain.steps[0]?.player || '?'}</div>`;
        
// ‚úÖ Tema sempre visibile
const themeDisplay = `<span>Tema: "${chain.originalTheme}"</span>`;
        
        card.innerHTML = `
            <div class="chain-header">
                <div class="chain-title">
                    <span>üé®</span>
                    ${themeDisplay}
                </div>
                ${headerInfo}
            </div>
            <div class="chain-flow" id="chain-flow-${chainId}"></div>
        `;
        
        const flowContainer = card.querySelector(`#chain-flow-${chainId}`);
        
        chain.steps.forEach((step, stepIdx) => {
            if (stepIdx > 0) {
                const arrow = document.createElement('div');
                arrow.className = 'chain-arrow';
                arrow.innerHTML = '‚û°Ô∏è';
                flowContainer.appendChild(arrow);
            }
            
            // ‚úÖ Controlla se questo disegno √® mio (non posso votarmi)
            const isMyDrawing = step.player === state.playerName;
            const isVoted = myVotes[chainId] === `${chainId}-${stepIdx}`;
            
            const stepCard = document.createElement('div');
            stepCard.className = `chain-step ${isVoted ? 'voted' : ''} ${isMyDrawing && isVotingPhase ? 'my-drawing' : ''}`;
            
            // ‚úÖ Durante votazione: nascondo nome, durante risultati: mostro nome
            const playerDisplay = isVotingPhase 
                ? `<div class="step-player" style="color: #888;">Disegno #${stepIdx + 1}</div>`
                : `<div class="step-player">${step.player}</div>`;
            
            // ‚úÖ Pulsante voto: disabilitato se √® il mio disegno
            let voteButton = '';
            if (isVotingPhase) {
                if (isMyDrawing) {
                    voteButton = `
                        <button class="vote-btn" disabled 
                                style="opacity: 0.4; cursor: not-allowed; background: #444;">
                            üö´ Tuo disegno
                        </button>`;
                } else {
                    voteButton = `
                        <button class="vote-btn ${isVoted ? 'voted' : ''}" 
                                onclick="voteFor('${chainId}', '${chainId}-${stepIdx}')">
                            ${isVoted ? '‚≠ê VOTATO' : 'üëç VOTA'}
                        </button>`;
                }
            }
            
            stepCard.innerHTML = `
                <div class="step-canvas"><canvas id="step-canvas-${chainId}-${stepIdx}"></canvas></div>
                <div class="step-info">
                    ${playerDisplay}
                    <div class="step-type" style="font-size: 0.65rem; opacity: 0.6;">
                        ${stepIdx === 0 ? 'üéØ Primo disegno' : `üîÑ Copia #${stepIdx}`}
                    </div>
                </div>
                ${voteButton}
            `;
            
            flowContainer.appendChild(stepCard);
            
            setTimeout(() => {
                const cvs = document.getElementById(`step-canvas-${chainId}-${stepIdx}`);
                if (cvs && step.drawing) {
                    cvs.width = LOGICAL_SIZE;
                    cvs.height = LOGICAL_SIZE;
                    const ctxCanvas = cvs.getContext('2d');
                    ctxCanvas.fillStyle = '#ffffff';
                    ctxCanvas.fillRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
                    const actions = decompressDrawing(step.drawing);
                    actions.forEach(act => applyAction(act, ctxCanvas));
                }
            }, 50);
        });
        
        container.appendChild(card);
    });
    
    // ‚úÖ Conta solo i voti validi (non i propri disegni)
    const validVotesCount = Object.keys(myVotes).length;
    const totalChains = Object.keys(data.chains).length;
    document.getElementById('vote-status').textContent = 
        `Voti: ${validVotesCount}/${totalChains}`;
}

function voteFor(chainId, uniqueVoteId) {
    // ‚úÖ Estrai stepIdx dal uniqueVoteId
    const stepIdx = parseInt(uniqueVoteId.split('-')[1]);
    const chain = state.roomData.chains[chainId];
    const step = chain.steps[stepIdx];
    
    // ‚úÖ Doppio controllo: non posso votare me stesso
    if (step.player === state.playerName) {
        alert("Non puoi votare il tuo disegno!");
        return;
    }
    
    // ‚úÖ Toggle voto (clicca di nuovo per deselezionare)
    if (state.myVotes[chainId] === uniqueVoteId) {
        delete state.myVotes[chainId];
    } else {
        state.myVotes[chainId] = uniqueVoteId;
    }
    
    renderGallery(state.roomData);
    
    const votedCount = Object.keys(state.myVotes).length;
    const totalChains = Object.keys(state.roomData.chains).length;
    
    // ‚úÖ Solo aggiorna testo, non ricreare banner
    updateBannerText(
        'VOTAZIONE IN CORSO',
        `Vota il disegno pi√π bello di ogni catena (${votedCount}/${totalChains})`
    );
    
    document.getElementById('vote-status').textContent = `Voti: ${votedCount}/${totalChains}`;
}
async function confirmVotes() {
    const data = state.roomData;
    const totalChains = Object.keys(data.chains).length;
    
    if (Object.keys(state.myVotes).length < totalChains) {
        return alert(`Devi votare in tutte le ${totalChains} catene!`);
    }
    
    // ‚úÖ Disabilita subito il pulsante per evitare doppi click
    const confirmBtn = document.getElementById('confirm-votes-btn');
    if (confirmBtn) {
        confirmBtn.disabled = true;
        confirmBtn.innerHTML = '‚è≥ INVIO VOTI...';
        confirmBtn.style.opacity = '0.6';
        confirmBtn.style.cursor = 'not-allowed';
    }
    
    // ‚úÖ Converti voti in formato {chainId: playerName}
    const votesForFirebase = {};
    Object.entries(state.myVotes).forEach(([chainId, uniqueVoteId]) => {
        const stepIdx = parseInt(uniqueVoteId.split('-')[1]);
        const chain = data.chains[chainId];
        const votedPlayer = chain.steps[stepIdx].player;
        votesForFirebase[chainId] = votedPlayer;
    });
    
    try {
        await db.collection("pictionary_rooms").doc(state.roomId).update({
            [`votes.${state.playerName}`]: votesForFirebase
        });
        
        // ‚úÖ Aggiorna pulsante a stato "confermato"
        if (confirmBtn) {
            confirmBtn.innerHTML = '‚úÖ VOTI INVIATI';
            confirmBtn.style.background = 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)';
        }
        
        showBanner({
            icon: '‚è≥',
            title: 'VOTI CONFERMATI',
            subtitle: 'Attendi gli altri giocatori...',
            color: '#27ae60',
            spinner: true
        });
        
        // ‚úÖ Host controlla e calcola risultati
        if (state.isHost) {
            await checkAndCalculateResults();
        }
        
    } catch (e) {
        console.error("Errore invio voti:", e);
        // Riabilita in caso di errore
        if (confirmBtn) {
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = '‚úÖ CONFERMA VOTI';
            confirmBtn.style.opacity = '1';
            confirmBtn.style.cursor = 'pointer';
        }
        alert("Errore nell'invio dei voti. Riprova.");
    }
}
// Aggiungi questa variabile globale (vicino a state)
let isCalculatingResults = false;

// Modifica la funzione
async function checkAndCalculateResults() {
    // ‚úÖ Evita chiamate multiple
    if (isCalculatingResults) {
        console.log("‚ö†Ô∏è Calcolo gi√† in corso, skip");
        return;
    }
    isCalculatingResults = true;
    
    try {
        const doc = await db.collection("pictionary_rooms").doc(state.roomId).get();
        const newData = doc.data();
        
        // ‚úÖ Doppio controllo: non ricalcolare se gi√† in results
        if (newData.stato === 'results') {
            console.log("‚ö†Ô∏è Gi√† in results, skip");
            return;
        }
        
        if (Object.keys(newData.votes).length >= newData.players.length) {
            const scores = {};
            newData.players.forEach(p => scores[p] = 0);
            
            Object.values(newData.votes).forEach(playerVotes => {
                Object.values(playerVotes).forEach(votedPlayer => {
                    if (scores[votedPlayer] !== undefined) {
                        scores[votedPlayer]++;
                    }
                });
            });
            
            await db.collection("pictionary_rooms").doc(state.roomId).update({
                scores: scores,
                stato: 'results'
            });
        }
    } catch (e) {
        console.error("Errore calcolo risultati:", e);
    } finally {
        // ‚úÖ Reset dopo 3 secondi (sicurezza)
        setTimeout(() => {
            isCalculatingResults = false;
        }, 3000);
    }
}

// ========================================
// RISULTATI
// ========================================
function handleResultsPhase(data) {
    removeBanner();
    showScreen('results-screen');
    showHomeButton();
    fireConfetti();
    
    const sorted = Object.entries(data.scores).sort((a, b) => b[1] - a[1]);
    
    const podium = document.getElementById('podium');
    podium.innerHTML = '';
    
const podiumOrder = [1, 0, 2];
podiumOrder.forEach((idx) => {
    if (sorted[idx]) {
        const [player, score] = sorted[idx];
        const place = idx + 1;
        
        const div = document.createElement('div');
        div.className = `podium-place place-${place}`;
        div.style.animationDelay = `${idx * 0.2}s`;
        div.innerHTML = `
            <div class="podium-avatar">${place}¬∞</div>
            <div class="podium-bar">
                <div class="podium-score">${score}</div>
            </div>
            <div class="podium-name">${player}</div>
        `;
        podium.appendChild(div);
    }
});
    
    const ranking = document.getElementById('full-ranking');
    ranking.innerHTML = '<h3 style="margin-top: 0;">Classifica Completa</h3>';
    
    sorted.forEach(([player, score], idx) => {
        const row = document.createElement('div');
        row.className = `ranking-row ${player === state.playerName ? 'me' : ''}`;
        row.innerHTML = `
            <span class="ranking-position">${idx + 1}¬∞</span>
            <span class="ranking-name">${player}</span>
            <span class="ranking-score">${score} voti</span>
        `;
        ranking.appendChild(row);
    });
    // ‚úÖ Mostra tema originale di ogni catena nei risultati
    let chainsInfo = '';
    Object.entries(data.chains).forEach(([chainId, chain]) => {
        const firstPlayer = chain.steps[0]?.player || '?';
        chainsInfo += `\n‚Ä¢ "${chain.originalTheme}" (iniziato da ${firstPlayer})`;
    });    
    const isWinner = sorted[0]?.[0] === state.playerName;
    showBanner({
        icon: isWinner ? 'üëë' : 'üèÜ',
        title: isWinner ? 'HAI VINTO!' : 'PARTITA TERMINATA',
        subtitle: `Vincitore: ${sorted[0]?.[0] || '-'} con ${sorted[0]?.[1] || 0} voti`,
        color: isWinner ? '#ffd700' : '#27ae60'
    });
}

async function playAgain() {
    if (!state.isHost) {
        return alert("Solo l'host pu√≤ avviare una nuova partita!");
    }
    
    await db.collection("pictionary_rooms").doc(state.roomId).update({
        stato: 'lobby',
        currentRound: 0,
        totalRounds: 0,
        chains: {},
        votes: {},
        scores: {},
        completedRound: {},
        ready: [],
        playerOrder: []
    });
    
    state.myVotes = {};
    state.isAdvancing = false;
}

function goHome() {
    window.location.href = 'index.html';
}

// ========================================
// CANVAS SETUP E CONTROLLI
// ========================================

const QUICK_COLORS = [
    '#000000', '#ffffff', '#ff0000', '#ff6b6b', 
    '#ffa500', '#ffff00', '#00ff00', '#008000',
    '#00ffff', '#0000ff', '#800080', '#ff00ff',
    '#ffc0cb', '#a52a2a', '#808080', '#f5deb3'
];

function setupCanvas(c) {
    // ‚úÖ Canvas sempre 500x500 internamente (quadrato)
    c.width = LOGICAL_SIZE;
    c.height = LOGICAL_SIZE;
    
    const cx = c.getContext('2d');
    cx.lineCap = 'round';
    cx.lineJoin = 'round';
    cx.fillStyle = '#ffffff';
    cx.fillRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
    
    // Reset history
    history = [];
}

function getPos(e, c) {
    const rect = c.getBoundingClientRect();
    
    let clientX, clientY;
    if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else if (e.changedTouches && e.changedTouches.length > 0) {
        clientX = e.changedTouches[0].clientX;
        clientY = e.changedTouches[0].clientY;
    } else {
        clientX = e.clientX;
        clientY = e.clientY;
    }
    
    // ‚úÖ Calcolo preciso con scala
    const scaleX = c.width / rect.width;
    const scaleY = c.height / rect.height;
    
    let x = (clientX - rect.left) * scaleX;
    let y = (clientY - rect.top) * scaleY;
    
    // ‚úÖ Clamp ai bordi del canvas
    x = Math.max(0, Math.min(c.width, x));
    y = Math.max(0, Math.min(c.height, y));
    
    return { x: Math.round(x), y: Math.round(y) };
}

function attachCanvasListeners() {
    // Rimuovi listener precedenti
    canvas.onmousedown = null;
    canvas.onmousemove = null;
    canvas.ontouchstart = null;
    canvas.ontouchmove = null;
    window.onmouseup = null;
    window.ontouchend = null;
    
    const startDrawing = (e) => {
        e.preventDefault();
        const pos = getPos(e, canvas);
        
        if (currentTool === 'bucket') {
            const act = { type: 'fill', color: currentColor, x: pos.x, y: pos.y };
            history.push(act);
            floodFill(pos.x, pos.y, currentColor, ctx);
        } else {
            isDrawing = true;
            const color = currentTool === 'eraser' ? '#ffffff' : currentColor;
            const act = { type: 'stroke', color: color, size: currentSize, points: [pos] };
            history.push(act);
            
            // Disegna punto iniziale
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.arc(pos.x, pos.y, currentSize / 2, 0, Math.PI * 2);
            ctx.fill();
        }
    };
    
    const draw = (e) => {
        if (!isDrawing) return;
        e.preventDefault();
        
        const pos = getPos(e, canvas);
        const stroke = history[history.length - 1];
        
        if (!stroke || !stroke.points) return;
        
        const last = stroke.points[stroke.points.length - 1];
        const dist = Math.hypot(pos.x - last.x, pos.y - last.y);
        
        if (dist > MIN_DIST) {
            stroke.points.push(pos);
            
            ctx.beginPath();
            ctx.strokeStyle = stroke.color;
            ctx.lineWidth = stroke.size;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.moveTo(last.x, last.y);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        }
    };
    
    const stopDrawing = () => {
        isDrawing = false;
    };
    
    // Mouse events
    canvas.onmousedown = startDrawing;
    canvas.onmousemove = draw;
    window.onmouseup = stopDrawing;
    
    // Touch events
    canvas.ontouchstart = startDrawing;
    canvas.ontouchmove = draw;
    window.ontouchend = stopDrawing;
    canvas.ontouchcancel = stopDrawing;
}

function applyAction(act, cx) {
    if (act.type === 'stroke') {
        if (act.points.length === 1) {
            cx.beginPath();
            cx.fillStyle = act.color;
            cx.arc(act.points[0].x, act.points[0].y, act.size / 2, 0, Math.PI * 2);
            cx.fill();
            return;
        }
        cx.beginPath();
        cx.strokeStyle = act.color;
        cx.lineWidth = act.size;
        cx.lineCap = 'round';
        cx.lineJoin = 'round';
        cx.moveTo(act.points[0].x, act.points[0].y);
        for (let i = 1; i < act.points.length; i++) {
            cx.lineTo(act.points[i].x, act.points[i].y);
        }
        cx.stroke();
    } else if (act.type === 'fill') {
        floodFill(act.x, act.y, act.color, cx);
    }
}

function undo() {
    if (history.length === 0) return;
    
    history.pop();
    
    // Ridisegna tutto
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    history.forEach(act => applyAction(act, ctx));
}

function clearCanvas() {
    if (history.length === 0) return;
    
    if (confirm("Pulire tutto il disegno?")) {
        history = [];
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
}

function floodFill(startX, startY, fillColorHex, context) {
    const canvasEl = context.canvas;
    const width = canvasEl.width;
    const height = canvasEl.height;
    
    // Clamp e arrotonda coordinate
    startX = Math.max(0, Math.min(width - 1, Math.floor(startX)));
    startY = Math.max(0, Math.min(height - 1, Math.floor(startY)));
    
    const imageData = context.getImageData(0, 0, width, height);
    const data = imageData.data;
    
    const startIdx = (startY * width + startX) * 4;
    const targetR = data[startIdx];
    const targetG = data[startIdx + 1];
    const targetB = data[startIdx + 2];
    
    const fillRgb = hexToRgb(fillColorHex);
    
    // Non riempire se il colore √® gi√† lo stesso
    if (Math.abs(targetR - fillRgb[0]) < 5 && 
        Math.abs(targetG - fillRgb[1]) < 5 && 
        Math.abs(targetB - fillRgb[2]) < 5) {
        return;
    }
    
    const tolerance = 32;
    const pixelsToCheck = [[startX, startY]];
    const checked = new Uint8Array(width * height);
    
    let count = 0;
    const maxPixels = width * height;
    
    while (pixelsToCheck.length > 0 && count < maxPixels) {
        count++;
        const [x, y] = pixelsToCheck.pop();
        
        if (x < 0 || x >= width || y < 0 || y >= height) continue;
        
        const idx = y * width + x;
        if (checked[idx]) continue;
        checked[idx] = 1;
        
        const pixelIdx = idx * 4;
        const r = data[pixelIdx];
        const g = data[pixelIdx + 1];
        const b = data[pixelIdx + 2];
        
        // Verifica se il pixel √® simile al target
        if (Math.abs(r - targetR) > tolerance ||
            Math.abs(g - targetG) > tolerance ||
            Math.abs(b - targetB) > tolerance) {
            continue;
        }
        
        // Riempi pixel
        data[pixelIdx] = fillRgb[0];
        data[pixelIdx + 1] = fillRgb[1];
        data[pixelIdx + 2] = fillRgb[2];
        data[pixelIdx + 3] = 255;
        
        // Aggiungi vicini
        pixelsToCheck.push([x + 1, y]);
        pixelsToCheck.push([x - 1, y]);
        pixelsToCheck.push([x, y + 1]);
        pixelsToCheck.push([x, y - 1]);
    }
    
    context.putImageData(imageData, 0, 0);
}

function getPixelColor(data, x, y, width) {
    const idx = (y * width + x) * 4;
    return [data[idx], data[idx + 1], data[idx + 2]];
}

function colorsMatch(c1, c2, tolerance = 15) {
    return Math.abs(c1[0] - c2[0]) <= tolerance &&
           Math.abs(c1[1] - c2[1]) <= tolerance &&
           Math.abs(c1[2] - c2[2]) <= tolerance;
}
function setColorFromPicker(color) {
    currentColor = color;
    
    // Aggiorna picker
    const picker = document.getElementById('color-picker');
    if (picker) picker.value = color;
    
    // Aggiorna quick colors
    document.querySelectorAll('.qcolor').forEach(el => {
        el.classList.toggle('active', el.dataset.color === color);
    });
}
function renderQuickColors() {
    const container = document.getElementById('quick-colors');
    if (!container) return;
    
    container.innerHTML = QUICK_COLORS.map(c => `
        <div class="qcolor ${c === currentColor ? 'active' : ''}" 
             style="background: ${c};" 
             data-color="${c}"
             onclick="setColorFromPicker('${c}')">
        </div>
    `).join('');
}

function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (result) {
        return [
            parseInt(result[1], 16),
            parseInt(result[2], 16),
            parseInt(result[3], 16)
        ];
    }
    return [0, 0, 0];
}

function getPixel(d, x, y) {
    const i = (y * LOGICAL_SIZE + x) * 4;
    return [d.data[i], d.data[i+1], d.data[i+2]];
}

function setPixel(d, x, y, c) {
    const i = (y * LOGICAL_SIZE + x) * 4;
    d.data[i] = c[0]; d.data[i+1] = c[1]; d.data[i+2] = c[2]; d.data[i+3] = 255;
}

function colorsMatch(a, b) {
    return Math.abs(a[0]-b[0]) < 15 && Math.abs(a[1]-b[1]) < 15 && Math.abs(a[2]-b[2]) < 15;
}

function hexToRgb(h) {
    const n = parseInt(h.slice(1), 16);
    return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
}

function setTool(t) {
    currentTool = t;
    document.querySelectorAll('.toolbar-left .tool-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    const btn = document.getElementById(`tool-${t}`);
    if (btn) btn.classList.add('active');
}
function setSize(s) {
    currentSize = parseInt(s);
    
    // Aggiorna pulsanti visivamente
    document.querySelectorAll('.size-btn').forEach(btn => btn.classList.remove('active'));
    
    if (s <= 6) {
        document.getElementById('size-small')?.classList.add('active');
    } else if (s <= 18) {
        document.getElementById('size-medium')?.classList.add('active');
    } else {
        document.getElementById('size-large')?.classList.add('active');
    }
}

// ========================================
// COMPRESSIONE
// ========================================
function compressDrawing(historyData) {
    return historyData.map(op => {
        const cIdx = COLORS.indexOf(op.color);
        const colorCode = cIdx >= 0 ? cIdx.toString(36) : op.color;
        
        if (op.type === 'stroke') {
            let prevX = 0, prevY = 0;
            const pts = op.points.map(p => {
                const dx = p.x - prevX, dy = p.y - prevY;
                prevX = p.x; prevY = p.y;
                return `${dx.toString(36)}.${dy.toString(36)}`;
            }).join(',');
            return `S${colorCode}|${op.size.toString(36)}|${pts}`;
        } else {
            return `F${colorCode}|${op.x.toString(36)}.${op.y.toString(36)}`;
        }
    }).join('~');
}

function decompressDrawing(str) {
    if (!str) return [];
    return str.split('~').map(s => {
        const type = s.charAt(0);
        const parts = s.substring(1).split('|');
        
        const colorCode = parts[0];
        const color = colorCode.length <= 2 ? 
            COLORS[parseInt(colorCode, 36)] || '#000000' : colorCode;
        
        if (type === 'S') {
            const size = parseInt(parts[1], 36);
            const pts = []; let cx = 0, cy = 0;
            parts[2].split(',').forEach(pt => {
                const [dx, dy] = pt.split('.').map(v => parseInt(v, 36));
                cx += dx; cy += dy; pts.push({x: cx, y: cy});
            });
            return { type: 'stroke', color, size, points: pts };
        } else {
            const [x, y] = parts[1].split('.').map(v => parseInt(v, 36));
            return { type: 'fill', color, x, y };
        }
    });
}

// ========================================
// INIT
// ========================================
window.onload = async () => {
    const urlParams = new URLSearchParams(window.location.search);
    const roomCode = urlParams.get('room');
    const mioNome = localStorage.getItem('mioNome');
        // ‚úÖ AGGIUNGI QUESTE RIGHE
    const gameMode = urlParams.get('mode') || 'classic';
    if (!roomCode || !mioNome) {
        alert("Accedi dalla homepage per giocare!");
        window.location.href = 'index.html';
        return;
    }
    
    state.playerName = mioNome;
    state.roomId = roomCode;
    
    showScreen('loading-screen');
    
    try {
        const doc = await db.collection("pictionary_rooms").doc(roomCode).get();
        
if (!doc.exists) {
    // ‚úÖ Nessun alert
    window.location.href = 'index.html';
    return;
}
        
        const data = doc.data();
        if (!data.settings || !data.settings.mode) {
            await db.collection("pictionary_rooms").doc(roomCode).update({
                'settings.mode': gameMode,
                'settings.timePerRound': data.settings?.timePerRound || 60
            });
        }        
        if (data.players.includes(mioNome)) {
            state.isHost = data.host === mioNome;
            enterLobby();
        } else if (data.stato === 'lobby') {
            await db.collection("pictionary_rooms").doc(roomCode).update({
                players: firebase.firestore.FieldValue.arrayUnion(mioNome)
            });
            state.isHost = false;
            enterLobby();
        } else {
            alert("La partita √® gi√† iniziata!");
            window.location.href = 'index.html';
        }
        
} catch (e) {
    console.error("Errore auto-join:", e);
    // ‚úÖ Nessun alert
    window.location.href = 'index.html';
}
};

// ========================================
// NAVIGAZIONE
// ========================================
function tornaHome() {
    if (unsubscribeRoom) {
        unsubscribeRoom();
        unsubscribeRoom = null;
    }
    
    if (timerInterval) {
        clearInterval(timerInterval);
    }
    
    window.location.href = 'index.html';
}

function showHomeButton() {
    const btn = document.getElementById('fixed-home-btn');
    if (btn) btn.style.display = 'block';
}

function hideHomeButton() {
    const btn = document.getElementById('fixed-home-btn');
    if (btn) btn.style.display = 'none';
}
// ========================================
// MODALIT√Ä GUESS IT! - VERSIONE CORRETTA
// ========================================

let guessIt = {
    canvas: null,
    ctx: null,
    isDrawer: false,
    currentWord: '',
    isDrawing: false,
    streamInterval: null,
    timerInterval: null,
    tool: 'pen',
    color: '#000000',
    size: 12,
    history: [],
    initialized: false,      // ‚úÖ Evita re-init
    currentRound: -1,        // ‚úÖ Traccia round corrente
    roundEndedLocally: false // ‚úÖ Evita doppi avanzamenti
};

function handleGuessItPhase(data) {
    const gi = data.guessIt;
    if (!gi) return;
    
    const currentRoundFromDB = gi.round || 0;
    const amIDrawer = gi.currentDrawer === state.playerName;
    
    // ‚úÖ PRIMO CARICAMENTO o CAMBIO ROUND
    if (!guessIt.initialized || guessIt.currentRound !== currentRoundFromDB) {
        console.log(`üîÆ GuessIt: Inizializzazione round ${currentRoundFromDB}`);
        
        guessIt.initialized = true;
        guessIt.currentRound = currentRoundFromDB;
        guessIt.isDrawer = amIDrawer;
        guessIt.roundEndedLocally = false;
        guessIt.history = [];
        
        showScreen('guessit-screen');
        showHomeButton();
        removeBanner();
        
        // Setup canvas
        guessIt.canvas = document.getElementById('guessitCanvas');
        guessIt.ctx = guessIt.canvas.getContext('2d');
        guessIt.canvas.width = 500;
        guessIt.canvas.height = 500;
        guessIt.ctx.fillStyle = '#ffffff';
        guessIt.ctx.fillRect(0, 0, 500, 500);
        
        // Aggiorna UI
        document.getElementById('guessit-round-info').textContent = 
            `ROUND ${currentRoundFromDB + 1}/${gi.totalRounds || 5}`;
    
        if (amIDrawer) {
            setupGuessItDrawer(gi);
        } else {
            setupGuessItGuesser(gi);
        }
        
        // Timer - avvia solo una volta per round
        startGuessItTimer(gi.timePerRound || 60);
    }
    
    // ‚úÖ AGGIORNAMENTI CONTINUI (senza re-init)
    
    // Aggiorna punteggi
    const myScore = gi.scores?.[state.playerName] || 0;
    document.getElementById('guessit-my-score').textContent = myScore;
    
    const drawerScore = gi.scores?.[gi.currentDrawer] || 0;
    document.getElementById('guessit-drawer-score').textContent = drawerScore;
    
    // Aggiorna feed risposte
    updateGuessItFeed(gi.guesses || {}, gi.currentDrawer);
    
    // Se NON sono il disegnatore, aggiorna canvas
    if (!guessIt.isDrawer && gi.canvasData) {
        const img = new Image();
        img.onload = () => {
            if (guessIt.canvas) {
                guessIt.ctx.drawImage(img, 0, 0, guessIt.canvas.width, guessIt.canvas.height);
            }
        };
        img.src = gi.canvasData;
    }
    
    // ‚úÖ GESTIONE VINCITORE ROUND
    if (gi.roundWinner && !guessIt.roundEndedLocally) {
        guessIt.roundEndedLocally = true;
        showRoundWinnerBanner(gi.roundWinner, gi.currentWord, gi.currentDrawer, data);
    }
}

function setupGuessItDrawer(gi) {
    guessIt.currentWord = gi.currentWord;
    
    // Layout disegnatore
    document.getElementById('guessit-toolbar-left').style.display = 'flex';
    document.getElementById('guessit-placeholder-left').style.display = 'none';
    document.getElementById('guessit-word-badge').style.display = 'block';
    document.getElementById('guessit-drawer-info').style.display = 'none';
    document.getElementById('guessit-answers-sidebar').style.display = 'flex';
    
    // Parola da disegnare
const badge = document.getElementById('guessit-word-badge');
badge.innerHTML = `
    <div style="font-size: 0.7rem; opacity: 0.8; margin-bottom: 3px;">
        ${gi.currentCategory || 'üé® Disegna'}
    </div>
    <div style="font-size: 1.1rem;">
        ${gi.currentWord || 'Caricamento...'}
    </div>
`;
    
    // Nascondi input, mostra "Sei il disegnatore"
    const inputArea = document.getElementById('guessit-input-area');
    if (inputArea) inputArea.style.display = 'none';
    
    const drawerNotice = document.getElementById('guessit-drawer-notice');
    if (drawerNotice) drawerNotice.style.display = 'block';
    
    // Canvas interattivo
    guessIt.canvas.style.cursor = 'crosshair';
    attachGuessItCanvasListeners();
    
    // Quick colors
    renderGuessItQuickColors();
    
    // Reset tools
    guessIt.tool = 'pen';
    guessIt.color = '#000000';
    guessIt.size = 12;
    setGuessItTool('pen');
    setGuessItSize(12);
    
    // Streaming
    startGuessItStreaming();
}

function setupGuessItGuesser(gi) {
    // Layout indovinatore
    document.getElementById('guessit-toolbar-left').style.display = 'none';
    document.getElementById('guessit-placeholder-left').style.display = 'flex';
    document.getElementById('guessit-word-badge').style.display = 'none';
    document.getElementById('guessit-drawer-info').style.display = 'block';
    document.getElementById('guessit-answers-sidebar').style.display = 'flex';
    
    // Info disegnatore
    document.getElementById('guessit-drawer-info').textContent = 
        `üé® ${gi.currentDrawer} STA DISEGNANDO...`;
    
    // Mostra input
    const inputArea = document.getElementById('guessit-input-area');
    if (inputArea) inputArea.style.display = 'block';
    
    const drawerNotice = document.getElementById('guessit-drawer-notice');
    if (drawerNotice) drawerNotice.style.display = 'none';
    
    // Canvas non interattivo
    guessIt.canvas.style.cursor = 'default';
    
    // Focus input
    const input = document.getElementById('guessit-input');
    if (input) {
        input.value = '';
        setTimeout(() => input.focus(), 100);
        input.onkeypress = (e) => {
            if (e.key === 'Enter') submitGuessItAnswer();
        };
    }
}

// ========================================
// BANNER VINCITORE + COUNTDOWN
// ========================================

function showRoundWinnerBanner(winner, word, drawer, data) {
    // Ferma streaming e timer
    if (guessIt.streamInterval) clearInterval(guessIt.streamInterval);
    if (guessIt.timerInterval) clearInterval(guessIt.timerInterval);
    
    const isMe = winner === state.playerName;
    const iAmDrawer = drawer === state.playerName;
    
    // Punti guadagnati
    let pointsMsg = '';
    if (isMe) {
        pointsMsg = '+10 punti per aver indovinato!';
    } else if (iAmDrawer) {
        pointsMsg = '+5 punti perch√© hanno indovinato!';
    }
    
    // Banner verde grande
    removeBanner();
    const banner = document.createElement('div');
    banner.id = 'game-banner';
    banner.className = 'game-banner';
    banner.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; z-index: 99999;
        background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
        padding: 20px; text-align: center; animation: slideDown 0.3s ease;
        box-shadow: 0 5px 30px rgba(39, 174, 96, 0.5);
    `;
    banner.innerHTML = `
        <div style="font-size: 2.5rem; margin-bottom: 10px;">üéâ</div>
        <div style="font-size: 1.5rem; font-weight: 900; color: white;">
            ${winner} HA INDOVINATO!
        </div>
        <div style="font-size: 1.2rem; color: rgba(255,255,255,0.9); margin-top: 5px;">
            La parola era: <strong>"${word}"</strong>
        </div>
        ${pointsMsg ? `<div style="font-size: 1rem; color: #ffd700; margin-top: 10px; font-weight: bold;">${pointsMsg}</div>` : ''}
        <div id="countdown-text" style="font-size: 1.1rem; margin-top: 15px; color: rgba(255,255,255,0.8);">
            Prossimo round tra <span id="countdown-num">3</span>...
        </div>
    `;
    document.body.appendChild(banner);
    
    // Overlay centrale
    const overlay = document.createElement('div');
    overlay.id = 'winner-overlay';
    overlay.style.cssText = `
        position: fixed; inset: 0; z-index: 99998;
        background: rgba(0,0,0,0.7); display: flex;
        justify-content: center; align-items: center;
        animation: fadeIn 0.3s ease;
    `;
    overlay.innerHTML = `
        <div style="text-align: center; color: white;">
            <div style="font-size: 8rem; animation: bounce 0.5s infinite;">üèÜ</div>
            <div style="font-size: 2rem; font-weight: 900; margin-top: 20px;">
                ${isMe ? 'HAI INDOVINATO!' : `${winner} ha indovinato!`}
            </div>
        </div>
    `;
    document.body.appendChild(overlay);
    
    // Countdown 3, 2, 1
    let count = 3;
    const countdownEl = document.getElementById('countdown-num');
    
    const countdownInterval = setInterval(() => {
        count--;
        if (countdownEl) countdownEl.textContent = count;
        
        if (count <= 0) {
            clearInterval(countdownInterval);
            overlay.remove();
            
            // Avanza al prossimo round (solo host)
            if (state.isHost) {
                advanceGuessItRound();
            }
        }
    }, 1000);
}

function showTimeUpBanner(word, drawer, data) {
    if (guessIt.streamInterval) clearInterval(guessIt.streamInterval);
    if (guessIt.timerInterval) clearInterval(guessIt.timerInterval);
    
    removeBanner();
    const banner = document.createElement('div');
    banner.id = 'game-banner';
    banner.className = 'game-banner';
    banner.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; z-index: 99999;
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        padding: 20px; text-align: center; animation: slideDown 0.3s ease;
    `;
    banner.innerHTML = `
        <div style="font-size: 2rem; margin-bottom: 10px;">‚è∞</div>
        <div style="font-size: 1.3rem; font-weight: 900; color: white;">TEMPO SCADUTO!</div>
        <div style="font-size: 1rem; color: rgba(255,255,255,0.9); margin-top: 5px;">
            La parola era: <strong>"${word}"</strong>
        </div>
        <div id="countdown-text" style="font-size: 1rem; margin-top: 15px; color: rgba(255,255,255,0.8);">
            Prossimo round tra <span id="countdown-num">3</span>...
        </div>
    `;
    document.body.appendChild(banner);
    
    let count = 3;
    const countdownEl = document.getElementById('countdown-num');
    
    const countdownInterval = setInterval(() => {
        count--;
        if (countdownEl) countdownEl.textContent = count;
        
        if (count <= 0) {
            clearInterval(countdownInterval);
            if (state.isHost) {
                advanceGuessItRound();
            }
        }
    }, 1000);
}

// ========================================
// CANVAS E STRUMENTI
// ========================================

function renderGuessItQuickColors() {
    const container = document.getElementById('gi-quick-colors');
    if (!container) return;
    
    container.innerHTML = QUICK_COLORS.map(c => `
        <div class="qcolor ${c === guessIt.color ? 'active' : ''}" 
             style="background: ${c};" 
             data-color="${c}"
             onclick="setGuessItColor('${c}')">
        </div>
    `).join('');
}

function attachGuessItCanvasListeners() {
    const c = guessIt.canvas;
    if (!c) return;
    
    // Rimuovi listener precedenti
    c.onmousedown = null;
    c.onmousemove = null;
    c.ontouchstart = null;
    c.ontouchmove = null;
    
    const getPos = (e) => {
        const rect = c.getBoundingClientRect();
        let clientX, clientY;
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        return {
            x: Math.round((clientX - rect.left) * (c.width / rect.width)),
            y: Math.round((clientY - rect.top) * (c.height / rect.height))
        };
    };
    
    let lastPos = null;
    
    const start = (e) => {
        e.preventDefault();
        
        if (guessIt.tool === 'bucket') {
            const pos = getPos(e);
            guessIt.history.push({ type: 'fill', color: guessIt.color, x: pos.x, y: pos.y });
            floodFillGuessIt(pos.x, pos.y, guessIt.color);
            return;
        }
        
        guessIt.isDrawing = true;
        lastPos = getPos(e);
        
        const color = guessIt.tool === 'eraser' ? '#ffffff' : guessIt.color;
        guessIt.history.push({ type: 'stroke', color: color, size: guessIt.size, points: [lastPos] });
        
        guessIt.ctx.beginPath();
        guessIt.ctx.fillStyle = color;
        guessIt.ctx.arc(lastPos.x, lastPos.y, guessIt.size / 2, 0, Math.PI * 2);
        guessIt.ctx.fill();
    };
    
    const draw = (e) => {
        if (!guessIt.isDrawing) return;
        e.preventDefault();
        
        const pos = getPos(e);
        const stroke = guessIt.history[guessIt.history.length - 1];
        
        if (stroke && stroke.points) {
            stroke.points.push(pos);
        }
        
        const color = guessIt.tool === 'eraser' ? '#ffffff' : guessIt.color;
        guessIt.ctx.beginPath();
        guessIt.ctx.strokeStyle = color;
        guessIt.ctx.lineWidth = guessIt.size;
        guessIt.ctx.lineCap = 'round';
        guessIt.ctx.lineJoin = 'round';
        guessIt.ctx.moveTo(lastPos.x, lastPos.y);
        guessIt.ctx.lineTo(pos.x, pos.y);
        guessIt.ctx.stroke();
        lastPos = pos;
    };
    
    const stop = () => { guessIt.isDrawing = false; };
    
    c.onmousedown = start;
    c.onmousemove = draw;
    window.addEventListener('mouseup', stop);
    c.ontouchstart = start;
    c.ontouchmove = draw;
    c.ontouchend = stop;
}

function floodFillGuessIt(startX, startY, fillColorHex) {
    const ctx = guessIt.ctx;
    const canvas = guessIt.canvas;
    const width = canvas.width;
    const height = canvas.height;
    
    startX = Math.max(0, Math.min(width - 1, Math.floor(startX)));
    startY = Math.max(0, Math.min(height - 1, Math.floor(startY)));
    
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    
    const startIdx = (startY * width + startX) * 4;
    const targetR = data[startIdx];
    const targetG = data[startIdx + 1];
    const targetB = data[startIdx + 2];
    
    const fillRgb = hexToRgb(fillColorHex);
    
    if (Math.abs(targetR - fillRgb[0]) < 5 && 
        Math.abs(targetG - fillRgb[1]) < 5 && 
        Math.abs(targetB - fillRgb[2]) < 5) {
        return;
    }
    
    const tolerance = 32;
    const pixelsToCheck = [[startX, startY]];
    const checked = new Uint8Array(width * height);
    
    let count = 0;
    const maxPixels = width * height;
    
    while (pixelsToCheck.length > 0 && count < maxPixels) {
        count++;
        const [x, y] = pixelsToCheck.pop();
        
        if (x < 0 || x >= width || y < 0 || y >= height) continue;
        
        const idx = y * width + x;
        if (checked[idx]) continue;
        checked[idx] = 1;
        
        const pixelIdx = idx * 4;
        const r = data[pixelIdx];
        const g = data[pixelIdx + 1];
        const b = data[pixelIdx + 2];
        
        if (Math.abs(r - targetR) > tolerance ||
            Math.abs(g - targetG) > tolerance ||
            Math.abs(b - targetB) > tolerance) {
            continue;
        }
        
        data[pixelIdx] = fillRgb[0];
        data[pixelIdx + 1] = fillRgb[1];
        data[pixelIdx + 2] = fillRgb[2];
        data[pixelIdx + 3] = 255;
        
        pixelsToCheck.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
    }
    
    ctx.putImageData(imageData, 0, 0);
}

function setGuessItTool(t) {
    guessIt.tool = t;
    document.getElementById('gi-tool-pen')?.classList.toggle('active', t === 'pen');
    document.getElementById('gi-tool-eraser')?.classList.toggle('active', t === 'eraser');
    document.getElementById('gi-tool-bucket')?.classList.toggle('active', t === 'bucket');
}

function setGuessItSize(s) {
    guessIt.size = s;
    document.querySelectorAll('#guessit-toolbar-left .size-btn').forEach(btn => btn.classList.remove('active'));
    if (s <= 6) document.getElementById('gi-size-small')?.classList.add('active');
    else if (s <= 18) document.getElementById('gi-size-medium')?.classList.add('active');
    else document.getElementById('gi-size-large')?.classList.add('active');
}

function setGuessItColor(c) {
    guessIt.color = c;
    const picker = document.getElementById('gi-color-picker');
    if (picker) picker.value = c;
    
    document.querySelectorAll('#gi-quick-colors .qcolor').forEach(el => {
        el.classList.toggle('active', el.dataset.color === c);
    });
}

function undoGuessIt() {
    if (guessIt.history.length === 0) return;
    guessIt.history.pop();
    redrawGuessItCanvas();
}

function clearGuessItCanvas() {
    if (guessIt.history.length === 0) return;
    if (confirm("Pulire tutto?")) {
        guessIt.history = [];
        guessIt.ctx.fillStyle = '#ffffff';
        guessIt.ctx.fillRect(0, 0, guessIt.canvas.width, guessIt.canvas.height);
    }
}

function redrawGuessItCanvas() {
    guessIt.ctx.fillStyle = '#ffffff';
    guessIt.ctx.fillRect(0, 0, guessIt.canvas.width, guessIt.canvas.height);
    
    guessIt.history.forEach(act => {
        if (act.type === 'stroke' && act.points && act.points.length > 0) {
            if (act.points.length === 1) {
                guessIt.ctx.beginPath();
                guessIt.ctx.fillStyle = act.color;
                guessIt.ctx.arc(act.points[0].x, act.points[0].y, act.size / 2, 0, Math.PI * 2);
                guessIt.ctx.fill();
            } else {
                guessIt.ctx.beginPath();
                guessIt.ctx.strokeStyle = act.color;
                guessIt.ctx.lineWidth = act.size;
                guessIt.ctx.lineCap = 'round';
                guessIt.ctx.lineJoin = 'round';
                guessIt.ctx.moveTo(act.points[0].x, act.points[0].y);
                for (let i = 1; i < act.points.length; i++) {
                    guessIt.ctx.lineTo(act.points[i].x, act.points[i].y);
                }
                guessIt.ctx.stroke();
            }
        } else if (act.type === 'fill') {
            floodFillGuessIt(act.x, act.y, act.color);
        }
    });
}

// ========================================
// STREAMING E TIMER
// ========================================

function startGuessItStreaming() {
    if (guessIt.streamInterval) clearInterval(guessIt.streamInterval);
    
    guessIt.streamInterval = setInterval(async () => {
        if (!guessIt.isDrawer || !guessIt.canvas) return;
        
        try {
            const dataUrl = guessIt.canvas.toDataURL('image/jpeg', 0.6);
            await db.collection("pictionary_rooms").doc(state.roomId).update({
                'guessIt.canvasData': dataUrl
            });
        } catch (e) {
            console.error('Errore streaming:', e);
        }
    }, 350);
}

function startGuessItTimer(seconds) {
    if (guessIt.timerInterval) clearInterval(guessIt.timerInterval);
    
    let remaining = seconds;
    const timerEl = document.getElementById('guessit-timer');
    
    if (timerEl) {
        timerEl.textContent = remaining;
        timerEl.classList.remove('warning');
    }
    
    guessIt.timerInterval = setInterval(() => {
        remaining--;
        
        if (timerEl) {
            timerEl.textContent = remaining;
            if (remaining <= 10) {
                timerEl.classList.add('warning');
            }
        }
        
        if (remaining <= 0) {
            clearInterval(guessIt.timerInterval);
            guessIt.timerInterval = null;
            
            // Tempo scaduto
            if (!guessIt.roundEndedLocally) {
                guessIt.roundEndedLocally = true;
                const gi = state.roomData?.guessIt;
                if (gi) {
                    showTimeUpBanner(gi.currentWord, gi.currentDrawer, state.roomData);
                }
            }
        }
    }, 1000);
}

// ========================================
// RISPOSTE E VALIDAZIONE
// ========================================

async function submitGuessItAnswer() {
    const input = document.getElementById('guessit-input');
    if (!input) return;
    
    const answer = input.value.trim();
    if (!answer) return;
    
    input.value = '';
    input.focus();
    
    const gi = state.roomData?.guessIt;
    if (!gi) return;
    
    const correctWord = gi.currentWord.toUpperCase().trim();
    const userAnswer = answer.toUpperCase().trim();
    
    // Normalizza per confronto
    const normalize = (s) => s.normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/\s+/g, ' ').trim();
    const isCorrect = normalize(userAnswer) === normalize(correctWord);
    
    const guessId = Date.now().toString();
    
    await db.collection("pictionary_rooms").doc(state.roomId).update({
        [`guessIt.guesses.${guessId}`]: {
            id: guessId,
            player: state.playerName,
            answer: answer,
            correct: isCorrect,
            approved: false,
            timestamp: Date.now()
        }
    });
    
    if (isCorrect) {
        await markAsWinner(state.playerName, gi.currentDrawer);
    }
}

// ‚úÖ Il disegnatore pu√≤ approvare una risposta
async function approveAnswer(guessId, playerName) {
    const gi = state.roomData?.guessIt;
    if (!gi || gi.currentDrawer !== state.playerName) return;
    
    // Marca come approvato
    await db.collection("pictionary_rooms").doc(state.roomId).update({
        [`guessIt.guesses.${guessId}.approved`]: true,
        [`guessIt.guesses.${guessId}.correct`]: true
    });
    
    // Assegna punti
    await markAsWinner(playerName, gi.currentDrawer);
}

async function markAsWinner(guesser, drawer) {
    const pointsGuesser = 10;
    const pointsDrawer = 5;
    
    await db.collection("pictionary_rooms").doc(state.roomId).update({
        [`guessIt.scores.${guesser}`]: firebase.firestore.FieldValue.increment(pointsGuesser),
        [`guessIt.scores.${drawer}`]: firebase.firestore.FieldValue.increment(pointsDrawer),
        'guessIt.roundWinner': guesser
    });
}

async function advanceGuessItRound() {
    if (guessIt.streamInterval) clearInterval(guessIt.streamInterval);
    if (guessIt.timerInterval) clearInterval(guessIt.timerInterval);
    
    removeBanner();
    document.getElementById('winner-overlay')?.remove();
    
    const data = state.roomData;
    const gi = data?.guessIt;
    if (!gi) return;
    
    const nextRound = (gi.round || 0) + 1;
    const totalRounds = gi.totalRounds || data.players.length;
    
    // Reset per prossimo round
    guessIt.initialized = false;
    
    if (nextRound >= totalRounds) {
        // Fine gioco
        await db.collection("pictionary_rooms").doc(state.roomId).update({
            stato: 'results',
            scores: gi.scores || {}
        });
    } else {
        // Prossimo round
        const nextDrawerIdx = nextRound % data.players.length;
        const nextDrawer = data.players[nextDrawerIdx];
const theme = getRandomTheme(); // ‚úÖ Usa la nuova funzione

await db.collection("pictionary_rooms").doc(state.roomId).update({
    'guessIt.round': nextRound,
    'guessIt.currentDrawer': nextDrawer,
    'guessIt.currentWord': theme.word,       // ‚úÖ Parola
    'guessIt.currentCategory': theme.category, // ‚úÖ Categoria
    'guessIt.canvasData': null,
    'guessIt.guesses': {},
    'guessIt.roundWinner': null
});
    }
}

// ========================================
// FEED RISPOSTE (con pulsante approva)
// ========================================

function updateGuessItFeed(guesses, currentDrawer) {
    const feed = document.getElementById('guessit-feed');
    if (!feed) return;
    
    const sorted = Object.values(guesses).sort((a, b) => b.timestamp - a.timestamp);
    
    if (sorted.length === 0) {
        feed.innerHTML = '<div style="text-align: center; opacity: 0.5; padding: 20px; font-size: 0.85rem;">Le risposte appariranno qui...</div>';
        return;
    }
    
    const amIDrawer = currentDrawer === state.playerName;
    
    feed.innerHTML = sorted.map(g => {
        const isCorrectOrApproved = g.correct || g.approved;
        
        // Pulsante approva (solo per disegnatore, solo se non gi√† approvato)
        let approveBtn = '';
        if (amIDrawer && !isCorrectOrApproved && !state.roomData?.guessIt?.roundWinner) {
            approveBtn = `
                <button onclick="approveAnswer('${g.id}', '${g.player}')" 
                        style="margin-top: 8px; padding: 5px 12px; background: var(--success); 
                               color: white; border: none; border-radius: 5px; 
                               font-size: 0.75rem; font-weight: bold; cursor: pointer;">
                    ‚úÖ ACCETTA
                </button>
            `;
        }
        
        return `
            <div style="
                padding: 10px 12px; margin-bottom: 8px; border-radius: 10px;
                background: ${isCorrectOrApproved ? 'rgba(78, 205, 196, 0.25)' : 'var(--bg)'};
                border-left: 4px solid ${isCorrectOrApproved ? 'var(--success)' : 'var(--border)'};
            ">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span style="font-weight: 700; font-size: 0.8rem; color: ${isCorrectOrApproved ? 'var(--success)' : 'var(--text)'};">
                        ${g.player}
                    </span>
                    ${isCorrectOrApproved ? '<span style="color: var(--success); font-weight: bold;">‚úÖ</span>' : ''}
                </div>
                <div style="font-size: 0.9rem; opacity: 0.9; margin-top: 4px;">${g.answer}</div>
                ${approveBtn}
            </div>
        `;
    }).join('');
    
    feed.scrollTop = 0;
}
</script>

</body>
</html>
