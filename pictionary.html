<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PICTIONARY üé®</title>
    <script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-firestore-compat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;900&family=JetBrains+Mono&display=swap');

        :root {
            --bg: #1a1a2e; --panel: #16213e; --primary: #e94560; --accent: #0f3460;
            --text: #eaeaea; --border: #0f3460; --danger: #ff6b6b; --success: #4ecdc4;
            --gold: #ffd700; --silver: #c0c0c0; --bronze: #cd7f32;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text);
            margin: 0; padding: 0; min-height: 100vh; display: flex; flex-direction: column;
        }

        /* === ANIMAZIONI === */
        @keyframes slideDown { from { transform: translateY(-100%); } to { transform: translateY(0); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.1); opacity: 0.8; } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes confetti { 0% { transform: translateY(0) rotate(0deg); opacity: 1; } 100% { transform: translateY(100vh) rotate(720deg); opacity: 0; } }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        @keyframes glow { 0%, 100% { box-shadow: 0 0 20px var(--primary); } 50% { box-shadow: 0 0 40px var(--primary), 0 0 60px var(--primary); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes timerPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.15); } }

        /* === LAYOUT === */
        .app-container {
            width: 100%; max-width: 1000px; margin: 0 auto; min-height: 100vh;
            background: var(--panel); display: flex; flex-direction: column;
            box-shadow: 0 0 50px rgba(0,0,0,0.3); position: relative;
        }

        header {
            padding: 12px 20px; border-bottom: 2px solid var(--border);
            display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(135deg, var(--panel) 0%, var(--accent) 100%);
            position: sticky; top: 0; z-index: 100;
        }

        .header-left { display: flex; align-items: center; gap: 15px; }
        .room-tag { 
            font-size: 0.7rem; color: var(--primary); font-weight: 700; 
            letter-spacing: 2px; text-transform: uppercase;
            background: rgba(233, 69, 96, 0.2); padding: 4px 10px; border-radius: 4px;
        }
        .player-name { font-weight: 900; color: var(--text); font-size: 1rem; }
        
        #timer { 
            font-family: 'JetBrains Mono'; font-weight: bold; color: var(--danger); 
            font-size: 2rem; min-width: 60px; text-align: center;
            text-shadow: 0 0 20px var(--danger);
        }
        #timer.warning { animation: pulse 0.5s infinite; color: #ff0000; }

        /* === CANVAS AREA === */
        #game-area {
            flex: 1; display: flex; flex-direction: column; 
            padding: 15px; overflow: hidden; align-items: center; justify-content: center;
            background: radial-gradient(circle at center, #1e2a4a 0%, var(--bg) 100%);
        }

        .canvas-wrapper {
            width: 100%; max-width: 500px; display: flex; flex-direction: column; gap: 10px;
        }

        .canvas-container {
            width: 100%; aspect-ratio: 1 / 1;
            background: #fff; cursor: crosshair; touch-action: none; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.4); border-radius: 12px;
            border: 3px solid var(--primary); position: relative;
            overflow: hidden;
        }

        .canvas-badge {
            position: absolute; top: 10px; left: 10px; 
            background: linear-gradient(135deg, var(--primary) 0%, #ff6b9d 100%);
            color: white; padding: 8px 15px; border-radius: 8px; 
            font-size: 0.85rem; font-weight: 700;
            pointer-events: none; z-index: 20; text-transform: uppercase;
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }

        /* === MINIATURA RIFERIMENTO INGRANDIBILE === */
        .reference-thumbnail {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 100px;
            height: 100px;
            background: white;
            border: 3px solid var(--success);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            z-index: 25;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            overflow: hidden;
        }

        .reference-thumbnail:hover {
            transform: scale(3.5) translate(-35%, 15%);
            z-index: 100;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }

        .reference-thumbnail canvas {
            width: 100%;
            height: 100%;
        }

        .reference-thumbnail .label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--success);
            color: white;
            font-size: 0.5rem;
            font-weight: bold;
            text-align: center;
            padding: 2px;
            opacity: 1;
            transition: opacity 0.3s;
        }

        .reference-thumbnail:hover .label {
            opacity: 0;
        }

        canvas { width: 100%; height: 100%; display: block; border-radius: 10px; }

        /* === TOOLBAR === */
        .toolbar {
            padding: 15px; background: var(--panel); border-top: 2px solid var(--border);
            display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: center;
            position: sticky; bottom: 0; z-index: 100;
        }

        .color-palette { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; }
        .color-dot {
            width: 32px; height: 32px; border-radius: 8px; border: 3px solid transparent; 
            cursor: pointer; transition: all 0.2s;
        }
        .color-dot:hover { transform: scale(1.1); }
        .color-dot.active { 
            border-color: var(--text); transform: scale(1.2); 
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        .tools-group { 
            display: flex; gap: 5px; background: var(--bg); 
            padding: 5px; border-radius: 10px; 
        }
        
        .tool-btn {
            width: 44px; height: 44px; border: none; background: transparent; border-radius: 8px;
            cursor: pointer; display: flex; align-items: center; justify-content: center; 
            font-size: 1.3rem; color: var(--text); transition: all 0.2s;
        }
        .tool-btn:hover { background: var(--accent); }
        .tool-btn.active { 
            background: var(--primary); color: white; 
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }

        .btn {
            padding: 12px 25px; border-radius: 10px; border: none; font-family: inherit; 
            font-weight: 700; cursor: pointer; font-size: 0.9rem; transition: all 0.2s;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .btn:active { transform: scale(0.95); }
        .btn-primary { 
            background: linear-gradient(135deg, var(--primary) 0%, #ff6b9d 100%); 
            color: white; box-shadow: 0 4px 20px rgba(233, 69, 96, 0.4); 
        }
        .btn-primary:hover { box-shadow: 0 6px 30px rgba(233, 69, 96, 0.6); }
        .btn-success { 
            background: linear-gradient(135deg, var(--success) 0%, #26d0ce 100%); 
            color: white; 
        }
        .btn-secondary { background: var(--accent); color: var(--text); }
        .btn-danger { background: var(--danger); color: white; }
        .btn-gold { 
            background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%); 
            color: #1a1a2e; 
        }

        /* === OVERLAYS === */
        .overlay {
            position: fixed; inset: 0; background: var(--bg);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000; text-align: center; padding: 20px; overflow-y: auto;
        }
        .hidden { display: none !important; }

        .card {
            background: var(--panel); padding: 30px; border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4); width: 100%; max-width: 500px;
            display: flex; flex-direction: column; gap: 15px; 
            border: 2px solid var(--border); animation: fadeIn 0.3s ease;
        }

        h1 { font-size: 2rem; margin: 0; color: var(--primary); letter-spacing: -1px; }
        h2 { font-size: 1.5rem; margin: 0; color: var(--text); }
        
        input, select, textarea {
            width: 100%; padding: 14px; border-radius: 10px; border: 2px solid var(--border);
            background: var(--bg); font-family: 'JetBrains Mono', monospace; font-size: 1rem;
            outline: none; color: var(--text);
        }
        input:focus, select:focus, textarea:focus { border-color: var(--primary); }
        input::placeholder { color: #666; }

        .theme-box {
            background: linear-gradient(135deg, var(--primary) 0%, #ff6b9d 100%);
            padding: 25px; border-radius: 15px; margin: 15px 0;
            font-size: 1.8rem; font-weight: 900; color: white;
            text-transform: uppercase; letter-spacing: 2px;
            box-shadow: 0 10px 30px rgba(233, 69, 96, 0.4);
            animation: pulse 2s infinite;
        }

        /* === LOBBY === */
        .players-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px; margin: 15px 0;
        }

        .player-card {
            background: var(--bg); padding: 15px 10px; border-radius: 10px;
            text-align: center; border: 2px solid var(--border);
            transition: all 0.3s;
        }
        .player-card.ready { 
            border-color: var(--success); 
            background: rgba(78, 205, 196, 0.1);
        }
        .player-card.host::after { 
            content: 'üëë'; display: block; font-size: 1.2rem; margin-top: 5px;
        }
        .player-card .name { font-weight: 700; font-size: 0.9rem; }
        .player-card .status { font-size: 0.7rem; opacity: 0.7; margin-top: 5px; }

        /* === BANNER STILE RUZZLE === */
        .game-banner {
            position: fixed; top: 0; left: 0; right: 0;
            padding: 15px 20px; display: flex; justify-content: space-between;
            align-items: center; z-index: 9999; animation: slideDown 0.3s ease;
            flex-wrap: wrap; gap: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .banner-left { display: flex; align-items: center; gap: 12px; }
        .banner-right { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .banner-icon { font-size: 1.8rem; }
        .banner-title { font-weight: 900; font-size: 1.1rem; color: white; }
        .banner-subtitle { font-size: 0.8rem; opacity: 0.9; color: white; }

        /* ‚úÖ TIMER NEL BANNER - SEMPRE VISIBILE */
        .banner-timer {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            font-weight: 900;
            color: white;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 16px;
            border-radius: 10px;
            min-width: 90px;
            text-align: center;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.3);
        }
        .banner-timer.warning {
            background: rgba(255, 0, 0, 0.4);
            border-color: #ff0000;
            animation: timerPulse 0.5s infinite;
        }

        /* === GALLERIA === */
        .gallery-container {
            width: 100%; max-width: 1200px; padding: 20px;
        }

        .chain-card {
            background: var(--panel); border-radius: 15px; padding: 20px;
            margin-bottom: 30px; border: 2px solid var(--border);
        }

        .chain-header {
            display: flex; justify-content: space-between; align-items: center;
            padding-bottom: 15px; border-bottom: 2px solid var(--border);
            margin-bottom: 20px;
        }

        .chain-title { 
            font-size: 1.2rem; font-weight: 900; color: var(--primary);
            display: flex; align-items: center; gap: 10px;
        }

        .chain-flow {
            display: flex; overflow-x: auto; gap: 20px; padding: 10px 0;
            scroll-snap-type: x mandatory;
        }

        .chain-step {
            min-width: 200px; max-width: 200px; scroll-snap-align: start;
            background: var(--bg); border-radius: 12px; padding: 10px;
            display: flex; flex-direction: column; align-items: center;
            border: 2px solid var(--border); transition: all 0.3s;
            cursor: pointer;
        }
        .chain-step:hover { border-color: var(--primary); transform: translateY(-5px); }
        .chain-step.voted { border-color: var(--gold); box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }

        .step-canvas {
            width: 100%; aspect-ratio: 1/1; background: white;
            border-radius: 8px; overflow: hidden; margin-bottom: 10px;
        }
        .step-canvas canvas { width: 100%; height: 100%; }

        .step-info { text-align: center; width: 100%; }
        .step-player { font-weight: 700; font-size: 0.85rem; color: var(--primary); }
        .step-guess { 
            font-size: 0.75rem; color: var(--text); opacity: 0.8; 
            margin-top: 5px; font-style: italic;
        }

        .chain-arrow {
            display: flex; align-items: center; font-size: 2rem; color: var(--primary);
            min-width: 40px; justify-content: center;
        }

        /* === VOTAZIONE === */
        .vote-btn {
            margin-top: 10px; width: 100%; padding: 8px;
            background: var(--accent); border: none; border-radius: 6px;
            color: white; font-weight: 700; cursor: pointer; transition: all 0.2s;
        }
        .vote-btn:hover { background: var(--primary); }
        .vote-btn.voted { background: var(--gold); color: #1a1a2e; }
/* ‚úÖ Evidenzia i propri disegni durante la votazione */
.chain-step.my-drawing {
    border-color: var(--primary);
    background: rgba(233, 69, 96, 0.1);
    position: relative;
}

.chain-step.my-drawing::before {
    content: 'üë§ TUO';
    position: absolute;
    top: 5px;
    right: 5px;
    background: var(--primary);
    color: white;
    font-size: 0.6rem;
    font-weight: bold;
    padding: 3px 8px;
    border-radius: 10px;
    z-index: 10;
}
        /* === RISULTATI === */
        .results-container {
            width: 100%; max-width: 600px;
        }

        .podium {
            display: flex; justify-content: center; align-items: flex-end;
            gap: 20px; margin: 30px 0; height: 200px;
        }

        .podium-place {
            display: flex; flex-direction: column; align-items: center;
            animation: bounce 0.5s ease;
        }

        .podium-avatar {
            width: 60px; height: 60px; border-radius: 50%;
            background: var(--panel); display: flex; align-items: center;
            justify-content: center; font-size: 1.5rem; font-weight: 900;
            border: 3px solid;
        }

        .podium-bar {
            width: 80px; display: flex; flex-direction: column;
            align-items: center; justify-content: flex-end;
            padding: 10px; border-radius: 10px 10px 0 0;
            margin-top: 10px;
        }

        .place-1 .podium-bar { height: 120px; background: linear-gradient(180deg, var(--gold) 0%, #cc9900 100%); }
        .place-1 .podium-avatar { border-color: var(--gold); }
        .place-2 .podium-bar { height: 90px; background: linear-gradient(180deg, var(--silver) 0%, #999 100%); }
        .place-2 .podium-avatar { border-color: var(--silver); }
        .place-3 .podium-bar { height: 60px; background: linear-gradient(180deg, var(--bronze) 0%, #8b5a2b 100%); }
        .place-3 .podium-avatar { border-color: var(--bronze); }

        .podium-name { font-weight: 700; font-size: 0.8rem; margin-top: 5px; }
        .podium-score { font-size: 1.2rem; font-weight: 900; color: #1a1a2e; }

        .full-ranking {
            background: var(--panel); border-radius: 15px; padding: 20px;
            margin-top: 20px;
        }

        .ranking-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 15px; border-radius: 8px; margin-bottom: 8px;
            background: var(--bg);
        }
        .ranking-row.me { border: 2px solid var(--primary); }

        .ranking-position { 
            font-weight: 900; font-size: 1.1rem; min-width: 30px;
        }
        .ranking-name { flex: 1; margin-left: 15px; font-weight: 600; }
        .ranking-score { font-weight: 900; color: var(--primary); }

        /* === SPINNER === */
        .spinner {
            width: 30px; height: 30px; border: 3px solid white;
            border-top-color: transparent; border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* === CONFETTI === */
        .confetti {
            position: fixed; width: 10px; height: 10px;
            z-index: 9999; pointer-events: none;
            animation: confetti 3s forwards;
        }

        /* === LOADING SCREEN === */
        #loading-screen {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #loading-screen .spinner-big {
            width: 60px;
            height: 60px;
            border: 4px solid var(--primary);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        #loading-screen p {
            color: var(--text);
            font-size: 1.1rem;
            opacity: 0.8;
        }

        /* === PULSANTE HOME FISSO === */
        #fixed-home-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 99999;
            display: none;
        }

        #fixed-home-btn button {
            background: var(--panel);
            color: var(--text);
            border: 2px solid var(--primary);
            padding: 12px 20px;
            border-radius: 50px;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            transition: all 0.2s ease;
        }

        #fixed-home-btn button:hover {
            transform: scale(1.05);
            background: var(--primary);
            color: white;
            box-shadow: 0 6px 25px rgba(233, 69, 96, 0.4);
        }

        /* === RESPONSIVE === */
        @media (max-width: 600px) {
            .card { padding: 20px; }
            h1 { font-size: 1.5rem; }
            .theme-box { font-size: 1.3rem; padding: 20px; }
            .toolbar { padding: 10px; gap: 8px; }
            .color-dot { width: 28px; height: 28px; }
            .tool-btn { width: 38px; height: 38px; font-size: 1.1rem; }
            .btn { padding: 10px 18px; font-size: 0.8rem; }
            .game-banner { flex-direction: column; text-align: center; }
            .banner-left, .banner-right { justify-content: center; width: 100%; }
            .banner-timer { font-size: 1.5rem; padding: 6px 12px; }
            .reference-thumbnail:hover {
                transform: scale(2.5) translate(-20%, 10%);
            }
        }
/* ========================================
   LAYOUT FULLSCREEN CANVAS
   ======================================== */

.toolbar-left {
    width: 80px;
    background: var(--panel);
    border-right: 2px solid var(--border);
    display: flex;
    flex-direction: column;
    padding: 10px;
    gap: 15px;
    overflow-y: auto;
    z-index: 100;
}

.tool-section {
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: center;
}

.tool-label {
    font-size: 0.6rem;
    font-weight: bold;
    opacity: 0.7;
    text-transform: uppercase;
    letter-spacing: 1px;
    text-align: center;
}

.toolbar-left .tool-btn {
    width: 50px;
    height: 50px;
    font-size: 1.4rem;
}

.size-slider {
    width: 60px;
    transform: rotate(-90deg);
    transform-origin: center;
    margin: 30px 0;
    accent-color: var(--primary);
}

.size-preview {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--text);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7rem;
    font-weight: bold;
    color: var(--bg);
}

.color-wheel {
    width: 60px;
    height: 60px;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    background: transparent;
    padding: 0;
}

.color-wheel::-webkit-color-swatch-wrapper {
    padding: 0;
}

.color-wheel::-webkit-color-swatch {
    border-radius: 50%;
    border: 3px solid var(--border);
}

.quick-colors {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 4px;
    margin-top: 5px;
}

.qcolor {
    width: 24px;
    height: 24px;
    border-radius: 4px;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.2s;
}

.qcolor:hover {
    transform: scale(1.2);
    border-color: white;
}

/* CANVAS AREA FULLSCREEN */
.canvas-area-fullscreen {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    background: radial-gradient(circle at center, #1e2a4a 0%, var(--bg) 100%);
    overflow: hidden;
    padding: 20px;
}

.canvas-area-fullscreen canvas#mainCanvas {
    max-width: calc(100vw - 200px);
    max-height: calc(100vh - 40px);
    aspect-ratio: 1/1;
    background: white;
    border-radius: 12px;
    border: 3px solid var(--primary);
    box-shadow: 0 10px 50px rgba(0,0,0,0.5);
    cursor: crosshair;
    touch-action: none;
}

.canvas-badge-fullscreen {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, var(--primary) 0%, #ff6b9d 100%);
    color: white;
    padding: 12px 30px;
    border-radius: 30px;
    font-size: 1.1rem;
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: 2px;
    box-shadow: 0 5px 20px rgba(233, 69, 96, 0.5);
    z-index: 50;
    white-space: nowrap;
    max-width: 80%;
    overflow: hidden;
    text-overflow: ellipsis;
}

.reference-thumbnail-fullscreen {
    position: absolute;
    top: 80px;
    right: 100px;
    width: 150px;
    height: 150px;
    background: white;
    border: 4px solid var(--success);
    border-radius: 12px;
    box-shadow: 0 5px 25px rgba(0,0,0,0.4);
    z-index: 50;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    overflow: hidden;
}

.reference-thumbnail-fullscreen:hover {
    transform: scale(2.5);
    z-index: 200;
}

.reference-thumbnail-fullscreen canvas {
    width: 100%;
    height: calc(100% - 25px);
}

.reference-thumbnail-fullscreen .ref-label {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--success);
    color: white;
    font-size: 0.55rem;
    font-weight: bold;
    text-align: center;
    padding: 4px;
}

.reference-thumbnail-fullscreen:hover .ref-label {
    opacity: 0;
}

/* INFO BAR DESTRA */
.info-bar-right {
    width: 100px;
    background: var(--panel);
    border-left: 2px solid var(--border);
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px 10px;
    gap: 20px;
}

.timer-box {
    text-align: center;
}

.timer-label {
    font-size: 0.7rem;
    opacity: 0.7;
    margin-bottom: 5px;
}

.timer-display {
    font-family: 'JetBrains Mono', monospace;
    font-size: 2.5rem;
    font-weight: 900;
    color: var(--success);
    text-shadow: 0 0 20px var(--success);
}

.timer-display.warning {
    color: var(--danger);
    text-shadow: 0 0 20px var(--danger);
    animation: pulse 0.5s infinite;
}

.round-info {
    font-size: 0.75rem;
    font-weight: bold;
    color: var(--primary);
    text-align: center;
    padding: 8px;
    background: rgba(233, 69, 96, 0.1);
    border-radius: 8px;
}

.player-info {
    font-size: 0.8rem;
    font-weight: 900;
    text-align: center;
    word-break: break-all;
}

/* RESPONSIVE */
@media (max-width: 768px) {
    .toolbar-left {
        width: 60px;
        padding: 5px;
    }
    
    .toolbar-left .tool-btn {
        width: 40px;
        height: 40px;
        font-size: 1.1rem;
    }
    
    .info-bar-right {
        width: 70px;
        padding: 10px 5px;
    }
    
    .timer-display {
        font-size: 1.8rem;
    }
    
    .canvas-area-fullscreen canvas#mainCanvas {
        max-width: calc(100vw - 150px);
    }
    
    .reference-thumbnail-fullscreen {
        width: 100px;
        height: 100px;
        right: 80px;
    }
}
    </style>
</head>
<body>

<!-- LOADING -->
<div id="loading-screen" class="overlay">
    <div class="spinner-big"></div>
    <p>Caricamento partita...</p>
</div>

<!-- LOBBY (gestita solo da banner, background neutro) -->
<div id="lobby-screen" class="overlay hidden" style="justify-content: center; align-items: center;">
    <div style="text-align: center; padding: 40px;">
        <div style="font-size: 5rem; margin-bottom: 20px;">üé®</div>
        <h1 style="margin-bottom: 10px;">PICTIONARY</h1>
        <p style="opacity: 0.7; margin-bottom: 30px;">In attesa nella lobby...</p>
        
        <div id="lobby-players-display" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 30px;"></div>
        
        <div style="background: var(--panel); padding: 20px; border-radius: 15px; max-width: 300px; margin: 0 auto;">
            <div style="text-align: center; padding: 10px; background: rgba(78, 205, 196, 0.1); border-radius: 8px; margin-bottom: 15px;">
                <div style="font-size: 0.75rem; opacity: 0.7;">ROUND AUTOMATICI</div>
                <div style="font-size: 1.5rem; font-weight: 900; color: var(--success);">
                    <span id="auto-rounds-display">2</span> round
                </div>
            </div>
        </div>
    </div>
</div>

<!-- CANVAS FULLSCREEN -->
<div id="game-ui" class="hidden" style="position: fixed; inset: 0; display: flex; background: var(--bg);">
    
    <!-- TOOLBAR SINISTRA -->
    <div class="toolbar-left">
        <div class="tool-section">
            <div class="tool-label">üõ†Ô∏è Strumenti</div>
            <button class="tool-btn active" id="tool-pen" onclick="setTool('pen')" title="Pennello">‚úèÔ∏è</button>
            <button class="tool-btn" id="tool-eraser" onclick="setTool('eraser')" title="Gomma">üßπ</button>
            <button class="tool-btn" id="tool-bucket" onclick="setTool('bucket')" title="Riempi">ü™£</button>
            <button class="tool-btn" onclick="undo()" title="Annulla">‚Ü©Ô∏è</button>
            <button class="tool-btn" onclick="clearCanvas()" title="Pulisci tutto">üóëÔ∏è</button>
        </div>
        
        <div class="tool-section">
            <div class="tool-label">üìè Dimensione</div>
            <input type="range" id="brush-size-slider" min="2" max="50" value="8" 
                   oninput="setSize(this.value)" class="size-slider">
            <div class="size-preview" id="size-preview"></div>
        </div>
        
        <div class="tool-section">
            <div class="tool-label">üé® Colore</div>
            <input type="color" id="color-picker" value="#000000" 
                   oninput="setColorFromPicker(this.value)" class="color-wheel">
            <div class="quick-colors">
                <div class="qcolor" style="background:#000000" onclick="setColorFromPicker('#000000')"></div>
                <div class="qcolor" style="background:#ffffff" onclick="setColorFromPicker('#ffffff')"></div>
                <div class="qcolor" style="background:#ff0000" onclick="setColorFromPicker('#ff0000')"></div>
                <div class="qcolor" style="background:#00ff00" onclick="setColorFromPicker('#00ff00')"></div>
                <div class="qcolor" style="background:#0000ff" onclick="setColorFromPicker('#0000ff')"></div>
                <div class="qcolor" style="background:#ffff00" onclick="setColorFromPicker('#ffff00')"></div>
                <div class="qcolor" style="background:#ff00ff" onclick="setColorFromPicker('#ff00ff')"></div>
                <div class="qcolor" style="background:#00ffff" onclick="setColorFromPicker('#00ffff')"></div>
            </div>
        </div>
        
        <div class="tool-section" style="margin-top: auto;">
            <button class="btn btn-success" onclick="finishCurrentPhase()" style="width: 100%;">
                ‚úÖ FATTO
            </button>
        </div>
    </div>
    
    <!-- AREA CANVAS CENTRALE -->
    <div class="canvas-area-fullscreen">
        <!-- Badge tema -->
        <div class="canvas-badge-fullscreen" id="canvas-theme-badge">TEMA</div>
        
        <!-- Miniatura riferimento -->
        <div class="reference-thumbnail-fullscreen" id="reference-thumbnail" style="display: none;">
            <canvas id="reference-mini-canvas"></canvas>
            <div class="ref-label">üëÜ RIFERIMENTO (hover per ingrandire)</div>
        </div>
        
        <!-- Canvas principale -->
        <canvas id="mainCanvas"></canvas>
    </div>
    
    <!-- INFO BAR DESTRA -->
    <div class="info-bar-right">
        <div class="timer-box">
            <div class="timer-label">‚è±Ô∏è TEMPO</div>
            <div id="timer" class="timer-display">60</div>
        </div>
        <div class="round-info" id="ui-round-info">ROUND 1/2</div>
        <div class="player-info" id="ui-player">PLAYER</div>
    </div>
</div>

<!-- ATTESA -->
<div id="waiting-screen" class="overlay hidden">
    <div class="card">
        <div class="spinner" style="margin: 0 auto;"></div>
        <h2 id="waiting-title">ATTESA</h2>
        <p id="waiting-message" style="opacity: 0.7;">Aspettando gli altri giocatori...</p>
        <div id="waiting-progress" style="margin-top: 15px; font-size: 1.2rem; color: var(--success);">
            <span id="done-count">0</span>/<span id="total-players">0</span>
        </div>
    </div>
</div>

<!-- GALLERIA + VOTAZIONE -->
<div id="gallery-screen" class="overlay hidden" style="justify-content: flex-start; padding: 0;">
    <header style="width: 100%; position: sticky; top: 0;">
        <div class="header-left">
            <span style="font-size: 1.5rem;">üñºÔ∏è</span>
            <span style="font-weight: 900;">GALLERIA</span>
        </div>
        <div id="vote-status" style="font-size: 0.85rem; opacity: 0.8;"></div>
    </header>
    
    <div class="gallery-container" id="gallery-container"></div>
    
    <div style="position: sticky; bottom: 0; width: 100%; padding: 15px; 
                background: var(--panel); border-top: 2px solid var(--border);">
        <button class="btn btn-gold" style="width: 100%; padding: 18px;" 
                onclick="confirmVotes()" id="confirm-votes-btn">
            ‚úÖ CONFERMA VOTI
        </button>
    </div>
</div>

<!-- RISULTATI -->
<div id="results-screen" class="overlay hidden">
    <div class="results-container">
        <div style="text-align: center; margin-bottom: 30px;">
            <div style="font-size: 4rem;">üèÜ</div>
            <h1 style="margin: 10px 0;">RISULTATI</h1>
        </div>
        
        <div class="podium" id="podium"></div>
        
        <div class="full-ranking" id="full-ranking"></div>
        
        <div style="display: flex; gap: 15px; margin-top: 30px;">
            <button class="btn btn-primary" style="flex: 1;" onclick="playAgain()">
                üîÑ RIVINCITA
            </button>
            <button class="btn btn-secondary" style="flex: 1;" onclick="goHome()">
                üè† HOME
            </button>
        </div>
    </div>
</div>
<!-- GUESS IT - DISEGNATORE -->
<div id="guessit-drawer-screen" class="overlay hidden">
    <div style="position: fixed; inset: 0; display: flex; background: var(--bg);">
        <!-- Stessa toolbar del canvas normale -->
        <div class="toolbar-left">
            <!-- ... stessi controlli ... -->
        </div>
        
        <div class="canvas-area-fullscreen">
            <div class="canvas-badge-fullscreen" id="guessit-theme-badge">DISEGNA: ???</div>
            <canvas id="guessitCanvas"></canvas>
        </div>
        
        <div class="info-bar-right">
            <div class="timer-box">
                <div class="timer-label">‚è±Ô∏è TEMPO</div>
                <div id="guessit-timer" class="timer-display">60</div>
            </div>
            <div style="margin-top: 20px; font-size: 0.8rem; text-align: center;">
                <div style="opacity: 0.7;">INDOVINATI</div>
                <div id="guessit-score" style="font-size: 2rem; font-weight: 900; color: var(--success);">0</div>
            </div>
        </div>
    </div>
</div>

<!-- GUESS IT - INDOVINATORI -->
<div id="guessit-guesser-screen" class="overlay hidden">
    <div style="display: flex; flex-direction: column; height: 100%; padding: 20px;">
        <!-- Canvas in streaming -->
        <div style="flex: 1; display: flex; justify-content: center; align-items: center;">
            <canvas id="guessitViewCanvas" style="
                max-width: 100%;
                max-height: 60vh;
                background: white;
                border-radius: 12px;
                border: 3px solid var(--primary);
            "></canvas>
        </div>
        
        <!-- Input per indovinare -->
        <div style="padding: 20px; background: var(--panel); border-radius: 15px; margin-top: 20px;">
            <input type="text" id="guess-input" placeholder="Scrivi cosa pensi sia..." 
                   autocomplete="off" autocorrect="off" spellcheck="false"
                   style="font-size: 1.2rem; text-align: center;">
            <button class="btn btn-primary" onclick="submitGuess()" style="width: 100%; margin-top: 10px;">
                üéØ INDOVINA!
            </button>
        </div>
        
        <!-- Feed risposte -->
        <div id="guesses-feed" style="
            max-height: 150px; 
            overflow-y: auto; 
            margin-top: 15px;
            padding: 10px;
            background: var(--bg);
            border-radius: 10px;
        "></div>
    </div>
</div>
<div id="fixed-home-btn">
    <button onclick="tornaHome()">üè† HOME</button>
</div>

<script>
// ========================================
// FIREBASE CONFIG
// ========================================
const firebaseConfig = {
    apiKey: "AIzaSyCNo7o2Ft22JDEyJ97BspE3Kur5DNAPKQc",
    authDomain: "funatwork-cd237.firebaseapp.com",
    projectId: "funatwork-cd237",
    storageBucket: "funatwork-cd237.firebasestorage.app",
    messagingSenderId: "798226885203",
    appId: "1:798226885203:web:ce83f4d9e96b82266274a6"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// ========================================
// TEMI
// ========================================
const THEMES = [
    // ü§™ ASSURDIT√Ä PURE
    "Nonno che fa parkour", "Gatto con il monocolo", "Pizza che fa yoga",
    "Dinosauro in smart working", "Nonna rapper", "Cane che guida una Ferrari",
    "Pinguino in discoteca", "Broccolo bodybuilder", "Unicorno depresso",
    "Banana ninja", "Paperella gigante che attacca Tokyo", "Ges√π che fa surf",
    
    // üòÇ SITUAZIONI IMBARAZZANTI
    "Collega che ruba il pranzo dal frigo", "Riunione Zoom in mutande",
    "Caff√® che non funziona il luned√¨", "Excel che crasha prima di salvare",
    "Stampante posseduta dal demonio", "Mail mandata al capo per sbaglio",
    "Scorreggia silenziosa in ascensore", "Russare durante una call",
    
    // ü¶Ñ CREATURE IMPOSSIBILI
    "Drago che ha paura del fuoco", "Squalo vegano", "Zombie influencer",
    "Fantasma con gli occhiali", "Sirena con le gambe", "Centauro in monopattino",
    "Fenicottero punk", "Bradipo su Red Bull", "Polpo massaggiatore",
    
    // üé≠ PERSONAGGI ASSURDI
    "Batman al supermercato", "Shrek al primo appuntamento", "Thanos che fa giardinaggio",
    "Mario Bros in palestra", "Pikachu arrabbiato col capo", "Yoda che balla reggaeton",
    "Gollum che vince alla lotteria", "Darth Vader in vacanza",
    
    // üçï CIBO CHE FA COSE
    "Hamburger in terapia", "Sushi che fa karate", "Donut alla guida",
    "Pasta che corre la maratona", "Gelato al sole in panico", "Caff√® che medita",
    "Pollo arrosto che scappa", "Uovo che si allena per Pasqua",
    
    // üè¢ VITA DA UFFICIO ASSURDA
    "Meeting che poteva essere una mail", "Stapler posseduto",
    "Collega che scalda il pesce in microonde", "Capo trasformato in rospo",
    "Deadline che insegue", "Ferie cancellate personificate",
    "Bonus di fine anno (molto piccolo)", "Luned√¨ mattina",
    
    // üåç SCENE EPICHE
    "Mondiale di nascondino", "Gara di rutti spaziale", "Olimpiadi del divano",
    "Apocalisse dei post-it", "Invasione di piccioni giganti",
    "T-Rex che fa il DJ", "Vulcano di nutella", "Tornado di coriandoli",
    
    // üò± PAURE MODERNE
    "Notifica di lavoro alle 23", "Batteria al 1%", "WiFi che non va",
    "Aggiornamento Windows forzato", "Messaggio vocale di 5 minuti",
    "Suocera a sorpresa", "Dentista sadico", "Sveglia del luned√¨",
    
    // üé™ COMBO IMPOSSIBILI
    "Papa Francesco che skatea", "Regina Elisabetta al rave",
    "Einstein che fa TikTok", "Leonardo da Vinci su OnlyFans",
    "Napoleone che ordina da Glovo", "Cleopatra al centro commerciale",
    
    // üêæ ANIMALI IN SITUAZIONI UMANE
    "Gatto che paga le tasse", "Cane commercialista", "Piccione avvocato",
    "Mucca in palestra", "Gallina in smart working", "Pesce che guida Uber",
    "Ape influencer", "Lumaca corriere espresso", "Ragno architetto"
];

const COLORS = [
    '#000000', '#ffffff', '#808080', '#c0c0c0',
    '#ff0000', '#ff6b6b', '#ffa500', '#ffff00', 
    '#90ee90', '#00ff00', '#008000', '#00ffff',
    '#0000ff', '#4169e1', '#800080', '#ff00ff',
    '#ffc0cb', '#a52a2a', '#8b4513', '#f5deb3'
];

const LOGICAL_SIZE = 500;
const MIN_DIST = 4;

// ========================================
// STATO GLOBALE
// ========================================
let state = {
    roomId: null,
    playerName: null,
    isHost: false,
    roomData: null,
    myVotes: {},
    myCurrentTheme: null,
    receivedDrawing: null,
    isDrawing: false,
    myChainId: null,
    isAdvancing: false  // ‚úÖ Flag per evitare chiamate multiple
};

let canvas, ctx;
let isDrawing = false;
let currentTool = 'pen';
let currentColor = '#000000';
let currentSize = 8;
let history = [];
let timer = 60;
let timerInterval;
let unsubscribeRoom = null;

// ========================================
// UTILITY
// ========================================
function showScreen(id) {
    document.querySelectorAll('.overlay, .app-container').forEach(el => el.classList.add('hidden'));
    const target = document.getElementById(id);
    if (target) target.classList.remove('hidden');
}

function showBanner(options) {
    removeBanner();
    const banner = document.createElement('div');
    banner.id = 'game-banner';
    banner.className = 'game-banner';
    banner.style.background = `linear-gradient(135deg, ${options.color} 0%, ${adjustColor(options.color, -30)} 100%)`;
    
    let buttonsHtml = (options.buttons || []).map(btn => 
        `<button class="btn ${btn.class || 'btn-secondary'}" onclick="${btn.onclick}" 
                 style="padding: 10px 20px;">${btn.text}</button>`
    ).join('');
    
    let spinnerHtml = options.spinner ? '<div class="spinner"></div>' : '';
    let timerHtml = options.timer ? `<div class="banner-timer" id="banner-timer">${options.timer}s</div>` : '';
    
    banner.innerHTML = `
        <div class="banner-left">
            <span class="banner-icon">${options.icon}</span>
            <div>
                <div class="banner-title">${options.title}</div>
                <div class="banner-subtitle">${options.subtitle}</div>
            </div>
        </div>
        <div class="banner-right">${timerHtml}${buttonsHtml}${spinnerHtml}</div>
    `;
    
    document.body.appendChild(banner);
}

function removeBanner() {
    document.getElementById('game-banner')?.remove();
}

function adjustColor(hex, amount) {
    let c = hex.replace('#', '');
    if (c.length === 3) c = c[0]+c[0]+c[1]+c[1]+c[2]+c[2];
    const num = parseInt(c, 16);
    let r = Math.min(255, Math.max(0, (num >> 16) + amount));
    let g = Math.min(255, Math.max(0, ((num >> 8) & 0xFF) + amount));
    let b = Math.min(255, Math.max(0, (num & 0xFF) + amount));
    return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
}

function cyrb128(str) {
    let h = 1779033703;
    for (let i = 0; i < str.length; i++) h = Math.imul(h ^ str.charCodeAt(i), 597399067);
    return h >>> 0;
}

function sfc32(a) {
    return function() {
        a |= 0; a = a + 0x6D2B79F5 | 0;
        let t = Math.imul(a ^ a >>> 15, 1 | a);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}

function shuffleArray(arr, rng) {
    const copy = [...arr];
    for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy;
}

function fireConfetti() {
    const colors = ['#ff0000', '#ffff00', '#00ff00', '#00ffff', '#ff00ff', '#ffd700'];
    for (let i = 0; i < 100; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDuration = (2 + Math.random() * 2) + 's';
        confetti.style.animationDelay = Math.random() * 0.5 + 's';
        if (Math.random() > 0.5) confetti.style.borderRadius = '50%';
        document.body.appendChild(confetti);
        setTimeout(() => confetti.remove(), 5000);
    }
}

// ========================================
// LOBBY
// ========================================
function enterLobby() {
    removeBanner();
    showScreen('lobby-screen');
    showHomeButton();
    
    if (unsubscribeRoom) unsubscribeRoom();
    unsubscribeRoom = db.collection("pictionary_rooms").doc(state.roomId).onSnapshot(handleRoomUpdate);
}

function handleRoomUpdate(doc) {
    if (!doc.exists) {
        alert("Stanza chiusa!");
        location.reload();
        return;
    }
    
    const data = doc.data();
    const prevStato = state.roomData?.stato;
    const prevPhase = state.roomData?.currentPhase;
    
    state.roomData = data;
    state.isHost = data.host === state.playerName;
    
    // ‚úÖ SE STO DISEGNANDO, IGNORA COMPLETAMENTE
    if (state.isDrawing) {
        console.log("üìù Sto disegnando, ignoro update");
        return;
    }
    
    console.log(`üîÑ Update: stato=${data.stato}, fase=${data.currentPhase}, prev=${prevStato}/${prevPhase}`);
    
    // ‚úÖ GESTISCI IN BASE ALLO STATO CORRENTE
switch(data.stato) {
    case 'lobby': 
        renderLobby(data); 
        break;
    case 'drawing': 
        handleDrawingPhase(data); 
        break;
    case 'guessit':  // ‚úÖ NUOVO
        handleGuessItPhase(data);
        break;
    case 'voting': 
        handleVotingPhase(data); 
        break;
    case 'results': 
        handleResultsPhase(data); 
        break;
}
}

function renderLobby(data) {
    showScreen('lobby-screen');
    showHomeButton();
    
    // ‚úÖ Aggiorna display giocatori
    const playersDisplay = document.getElementById('lobby-players-display');
    if (playersDisplay) {
        playersDisplay.innerHTML = data.players.map(p => `
            <div style="
                background: ${data.ready.includes(p) ? 'var(--success)' : 'var(--accent)'};
                color: white;
                padding: 10px 20px;
                border-radius: 25px;
                font-weight: bold;
                display: flex;
                align-items: center;
                gap: 8px;
            ">
                ${p === data.host ? 'üëë' : ''}
                ${p}
                ${data.ready.includes(p) ? '‚úÖ' : '‚è≥'}
            </div>
        `).join('');
    }
    
    // ‚úÖ Aggiorna rounds display
    const autoRoundsDisplay = document.getElementById('auto-rounds-display');
    if (autoRoundsDisplay) {
        autoRoundsDisplay.textContent = data.players.length;
    }
    
    // ‚úÖ Costruisci bottoni per il banner
    const buttons = [];
    
    if (data.ready.includes(state.playerName)) {
        buttons.push({
            text: '‚è∏Ô∏è ANNULLA',
            onclick: 'toggleReady()',
            class: 'btn-secondary'
        });
    } else {
        buttons.push({
            text: 'üöÄ SONO PRONTO!',
            onclick: 'toggleReady()',
            class: 'btn-primary'
        });
    }
    
    // ‚úÖ Selettore tempo (solo host)
    let timeSelector = '';
    if (state.isHost && !data.sfidaDiretta) {
        const currentTime = data.settings?.timePerRound || 60;
        timeSelector = `
            <select onchange="updateSettings()" id="banner-time-select" style="
                padding: 8px 12px;
                border-radius: 8px;
                border: none;
                font-weight: bold;
                cursor: pointer;
            ">
                <option value="30" ${currentTime == 30 ? 'selected' : ''}>30s</option>
                <option value="45" ${currentTime == 45 ? 'selected' : ''}>45s</option>
                <option value="60" ${currentTime == 60 ? 'selected' : ''}>60s</option>
                <option value="90" ${currentTime == 90 ? 'selected' : ''}>90s</option>
            </select>
        `;
    }
    
    buttons.push({
        text: 'üö™ ESCI',
        onclick: 'leaveRoom()',
        class: 'btn-danger'
    });
    
    // ‚úÖ Banner stile Ruzzle
    removeBanner();
    const banner = document.createElement('div');
    banner.id = 'game-banner';
    banner.className = 'game-banner';
    banner.style.background = 'linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%)';
    
    banner.innerHTML = `
        <div class="banner-left">
            <span class="banner-icon">üé®</span>
            <div>
                <div class="banner-title">PICTIONARY - LOBBY</div>
                <div class="banner-subtitle">${data.ready.length}/${data.players.length} pronti ‚Ä¢ ${data.players.length} round</div>
            </div>
        </div>
        <div class="banner-right">
            ${timeSelector}
            ${buttons.map(btn => `
                <button class="btn ${btn.class}" onclick="${btn.onclick}" style="padding: 10px 20px;">
                    ${btn.text}
                </button>
            `).join('')}
        </div>
    `;
    
    document.body.appendChild(banner);
    
    // ‚úÖ Avvio automatico quando tutti pronti
    if (data.ready.length >= data.players.length && data.players.length >= 2 && state.isHost) {
        startGame();
    }
}

async function updateSettings() {
    const timeSelect = document.getElementById('banner-time-select') || document.getElementById('lobby-time-select');
    if (timeSelect) {
        await db.collection("pictionary_rooms").doc(state.roomId).update({
            'settings.timePerRound': parseInt(timeSelect.value)
        });
    }
}

async function toggleReady() {
    const field = state.isReady ? 
        firebase.firestore.FieldValue.arrayRemove(state.playerName) :
        firebase.firestore.FieldValue.arrayUnion(state.playerName);
    
    await db.collection("pictionary_rooms").doc(state.roomId).update({ ready: field });
}

async function leaveRoom() {
    if (!confirm("Sicuro di voler uscire?")) return;
    
    if (state.isHost) {
        await db.collection("pictionary_rooms").doc(state.roomId).delete();
    } else {
        await db.collection("pictionary_rooms").doc(state.roomId).update({
            players: firebase.firestore.FieldValue.arrayRemove(state.playerName),
            ready: firebase.firestore.FieldValue.arrayRemove(state.playerName)
        });
    }
    
    location.reload();
}

// ========================================
// AVVIO GIOCO
// ========================================
async function startGame() {
    if (!state.isHost) return;
    
    const data = state.roomData;
    const players = data.players;
    const numPlayers = players.length;
    const gameMode = data.settings?.mode || 'classic';
    
    if (gameMode === 'guessit') {
        // ‚úÖ MODALIT√Ä GUESS IT
        const firstDrawer = players[0];
        const firstWord = THEMES[Math.floor(Math.random() * THEMES.length)];
        
        await db.collection("pictionary_rooms").doc(state.roomId).update({
            stato: 'guessit',
            guessIt: {
                round: 0,
                currentDrawer: firstDrawer,
                currentWord: firstWord,
                canvasData: null,
                guesses: {},
                scores: {}
            }
        });
        return;
    }
    
    // ‚úÖ MODALIT√Ä CLASSICA (codice esistente)
    const totalRounds = numPlayers;
    
    const seed = cyrb128(state.roomId + Date.now());
    const rng = sfc32(seed);
    const shuffledThemes = shuffleArray(THEMES, rng);
    
    // ‚úÖ Crea una catena per ogni tema (= numero giocatori)
    const chains = {};
    for (let i = 0; i < numPlayers; i++) {
        chains[i] = {
            themeIndex: i,
            originalTheme: shuffledThemes[i % shuffledThemes.length],
            steps: [],
            drawnBy: [] // Chi ha gi√† disegnato questo tema
        };
    }
    
    const scores = {};
    players.forEach(p => scores[p] = 0);
    
    await db.collection("pictionary_rooms").doc(state.roomId).update({
        stato: 'drawing',
        currentRound: 0,
        totalRounds: totalRounds,
        chains: chains,
        scores: scores,
        votes: {},
        completedRound: {},
        playerOrder: players // Ordine fisso per la rotazione
    });
}

// ========================================
// ‚úÖ FASE DISEGNO - CORRETTA
// ========================================
function handleDrawingPhase(data) {
    const currentRound = data.currentRound;
    const completed = data.completedRound?.[currentRound] || [];
    
    console.log(`üìù handleDrawingPhase: round=${currentRound}, completed=${completed.join(',')}`);
    
    // ‚úÖ Se ho gi√† completato questo round, mostra waiting
    if (completed.includes(state.playerName)) {
        showWaitingScreen(data);
        return;
    }
    
    // ‚úÖ CALCOLA QUALE TEMA DEVO DISEGNARE
    const players = data.playerOrder || data.players;
    const numPlayers = players.length;
    const myIdx = players.indexOf(state.playerName);
    
    // Round k ‚Üí Giocatore i disegna tema (i + k) % N
    const myChainId = (myIdx + currentRound) % numPlayers;
    const chain = data.chains[myChainId];
    
    let myTheme, referenceDrawing = null;
    
    if (currentRound === 0) {
        // ‚úÖ Round 0: Disegno il tema originale
        myTheme = chain.originalTheme;
    } else {
        // ‚úÖ Round 1+: Ridisegno guardando l'ultimo disegno della catena
        myTheme = "RIDISEGNALO!";
        const lastStep = chain.steps[chain.steps.length - 1];
        if (lastStep && lastStep.drawing) {
            referenceDrawing = lastStep.drawing;
        }
    }
    
    state.myCurrentTheme = currentRound === 0 ? chain.originalTheme : myTheme;
    state.originalTheme = chain.originalTheme; // Salva per riferimento
    state.receivedDrawing = referenceDrawing;
    state.myChainId = myChainId;
    
    console.log(`üéØ Round ${currentRound}: Disegno chain ${myChainId} ("${chain.originalTheme}"), hasRef=${!!referenceDrawing}`);
    
    launchCanvas(data);
}

function launchCanvas(data) {
    state.isDrawing = true;
    showScreen('game-ui');
    showHomeButton();
    
    canvas = document.getElementById('mainCanvas');
    ctx = canvas.getContext('2d', { willReadFrequently: true });
    setupCanvas(canvas);
    
    // ‚úÖ Mostra miniatura se presente riferimento
    const refThumbnail = document.getElementById('reference-thumbnail');
    const themeBadge = document.getElementById('canvas-theme-badge');
    
if (state.receivedDrawing) {
    refThumbnail.style.display = 'block';
    
    const miniCanvas = document.getElementById('reference-mini-canvas');
    miniCanvas.width = LOGICAL_SIZE;
    miniCanvas.height = LOGICAL_SIZE;
    const miniCtx = miniCanvas.getContext('2d');
    miniCtx.fillStyle = '#ffffff';
    miniCtx.fillRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
    
    const actions = decompressDrawing(state.receivedDrawing);
    actions.forEach(act => applyAction(act, miniCtx));
    
    themeBadge.textContent = "üé® COPIA QUESTO!";
    themeBadge.style.background = 'linear-gradient(135deg, #4ecdc4 0%, #26d0ce 100%)';
} else {
    if (refThumbnail) refThumbnail.style.display = 'none';
    themeBadge.textContent = state.myCurrentTheme;
    themeBadge.style.background = 'linear-gradient(135deg, #e94560 0%, #ff6b9d 100%)';
}
    
document.getElementById('ui-round-info').textContent = 
    `ROUND ${data.currentRound + 1}/${data.totalRounds}`;
    document.getElementById('ui-player').textContent = state.playerName;
    
    renderPalette();
    setTool('pen');
    setSize(8);
    history = [];
    
    timer = data.settings.timePerRound;
    document.getElementById('timer').textContent = timer;
    document.getElementById('timer').classList.remove('warning');
    
    startTimerWithBanner();
    attachCanvasListeners();
}

// ‚úÖ TIMER CON BANNER - CORRETTO
function startTimerWithBanner() {
    clearInterval(timerInterval);
    
    const data = state.roomData;
    const isRedraw = !!state.receivedDrawing;
    const fase = isRedraw ? 'RIDISEGNA' : 'DISEGNA';
    const tema = state.myCurrentTheme;
    const roundInfo = `Round ${data.currentRound + 1}/${data.totalRounds}`;
    
    // ‚úÖ BANNER CON TIMER VISIBILE
    showBanner({
        icon: isRedraw ? 'üé®' : '‚úèÔ∏è',
        title: `${fase}: ${tema}`,
        subtitle: roundInfo,
        color: isRedraw ? '#4ecdc4' : '#e94560',
        timer: timer
    });
    
    const timerEl = document.getElementById('timer');
    
    timerInterval = setInterval(() => {
        timer--;
        
        // Aggiorna header canvas
        if (timerEl) {
            timerEl.textContent = timer;
            if (timer <= 10) timerEl.classList.add('warning');
        }
        
        // ‚úÖ Aggiorna timer nel banner
        const bannerTimer = document.getElementById('banner-timer');
        if (bannerTimer) {
            bannerTimer.textContent = `${timer}s`;
            if (timer <= 10) {
                bannerTimer.classList.add('warning');
            }
        }
        
        if (timer <= 0) {
            clearInterval(timerInterval);
            finishCurrentPhase();
        }
    }, 1000);
}

// ‚úÖ FINISH PHASE - CORRETTO
async function finishCurrentPhase() {
    if (state.isAdvancing) return;
    
    clearInterval(timerInterval);
    removeBanner();
    state.isDrawing = false;
    
    const data = state.roomData;
    const currentRound = data.currentRound;
    const myChainId = state.myChainId;
    
    console.log(`‚úÖ finishCurrentPhase: round=${currentRound}, chain=${myChainId}`);
    
    const drawingData = compressDrawing(history);
    
    const step = {
        player: state.playerName,
        round: currentRound,
        drawing: drawingData
    };
    
    const chainPath = `chains.${myChainId}.steps`;
    const drawnByPath = `chains.${myChainId}.drawnBy`;
    const completedPath = `completedRound.${currentRound}`;
    
    await db.collection("pictionary_rooms").doc(state.roomId).update({
        [chainPath]: firebase.firestore.FieldValue.arrayUnion(step),
        [drawnByPath]: firebase.firestore.FieldValue.arrayUnion(state.playerName),
        [completedPath]: firebase.firestore.FieldValue.arrayUnion(state.playerName)
    });
    
    state.receivedDrawing = null;
    
    // Leggi dati freschi
    const freshDoc = await db.collection("pictionary_rooms").doc(state.roomId).get();
    const freshData = freshDoc.data();
    state.roomData = freshData;
    
    const completed = freshData.completedRound?.[currentRound] || [];
    const total = freshData.players.length;
    
    console.log(`üìä Completati: ${completed.length}/${total}, isHost=${state.isHost}`);
    
    if (completed.length >= total && state.isHost) {
        await advanceToNextRound(freshData);
    } else {
        showWaitingScreen(freshData);
    }
}

// ‚úÖ AVANZAMENTO FASE - CORRETTO
async function advanceToNextRound(data) {
    if (state.isAdvancing) {
        console.log("‚ö†Ô∏è Gi√† in avanzamento, skip");
        return;
    }
    
    state.isAdvancing = true;
    
    const currentRound = data.currentRound;
    const totalRounds = data.totalRounds;
    const nextRound = currentRound + 1;
    
    console.log(`üöÄ advanceToNextRound: ${currentRound} ‚Üí ${nextRound} (totale: ${totalRounds})`);
    
    try {
        if (nextRound >= totalRounds) {
            // ‚úÖ Tutti i round completati ‚Üí Votazione
            console.log("üó≥Ô∏è Passaggio a VOTAZIONE");
            await db.collection("pictionary_rooms").doc(state.roomId).update({
                stato: 'voting'
            });
        } else {
            // ‚úÖ Prossimo round
            console.log(`‚û°Ô∏è Passaggio a round ${nextRound}`);
            await db.collection("pictionary_rooms").doc(state.roomId).update({
                currentRound: nextRound,
                stato: 'drawing'
            });
        }
    } catch (e) {
        console.error("‚ùå Errore avanzamento round:", e);
    } finally {
        setTimeout(() => { state.isAdvancing = false; }, 2000);
    }
}

// ========================================
// ‚úÖ WAITING SCREEN - CORRETTO
// ========================================
function showWaitingScreen(data) {
    clearInterval(timerInterval);
    showScreen('waiting-screen');
    showHomeButton();
    
    const currentRound = data.currentRound;
    const completed = data.completedRound?.[currentRound] || [];
    const total = data.players.length;
    
    const remaining = data.players.filter(p => !completed.includes(p));
    
    document.getElementById('waiting-title').textContent = `‚úèÔ∏è ROUND ${currentRound + 1}/${data.totalRounds} COMPLETATO!`;
    document.getElementById('waiting-message').textContent = 
        remaining.length > 0 
            ? `In attesa di: ${remaining.join(', ')}`
            : 'Tutti hanno finito! Passaggio...';
    document.getElementById('done-count').textContent = completed.length;
    document.getElementById('total-players').textContent = total;
    
    showBanner({
        icon: '‚è≥',
        title: `ATTESA (${completed.length}/${total})`,
        subtitle: remaining.length > 0 ? `Manca: ${remaining.join(', ')}` : 'Passaggio in corso...',
        color: '#9b59b6',
        spinner: true
    });
    
    // ‚úÖ SE TUTTI HANNO FINITO E SONO HOST, AVANZA
    if (completed.length >= total && state.isHost && !state.isAdvancing) {
        console.log("‚úÖ Tutti finito in waiting, host avanza");
        advanceToNextRound(data);
    }
}

// ========================================
// VOTAZIONE
// ========================================
function handleVotingPhase(data) {
    removeBanner();
    showScreen('gallery-screen');
    showHomeButton();
    renderGallery(data);
    
    const votedCount = Object.keys(state.myVotes).length;
    const totalChains = Object.keys(data.chains).length;
    
    // ‚úÖ Controlla se ho gi√† votato (i miei voti sono su Firebase)
    const myVotesOnFirebase = data.votes?.[state.playerName];
    const confirmBtn = document.getElementById('confirm-votes-btn');
    
    if (myVotesOnFirebase && Object.keys(myVotesOnFirebase).length > 0) {
        // ‚úÖ Ho gi√† confermato i voti
        if (confirmBtn) {
            confirmBtn.disabled = true;
            confirmBtn.innerHTML = '‚úÖ VOTI INVIATI';
            confirmBtn.style.opacity = '0.6';
            confirmBtn.style.cursor = 'not-allowed';
            confirmBtn.style.background = 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)';
        }
        
        const votedPlayers = Object.keys(data.votes).length;
        const totalPlayers = data.players.length;
        
        showBanner({
            icon: '‚è≥',
            title: `ATTESA VOTI (${votedPlayers}/${totalPlayers})`,
            subtitle: 'Hai gi√† votato. Attendi gli altri...',
            color: '#27ae60',
            spinner: true
        });
        
        // ‚úÖ Host controlla se tutti hanno votato
        if (state.isHost && votedPlayers >= totalPlayers) {
            checkAndCalculateResults();
        }
    } else {
        // ‚úÖ Non ho ancora votato
        if (confirmBtn) {
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = '‚úÖ CONFERMA VOTI';
            confirmBtn.style.opacity = '1';
            confirmBtn.style.cursor = 'pointer';
            confirmBtn.style.background = 'linear-gradient(135deg, #ffd700 0%, #ffaa00 100%)';
        }
        
        showBanner({
            icon: 'üó≥Ô∏è',
            title: 'VOTAZIONE IN CORSO',
            subtitle: `Vota il disegno pi√π bello di ogni catena (${votedCount}/${totalChains})`,
            color: '#f39c12'
        });
    }
}

function renderGallery(data) {
    const container = document.getElementById('gallery-container');
    container.innerHTML = '';
    
    const myVotes = state.myVotes;
    const isVotingPhase = data.stato === 'voting';
    
    Object.entries(data.chains).forEach(([chainId, chain]) => {
        const card = document.createElement('div');
        card.className = 'chain-card';
        
        // ‚úÖ Durante la votazione NON mostrare chi ha creato il tema originale
        const headerInfo = isVotingPhase 
            ? `<div style="font-size: 0.8rem; opacity: 0.7;">üéØ Tema originale nascosto</div>`
            : `<div style="font-size: 0.8rem; opacity: 0.7;">di ${chain.steps[0]?.player || '?'}</div>`;
        
// ‚úÖ Tema sempre visibile
const themeDisplay = `<span>Tema: "${chain.originalTheme}"</span>`;
        
        card.innerHTML = `
            <div class="chain-header">
                <div class="chain-title">
                    <span>üé®</span>
                    ${themeDisplay}
                </div>
                ${headerInfo}
            </div>
            <div class="chain-flow" id="chain-flow-${chainId}"></div>
        `;
        
        const flowContainer = card.querySelector(`#chain-flow-${chainId}`);
        
        chain.steps.forEach((step, stepIdx) => {
            if (stepIdx > 0) {
                const arrow = document.createElement('div');
                arrow.className = 'chain-arrow';
                arrow.innerHTML = '‚û°Ô∏è';
                flowContainer.appendChild(arrow);
            }
            
            // ‚úÖ Controlla se questo disegno √® mio (non posso votarmi)
            const isMyDrawing = step.player === state.playerName;
            const isVoted = myVotes[chainId] === `${chainId}-${stepIdx}`;
            
            const stepCard = document.createElement('div');
            stepCard.className = `chain-step ${isVoted ? 'voted' : ''} ${isMyDrawing && isVotingPhase ? 'my-drawing' : ''}`;
            
            // ‚úÖ Durante votazione: nascondo nome, durante risultati: mostro nome
            const playerDisplay = isVotingPhase 
                ? `<div class="step-player" style="color: #888;">Disegno #${stepIdx + 1}</div>`
                : `<div class="step-player">${step.player}</div>`;
            
            // ‚úÖ Pulsante voto: disabilitato se √® il mio disegno
            let voteButton = '';
            if (isVotingPhase) {
                if (isMyDrawing) {
                    voteButton = `
                        <button class="vote-btn" disabled 
                                style="opacity: 0.4; cursor: not-allowed; background: #444;">
                            üö´ Tuo disegno
                        </button>`;
                } else {
                    voteButton = `
                        <button class="vote-btn ${isVoted ? 'voted' : ''}" 
                                onclick="voteFor('${chainId}', '${chainId}-${stepIdx}')">
                            ${isVoted ? '‚≠ê VOTATO' : 'üëç VOTA'}
                        </button>`;
                }
            }
            
            stepCard.innerHTML = `
                <div class="step-canvas"><canvas id="step-canvas-${chainId}-${stepIdx}"></canvas></div>
                <div class="step-info">
                    ${playerDisplay}
                    <div class="step-type" style="font-size: 0.65rem; opacity: 0.6;">
                        ${stepIdx === 0 ? 'üéØ Primo disegno' : `üîÑ Copia #${stepIdx}`}
                    </div>
                </div>
                ${voteButton}
            `;
            
            flowContainer.appendChild(stepCard);
            
            setTimeout(() => {
                const cvs = document.getElementById(`step-canvas-${chainId}-${stepIdx}`);
                if (cvs && step.drawing) {
                    cvs.width = LOGICAL_SIZE;
                    cvs.height = LOGICAL_SIZE;
                    const ctxCanvas = cvs.getContext('2d');
                    ctxCanvas.fillStyle = '#ffffff';
                    ctxCanvas.fillRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
                    const actions = decompressDrawing(step.drawing);
                    actions.forEach(act => applyAction(act, ctxCanvas));
                }
            }, 50);
        });
        
        container.appendChild(card);
    });
    
    // ‚úÖ Conta solo i voti validi (non i propri disegni)
    const validVotesCount = Object.keys(myVotes).length;
    const totalChains = Object.keys(data.chains).length;
    document.getElementById('vote-status').textContent = 
        `Voti: ${validVotesCount}/${totalChains}`;
}

function voteFor(chainId, uniqueVoteId) {
    // ‚úÖ Estrai stepIdx dal uniqueVoteId
    const stepIdx = parseInt(uniqueVoteId.split('-')[1]);
    const chain = state.roomData.chains[chainId];
    const step = chain.steps[stepIdx];
    
    // ‚úÖ Doppio controllo: non posso votare me stesso
    if (step.player === state.playerName) {
        alert("Non puoi votare il tuo disegno!");
        return;
    }
    
    // ‚úÖ Toggle voto (clicca di nuovo per deselezionare)
    if (state.myVotes[chainId] === uniqueVoteId) {
        delete state.myVotes[chainId];
    } else {
        state.myVotes[chainId] = uniqueVoteId;
    }
    
    renderGallery(state.roomData);
    
    const votedCount = Object.keys(state.myVotes).length;
    const totalChains = Object.keys(state.roomData.chains).length;
    
    showBanner({
        icon: 'üó≥Ô∏è',
        title: 'VOTAZIONE IN CORSO',
        subtitle: `Vota il disegno pi√π bello di ogni catena (${votedCount}/${totalChains})`,
        color: '#f39c12'
    });
}
async function confirmVotes() {
    const data = state.roomData;
    const totalChains = Object.keys(data.chains).length;
    
    if (Object.keys(state.myVotes).length < totalChains) {
        return alert(`Devi votare in tutte le ${totalChains} catene!`);
    }
    
    // ‚úÖ Disabilita subito il pulsante per evitare doppi click
    const confirmBtn = document.getElementById('confirm-votes-btn');
    if (confirmBtn) {
        confirmBtn.disabled = true;
        confirmBtn.innerHTML = '‚è≥ INVIO VOTI...';
        confirmBtn.style.opacity = '0.6';
        confirmBtn.style.cursor = 'not-allowed';
    }
    
    // ‚úÖ Converti voti in formato {chainId: playerName}
    const votesForFirebase = {};
    Object.entries(state.myVotes).forEach(([chainId, uniqueVoteId]) => {
        const stepIdx = parseInt(uniqueVoteId.split('-')[1]);
        const chain = data.chains[chainId];
        const votedPlayer = chain.steps[stepIdx].player;
        votesForFirebase[chainId] = votedPlayer;
    });
    
    try {
        await db.collection("pictionary_rooms").doc(state.roomId).update({
            [`votes.${state.playerName}`]: votesForFirebase
        });
        
        // ‚úÖ Aggiorna pulsante a stato "confermato"
        if (confirmBtn) {
            confirmBtn.innerHTML = '‚úÖ VOTI INVIATI';
            confirmBtn.style.background = 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)';
        }
        
        showBanner({
            icon: '‚è≥',
            title: 'VOTI CONFERMATI',
            subtitle: 'Attendi gli altri giocatori...',
            color: '#27ae60',
            spinner: true
        });
        
        // ‚úÖ Host controlla e calcola risultati
        if (state.isHost) {
            await checkAndCalculateResults();
        }
        
    } catch (e) {
        console.error("Errore invio voti:", e);
        // Riabilita in caso di errore
        if (confirmBtn) {
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = '‚úÖ CONFERMA VOTI';
            confirmBtn.style.opacity = '1';
            confirmBtn.style.cursor = 'pointer';
        }
        alert("Errore nell'invio dei voti. Riprova.");
    }
}

// ‚úÖ Funzione separata per calcolare risultati (chiamata anche dal listener)
async function checkAndCalculateResults() {
    const doc = await db.collection("pictionary_rooms").doc(state.roomId).get();
    const newData = doc.data();
    
    if (Object.keys(newData.votes).length >= newData.players.length) {
        const scores = {};
        newData.players.forEach(p => scores[p] = 0);
        
        Object.values(newData.votes).forEach(playerVotes => {
            Object.values(playerVotes).forEach(votedPlayer => {
                if (scores[votedPlayer] !== undefined) {
                    scores[votedPlayer]++;
                }
            });
        });
        
        await db.collection("pictionary_rooms").doc(state.roomId).update({
            scores: scores,
            stato: 'results'
        });
    }
}

// ========================================
// RISULTATI
// ========================================
function handleResultsPhase(data) {
    removeBanner();
    showScreen('results-screen');
    showHomeButton();
    fireConfetti();
    
    const sorted = Object.entries(data.scores).sort((a, b) => b[1] - a[1]);
    
    const podium = document.getElementById('podium');
    podium.innerHTML = '';
    
const podiumOrder = [1, 0, 2];
podiumOrder.forEach((idx) => {
    if (sorted[idx]) {
        const [player, score] = sorted[idx];
        const place = idx + 1;
        
        const div = document.createElement('div');
        div.className = `podium-place place-${place}`;
        div.style.animationDelay = `${idx * 0.2}s`;
        div.innerHTML = `
            <div class="podium-avatar">${place}¬∞</div>
            <div class="podium-bar">
                <div class="podium-score">${score}</div>
            </div>
            <div class="podium-name">${player}</div>
        `;
        podium.appendChild(div);
    }
});
    
    const ranking = document.getElementById('full-ranking');
    ranking.innerHTML = '<h3 style="margin-top: 0;">Classifica Completa</h3>';
    
    sorted.forEach(([player, score], idx) => {
        const row = document.createElement('div');
        row.className = `ranking-row ${player === state.playerName ? 'me' : ''}`;
        row.innerHTML = `
            <span class="ranking-position">${idx + 1}¬∞</span>
            <span class="ranking-name">${player}</span>
            <span class="ranking-score">${score} voti</span>
        `;
        ranking.appendChild(row);
    });
    // ‚úÖ Mostra tema originale di ogni catena nei risultati
    let chainsInfo = '';
    Object.entries(data.chains).forEach(([chainId, chain]) => {
        const firstPlayer = chain.steps[0]?.player || '?';
        chainsInfo += `\n‚Ä¢ "${chain.originalTheme}" (iniziato da ${firstPlayer})`;
    });    
    const isWinner = sorted[0]?.[0] === state.playerName;
    showBanner({
        icon: isWinner ? 'üëë' : 'üèÜ',
        title: isWinner ? 'HAI VINTO!' : 'PARTITA TERMINATA',
        subtitle: `Vincitore: ${sorted[0]?.[0] || '-'} con ${sorted[0]?.[1] || 0} voti`,
        color: isWinner ? '#ffd700' : '#27ae60'
    });
}

async function playAgain() {
    if (!state.isHost) {
        return alert("Solo l'host pu√≤ avviare una nuova partita!");
    }
    
    await db.collection("pictionary_rooms").doc(state.roomId).update({
        stato: 'lobby',
        currentRound: 0,
        totalRounds: 0,
        chains: {},
        votes: {},
        scores: {},
        completedRound: {},
        ready: [],
        playerOrder: []
    });
    
    state.myVotes = {};
    state.isAdvancing = false;
}

function goHome() {
    window.location.href = 'index.html';
}

// ========================================
// CANVAS FUNCTIONS
// ========================================
function setupCanvas(c) {
    c.width = LOGICAL_SIZE;
    c.height = LOGICAL_SIZE;
    const cx = c.getContext('2d');
    cx.lineCap = 'round';
    cx.lineJoin = 'round';
    cx.fillStyle = '#ffffff';
    cx.fillRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
}

function getPos(e, c) {
    const rect = c.getBoundingClientRect();
    const clientX = e.clientX ?? e.touches?.[0]?.clientX ?? 0;
    const clientY = e.clientY ?? e.touches?.[0]?.clientY ?? 0;
    
    // ‚úÖ Calcolo preciso considerando la scala del canvas
    const scaleX = c.width / rect.width;
    const scaleY = c.height / rect.height;
    
    const x = Math.round((clientX - rect.left) * scaleX);
    const y = Math.round((clientY - rect.top) * scaleY);
    
    // ‚úÖ Clamp ai bordi
    return {
        x: Math.max(0, Math.min(c.width - 1, x)),
        y: Math.max(0, Math.min(c.height - 1, y))
    };
}

function attachCanvasListeners() {
    const start = (e) => {
        e.preventDefault();
        const pos = getPos(e, canvas);
        
        if (currentTool === 'bucket') {
            const act = { type: 'fill', color: currentColor, x: pos.x, y: pos.y };
            history.push(act);
            applyAction(act, ctx);
        } else {
            isDrawing = true;
            const color = currentTool === 'eraser' ? '#ffffff' : currentColor;
            const act = { type: 'stroke', color: color, size: currentSize, points: [pos] };
            history.push(act);
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.arc(pos.x, pos.y, currentSize / 2, 0, Math.PI * 2);
            ctx.fill();
        }
    };
    
    const move = (e) => {
        if (!isDrawing) return;
        e.preventDefault();
        const pos = getPos(e, canvas);
        const stroke = history[history.length - 1];
        const last = stroke.points[stroke.points.length - 1];
        
        if (Math.hypot(pos.x - last.x, pos.y - last.y) > MIN_DIST) {
            stroke.points.push(pos);
            ctx.beginPath();
            ctx.strokeStyle = stroke.color;
            ctx.lineWidth = stroke.size;
            ctx.lineCap = 'round';
            ctx.moveTo(last.x, last.y);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        }
    };
    
    const end = () => { isDrawing = false; };
    
    canvas.onmousedown = start;
    canvas.onmousemove = move;
    window.onmouseup = end;
    canvas.ontouchstart = start;
    canvas.ontouchmove = move;
    window.ontouchend = end;
}

function applyAction(act, cx) {
    if (act.type === 'stroke') {
        if (act.points.length === 1) {
            cx.beginPath();
            cx.fillStyle = act.color;
            cx.arc(act.points[0].x, act.points[0].y, act.size / 2, 0, Math.PI * 2);
            cx.fill();
            return;
        }
        cx.beginPath();
        cx.strokeStyle = act.color;
        cx.lineWidth = act.size;
        cx.lineCap = 'round';
        cx.lineJoin = 'round';
        cx.moveTo(act.points[0].x, act.points[0].y);
        for (let i = 1; i < act.points.length; i++) {
            cx.lineTo(act.points[i].x, act.points[i].y);
        }
        cx.stroke();
    } else if (act.type === 'fill') {
        floodFill(act.x, act.y, act.color, cx);
    }
}

function undo() {
    history.pop();
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
    history.forEach(a => applyAction(a, ctx));
}

function clearCanvas() {
    if (confirm("Pulisci tutto?")) {
        history = [];
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
    }
}

function floodFill(startX, startY, fillColor, context) {
    const canvas = context.canvas;
    const width = canvas.width;
    const height = canvas.height;
    
    // Clamp coordinate
    startX = Math.max(0, Math.min(width - 1, Math.floor(startX)));
    startY = Math.max(0, Math.min(height - 1, Math.floor(startY)));
    
    const imageData = context.getImageData(0, 0, width, height);
    const data = imageData.data;
    
    const targetColor = getPixelColor(data, startX, startY, width);
    const fillRgb = hexToRgb(fillColor);
    
    // Non riempire se stesso
    if (colorsMatch(targetColor, fillRgb, 5)) return;
    
    const pixelsToCheck = [[startX, startY]];
    const visited = new Uint8Array(width * height);
    const tolerance = 30;
    
    let iterations = 0;
    const maxIterations = width * height;
    
    while (pixelsToCheck.length > 0 && iterations < maxIterations) {
        iterations++;
        const [x, y] = pixelsToCheck.pop();
        
        if (x < 0 || x >= width || y < 0 || y >= height) continue;
        
        const idx = y * width + x;
        if (visited[idx]) continue;
        visited[idx] = 1;
        
        const currentColor = getPixelColor(data, x, y, width);
        if (!colorsMatch(currentColor, targetColor, tolerance)) continue;
        
        // Riempi pixel
        const pixelIdx = idx * 4;
        data[pixelIdx] = fillRgb[0];
        data[pixelIdx + 1] = fillRgb[1];
        data[pixelIdx + 2] = fillRgb[2];
        data[pixelIdx + 3] = 255;
        
        // Aggiungi vicini
        pixelsToCheck.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
    }
    
    context.putImageData(imageData, 0, 0);
}

function getPixelColor(data, x, y, width) {
    const idx = (y * width + x) * 4;
    return [data[idx], data[idx + 1], data[idx + 2]];
}

function colorsMatch(c1, c2, tolerance = 15) {
    return Math.abs(c1[0] - c2[0]) <= tolerance &&
           Math.abs(c1[1] - c2[1]) <= tolerance &&
           Math.abs(c1[2] - c2[2]) <= tolerance;
}
function setColorFromPicker(color) {
    currentColor = color;
    document.getElementById('color-picker').value = color;
    updateSizePreview();
}

function updateSizePreview() {
    const preview = document.getElementById('size-preview');
    if (preview) {
        const size = Math.min(currentSize, 30);
        preview.style.width = `${size + 10}px`;
        preview.style.height = `${size + 10}px`;
        preview.style.background = currentColor;
        preview.textContent = currentSize;
    }
}

// Aggiorna setSize per includere preview
const originalSetSize = setSize;
function setSize(s) {
    currentSize = parseInt(s);
    document.querySelectorAll('[id^="size-"]').forEach(btn => btn.classList.remove('active'));
    document.getElementById(`size-${s}`)?.classList.add('active');
    updateSizePreview();
}

function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
    ] : [0, 0, 0];
}

function getPixel(d, x, y) {
    const i = (y * LOGICAL_SIZE + x) * 4;
    return [d.data[i], d.data[i+1], d.data[i+2]];
}

function setPixel(d, x, y, c) {
    const i = (y * LOGICAL_SIZE + x) * 4;
    d.data[i] = c[0]; d.data[i+1] = c[1]; d.data[i+2] = c[2]; d.data[i+3] = 255;
}

function colorsMatch(a, b) {
    return Math.abs(a[0]-b[0]) < 15 && Math.abs(a[1]-b[1]) < 15 && Math.abs(a[2]-b[2]) < 15;
}

function hexToRgb(h) {
    const n = parseInt(h.slice(1), 16);
    return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
}

function setTool(t) {
    currentTool = t;
    document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
    document.getElementById(`tool-${t}`)?.classList.add('active');
}

function setSize(s) {
    currentSize = s;
    document.querySelectorAll('[id^="size-"]').forEach(btn => btn.classList.remove('active'));
    document.getElementById(`size-${s}`)?.classList.add('active');
}

function renderPalette() {
    updateSizePreview();
}

// ========================================
// COMPRESSIONE
// ========================================
function compressDrawing(historyData) {
    return historyData.map(op => {
        const cIdx = COLORS.indexOf(op.color);
        const colorCode = cIdx >= 0 ? cIdx.toString(36) : op.color;
        
        if (op.type === 'stroke') {
            let prevX = 0, prevY = 0;
            const pts = op.points.map(p => {
                const dx = p.x - prevX, dy = p.y - prevY;
                prevX = p.x; prevY = p.y;
                return `${dx.toString(36)}.${dy.toString(36)}`;
            }).join(',');
            return `S${colorCode}|${op.size.toString(36)}|${pts}`;
        } else {
            return `F${colorCode}|${op.x.toString(36)}.${op.y.toString(36)}`;
        }
    }).join('~');
}

function decompressDrawing(str) {
    if (!str) return [];
    return str.split('~').map(s => {
        const type = s.charAt(0);
        const parts = s.substring(1).split('|');
        
        const colorCode = parts[0];
        const color = colorCode.length <= 2 ? 
            COLORS[parseInt(colorCode, 36)] || '#000000' : colorCode;
        
        if (type === 'S') {
            const size = parseInt(parts[1], 36);
            const pts = []; let cx = 0, cy = 0;
            parts[2].split(',').forEach(pt => {
                const [dx, dy] = pt.split('.').map(v => parseInt(v, 36));
                cx += dx; cy += dy; pts.push({x: cx, y: cy});
            });
            return { type: 'stroke', color, size, points: pts };
        } else {
            const [x, y] = parts[1].split('.').map(v => parseInt(v, 36));
            return { type: 'fill', color, x, y };
        }
    });
}

// ========================================
// INIT
// ========================================
window.onload = async () => {
    const urlParams = new URLSearchParams(window.location.search);
    const roomCode = urlParams.get('room');
    const mioNome = localStorage.getItem('mioNome');
    
    if (!roomCode || !mioNome) {
        alert("Accedi dalla homepage per giocare!");
        window.location.href = 'index.html';
        return;
    }
    
    state.playerName = mioNome;
    state.roomId = roomCode;
    
    showScreen('loading-screen');
    
    try {
        const doc = await db.collection("pictionary_rooms").doc(roomCode).get();
        
        if (!doc.exists) {
            alert("Stanza non trovata!");
            window.location.href = 'index.html';
            return;
        }
        
        const data = doc.data();
        
        if (data.players.includes(mioNome)) {
            state.isHost = data.host === mioNome;
            enterLobby();
        } else if (data.stato === 'lobby') {
            await db.collection("pictionary_rooms").doc(roomCode).update({
                players: firebase.firestore.FieldValue.arrayUnion(mioNome)
            });
            state.isHost = false;
            enterLobby();
        } else {
            alert("La partita √® gi√† iniziata!");
            window.location.href = 'index.html';
        }
        
    } catch (e) {
        console.error("Errore auto-join:", e);
        alert("Errore di connessione!");
        window.location.href = 'index.html';
    }
};

// ========================================
// NAVIGAZIONE
// ========================================
function tornaHome() {
    if (unsubscribeRoom) {
        unsubscribeRoom();
        unsubscribeRoom = null;
    }
    
    if (timerInterval) {
        clearInterval(timerInterval);
    }
    
    window.location.href = 'index.html';
}

function showHomeButton() {
    const btn = document.getElementById('fixed-home-btn');
    if (btn) btn.style.display = 'block';
}

function hideHomeButton() {
    const btn = document.getElementById('fixed-home-btn');
    if (btn) btn.style.display = 'none';
}
    // ========================================
// MODALIT√Ä GUESS IT!
// ========================================

let guessItState = {
    isDrawer: false,
    currentWord: null,
    roundNumber: 0,
    totalRounds: 5,
    scores: {},
    streamInterval: null
};

function handleGuessItPhase(data) {
    const currentDrawer = data.guessIt?.currentDrawer;
    
    if (currentDrawer === state.playerName) {
        // Sono il disegnatore
        guessItState.isDrawer = true;
        guessItState.currentWord = data.guessIt.currentWord;
        showGuessItDrawer(data);
    } else {
        // Sono un indovinatore
        guessItState.isDrawer = false;
        showGuessItGuesser(data);
    }
}

function showGuessItDrawer(data) {
    showScreen('guessit-drawer-screen');
    showHomeButton();
    
    const canvas = document.getElementById('guessitCanvas');
    const ctx = canvas.getContext('2d');
    setupCanvas(canvas);
    
    document.getElementById('guessit-theme-badge').textContent = 
        `DISEGNA: ${guessItState.currentWord}`;
    
    // Avvia streaming del canvas
    startCanvasStreaming(canvas);
    
    // Timer
    startGuessItTimer(data.settings?.timePerRound || 60);
    
    showBanner({
        icon: '‚úèÔ∏è',
        title: `DISEGNA: ${guessItState.currentWord}`,
        subtitle: 'Gli altri devono indovinare!',
        color: '#e94560'
    });
}

function showGuessItGuesser(data) {
    showScreen('guessit-guesser-screen');
    showHomeButton();
    
    const drawer = data.guessIt?.currentDrawer;
    
    showBanner({
        icon: 'üîÆ',
        title: 'INDOVINA!',
        subtitle: `${drawer} sta disegnando...`,
        color: '#9b59b6'
    });
    
    // Ascolta streaming canvas
    listenToCanvasStream();
    
    // Focus sull'input
    document.getElementById('guess-input').focus();
    
    // Listener per Enter
    document.getElementById('guess-input').onkeypress = (e) => {
        if (e.key === 'Enter') submitGuess();
    };
}

function startCanvasStreaming(canvas) {
    // Invia lo stato del canvas ogni 500ms
    guessItState.streamInterval = setInterval(async () => {
        const dataUrl = canvas.toDataURL('image/png', 0.5);
        await db.collection("pictionary_rooms").doc(state.roomId).update({
            'guessIt.canvasData': dataUrl,
            'guessIt.lastUpdate': Date.now()
        });
    }, 500);
}

function listenToCanvasStream() {
    // Il listener principale gi√† gestisce gli update
}

async function submitGuess() {
    const input = document.getElementById('guess-input');
    const guess = input.value.trim().toUpperCase();
    
    if (!guess) return;
    
    input.value = '';
    
    // Invia la risposta
    await db.collection("pictionary_rooms").doc(state.roomId).update({
        [`guessIt.guesses.${Date.now()}`]: {
            player: state.playerName,
            guess: guess,
            timestamp: Date.now()
        }
    });
}

function startGuessItTimer(seconds) {
    let remaining = seconds;
    const timerEl = document.getElementById('guessit-timer');
    
    const interval = setInterval(() => {
        remaining--;
        if (timerEl) timerEl.textContent = remaining;
        
        if (remaining <= 10) timerEl?.classList.add('warning');
        
        if (remaining <= 0) {
            clearInterval(interval);
            endGuessItRound();
        }
    }, 1000);
}

async function endGuessItRound() {
    if (guessItState.streamInterval) {
        clearInterval(guessItState.streamInterval);
    }
    
    if (state.isHost) {
        // Passa al prossimo round o termina
        const data = state.roomData;
        const nextRound = (data.guessIt?.round || 0) + 1;
        
        if (nextRound >= guessItState.totalRounds) {
            await db.collection("pictionary_rooms").doc(state.roomId).update({
                stato: 'results',
                scores: guessItState.scores
            });
        } else {
            // Prossimo disegnatore
            const players = data.players;
            const nextDrawerIdx = nextRound % players.length;
            const nextDrawer = players[nextDrawerIdx];
            const nextWord = THEMES[Math.floor(Math.random() * THEMES.length)];
            
            await db.collection("pictionary_rooms").doc(state.roomId).update({
                'guessIt.round': nextRound,
                'guessIt.currentDrawer': nextDrawer,
                'guessIt.currentWord': nextWord,
                'guessIt.canvasData': null,
                'guessIt.guesses': {}
            });
        }
    }
}
</script>

</body>
</html>
