<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Paroliere dei maiali üê∑</title>
	<script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-app-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-firestore-compat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700;900&display=swap');

        :root {
            /* LIGHT THEME */
            --primary: #3498db;
            --accent: #e74c3c;
            --bg: #ecf0f1;
            --text-main: #2c3e50;
            --tile-bg: #fff;
            --tile-text: #34495e;
            --tile-shadow: #95a5a6;
            --tile-selected: #f1c40f;
            --tile-valid: #2ecc71;
            --panel-bg: #fff;
            --item-bg: #f8f9fa;
            --line-color: rgba(44, 62, 80, 0.8);
            --overlay-bg: rgba(44, 62, 80, 0.98);
            
            /* Variabile Dinamica per le colonne della griglia */
            --grid-cols: 5; 
        }

        body.dark-mode {
            /* DARK THEME */
            --primary: #3498db;
            --accent: #ff6b6b;
            --bg: #121212;
            --text-main: #ecf0f1;
            --tile-bg: #2c3e50;
            --tile-text: #ecf0f1;
            --tile-shadow: #000;
            --tile-selected: #f39c12;
            --tile-valid: #27ae60;
            --panel-bg: #1e1e1e;
            --item-bg: #2d2d2d;
            --line-color: rgba(241, 196, 15, 0.8);
            --overlay-bg: rgba(0, 0, 0, 0.95);
        }

        /* --- EFFETTO TERREMOTO PER BUSET --- */
        @keyframes earthquake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        @keyframes disco-flash {
            0% { background-color: #e74c3c; }
            25% { background-color: #f1c40f; }
            50% { background-color: #2ecc71; }
            75% { background-color: #9b59b6; }
            100% { background-color: #3498db; }
        }

        body.mega-win-effect {
            animation: earthquake 0.5s infinite, disco-flash 0.5s infinite;
        }
        /* ----------------------------------- */

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            display: flex; flex-direction: column; align-items: center;
            min-height: 100vh; margin: 0; padding: 10px;
            overflow-x: hidden; transition: background 0.3s, color 0.3s;
        }

        /* LAYOUT GLOBALE */
        .app-wrapper {
            width: 100%; max-width: 875px;	
            display: flex;flex-direction: column; padding: 0 10px;
        }

        /* HEADER ALLINEATO */
        .header-bar {
            display: flex; justify-content: space-between; align-items: center;
            width: 100%; margin-bottom: 10px;
        }
        h1 { margin: 0; font-size: 1.5rem; text-transform: uppercase; letter-spacing: 1px; color: var(--text-main); }

        .theme-btn {
            background: none; border: none; font-size: 1.5rem; cursor: pointer;
            padding: 5px; border-radius: 50%; transition: background 0.2s;
        }
        .theme-btn:hover { background: rgba(0,0,0,0.1); }
        body.dark-mode .theme-btn:hover { background: rgba(255,255,255,0.1); }

        .game-container {
            display: flex; flex-direction: column; gap: 20px; align-items: center;
            max-width: 950px; width: 100%; height: auto;
        }

        @media (min-width: 850px) {
            .game-container { 
                flex-direction: row; 
                align-items: stretch; 
                justify-content: center; 
                gap: 40px; 
            }
            .board-wrapper { flex: 0 0 450px; } 
            .sidebar { flex: 1; }
        }

        /* CONFIG BAR */
        .config-bar {
            width: 100%; background: var(--panel-bg); padding: 15px; border-radius: 10px;
            margin-bottom: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex; flex-direction: column; gap: 12px;
        }
        .config-row { display: flex; justify-content: space-between; align-items: center; }
        
        .code-display {
            font-family: monospace; font-weight: bold; font-size: 1.1rem;
            color: var(--primary); background: var(--bg); padding: 6px 10px; border-radius: 4px;
            cursor: pointer; border: 1px solid #ccc;
        }

        select { padding: 5px; border-radius: 4px; background: var(--bg); color: var(--text-main); border: 1px solid #7f8c8d; }

        /* BOARD AREA */
        .board-wrapper {
            display: flex; flex-direction: column; width: 100%;
        }

        .status-bar {
            display: flex; justify-content: space-between; width: 100%;
            margin-bottom: 8px; font-weight: bold; font-size: 1.2rem; align-items: center;
        }
        #timer { color: var(--accent); font-feature-settings: "tnum"; }
        .timer-alert { animation: urgentPulse 0.8s infinite; font-weight: 900; }
        @keyframes urgentPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); color: red; } }

        #current-word {
            height: 45px; display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; font-weight: 900; color: #2c3e50;
            background: #dfe6e9; width: 100%; border-radius: 8px; margin-bottom: 15px;
            text-transform: uppercase; letter-spacing: 2px; position: relative; z-index: 2;
        }

        .grid-container { position: relative; width: 100%; aspect-ratio: 1 / 1; touch-action: none; }
        #line-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }

        .grid {
            display: grid; 
            /* MODIFICA: Colonne dinamiche */
            grid-template-columns: repeat(var(--grid-cols), 1fr); 
            gap: 6px;
            background: #95a5a6; padding: 6px; border-radius: 10px;
            width: 100%; height: 100%; box-sizing: border-box; user-select: none;
            /*transition: transform 0.4s ease-in-out; */
            /*transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); */
        }

        /* TILES */
        .tile {
            background-color: var(--tile-bg); border-radius: 6px;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.8rem; font-weight: bold; color: var(--tile-text);
            cursor: pointer; box-shadow: 0 3px 0 var(--tile-shadow);
            position: relative; z-index: 2; user-select: none;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.2s; /* ROTAZIONE VELOCE QUI */
        }
        /* Stili specifici per griglie dense */
        .tile.small-font { font-size: 0.9rem; border-radius: 3px; box-shadow: 0 1px 0 var(--tile-shadow); }
        .tile.medium-font { font-size: 2.2rem; } /* Per 4x4 */

        /* Stile per la griglia 6x6 */
        .tile.six-font { font-size: 1.55rem; }
        .tile.six-font .bonus-badge { font-size: 0.58rem; padding: 1px 3px; }

        /* Stile per la griglia 7x7 */
        .tile.compact-font { font-size: 1.35rem; }
        .tile.compact-font .bonus-badge { font-size: 0.55rem; padding: 1px 3px; }

        .tile.blurred { color: transparent; text-shadow: 0 0 10px rgba(0,0,0,0.5); }
        .tile.selected { background-color: var(--tile-selected); transform: translateY(2px); box-shadow: 0 1px 0 var(--tile-shadow); color: #fff; }
        .tile.anim-valid { animation: pulseGreen 0.5s; }
        .tile.anim-invalid { animation: shakeRed 0.4s; }

        .bonus-badge {
            position: absolute; top: 2px; right: 2px;
            font-size: 0.6rem; font-weight: 900; padding: 2px 4px;
            border-radius: 3px; color: white; line-height: 1; pointer-events: none;
        }
        /* Badge pi√π piccoli per la 10x10 */
        .tile.small-font .bonus-badge { font-size: 0.5rem; padding: 1px 2px; top: 1px; right: 1px; }

        .b-2l { background: #3498db; }
        .b-3l { background: #2980b9; }
        .b-2p { background: #e67e22; }
        .b-3p { background: #e74c3c; }

        .rotate-btn {
            background: none; border: none; font-size: 1.5rem; cursor: pointer;
            transition: transform 0.2s; padding: 5px; color: var(--text-main);
        }
        .rotate-btn:hover { transform: rotate(90deg); }

        @keyframes pulseGreen { 0% { background: var(--tile-valid); } 100% { background: var(--tile-bg); } }
        @keyframes shakeRed { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); background: var(--accent); } 75% { transform: translateX(5px); } }

        /* SIDEBAR */
        .sidebar {
            width: 100%; max-width: 400px; background: var(--panel-bg);
            padding: 15px; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            display: flex; flex-direction: column; position: relative;
            min-height: 600px; 
        }
        @media (max-width: 800px) { .sidebar { height: 100%; min-height: 500px; flex: 1; } }

        .score-box-container { 
            position: relative; text-align: center; 
            border-bottom: 2px solid var(--bg); padding-bottom: 10px; margin-bottom: 10px; 
        }
        .score-box { display: inline-block; }
        .score-val { font-size: 2.2rem; color: var(--primary); font-weight: bold; line-height: 1.1; }
        .info-btn { 
            position: absolute; right: 0; top: 0;
            width: 24px; height: 24px; border-radius: 50%; background: #95a5a6; color: white; 
            border: none; font-weight: bold; cursor: pointer; 
        }

        .words-list { flex: 1; overflow-y: auto; list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 5px; min-height: 0; transition: filter 0.3s; }
        .words-list.blurred-list { filter: blur(8px); pointer-events: none; user-select: none; }

        .words-list li {
            padding: 8px 10px; background: var(--item-bg); border-radius: 4px; display: flex; justify-content: space-between; align-items: center;
            transition: all 0.2s; border: 1px solid transparent;
        }
        .words-list li.deleted { text-decoration: line-through; opacity: 0.5; }
        .words-list li.missed { border-left: 4px solid var(--accent); background: rgba(231, 76, 60, 0.1); }
        .words-list.interactive li:hover { background: #ffe0b2; color: #333; }

        .word-item-left { display: flex; align-items: center; gap: 8px; }
        .btn-eye { 
            background: none; border: none; cursor: pointer; font-size: 1.1rem; padding: 0;
            opacity: 0.5; transition: all 0.2s; display: flex; align-items: center;
        }
        .btn-eye:hover { opacity: 1; transform: scale(1.2); }

        /* COMMON UI BUTTONS */
        .btn-action {
            width: 100%; padding: 12px; font-size: 0.9rem; border: none; border-radius: 6px;
            color: white; cursor: pointer; font-weight: bold; text-transform: uppercase; margin-top: 10px;
        }
        .btn-new { background-color: #34495e; }
        .btn-join { background-color: #7f8c8d; }
        .btn-reset { background-color: #e67e22; display: none; }
        
        .btn-end-now { background-color: var(--accent); display: none; } 

        .btn-history { 
            background-color: #8e44ad; width: 100%; margin-top: 10px; 
            padding: 12px; font-size: 0.9rem; border-radius: 6px; 
            flex: 0 0 auto; height: auto; 
        }
        .btn-missed { background-color: #16a085; width: 100%; margin-bottom: 5px; padding: 12px; font-size: 0.9rem; border-radius: 6px; display:none; flex: 0 0 auto; color: white; font-weight: bold; border: none; text-transform: uppercase; cursor: pointer;}

        .btn-group { display: flex; gap: 10px; width: 100%; margin-top: 10px; flex-shrink: 0;}
        .game-controls { display: flex; gap:10px; margin-top: 10px; }
        .game-controls .btn-action { margin-top: 0; }
        .btn-pause { background-color: #f39c12; }
        .btn-sandbox { background-color: #95a5a6; display: none; }
        
        .btn-action:hover, .btn-missed:hover { filter: brightness(1.1); }

        /* SWITCH */
        .switch-container { display: flex; align-items: center; font-size: 0.9rem; }
        .switch { position: relative; display: inline-block; width: 40px; height: 22px; margin-left: 10px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 22px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary); }
        input:checked + .slider:before { transform: translateX(18px); }

        /* MODALS */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 3000;
            display: none; justify-content: center; align-items: center;
        }
        .modal-content {
            background: var(--panel-bg); padding: 25px; border-radius: 10px;
            width: 90%; max-width: 500px; max-height: 85vh; overflow-y: auto;
            position: relative; display: flex; flex-direction: column; color: var(--text-main);
        }
        .close-modal { position: absolute; top: 10px; right: 15px; font-size: 2rem; cursor: pointer; line-height: 1; }
        
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
        .stat-card { background: var(--item-bg); padding: 10px; border-radius: 8px; text-align: center; }
        .stat-val { font-size: 1.2rem; font-weight: bold; color: var(--primary); display:block; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
        .stat-label { font-size: 0.75rem; opacity: 0.8; }

        .legend-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .legend-table th, .legend-table td { border-bottom: 1px solid #ccc; padding: 8px; text-align: left; }
        
        .history-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .history-table th, .history-table td { border-bottom: 1px solid #ccc; padding: 8px; text-align: left; font-size: 0.9rem;}
        
        .history-total-box { margin-top: 20px; background: #2c3e50; color: white; padding: 15px; border-radius: 8px; text-align: center; font-size: 1.2rem; font-weight: bold; }
        
        /* SORT & COMPARE TOOLS */
        .compare-tools, .sort-controls { display: none; } 
        .compare-tools { 
            background: #f39c1222; padding: 10px; border-radius: 8px; margin-bottom: 10px; border: 1px solid #f39c12; flex-shrink: 0; 
            flex-direction: column; gap: 5px; 
        }
        
        .compare-title { 
            font-size: 0.8rem; text-align: center; font-weight: bold; 
            text-transform: uppercase; color: #d35400; margin-bottom: 5px;
        }
        .compare-btns { display: flex; gap: 10px; width: 100%; }
        .btn-compare { 
            flex: 1; padding: 8px; border:none; border-radius:4px; 
            color:white; font-weight:bold; cursor:pointer; font-size: 0.85rem;
        }
        .btn-copy { background: #3498db; } .btn-verify { background: #27ae60; }
        
        .sort-controls { justify-content: center; gap: 8px; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px dashed #ccc; flex-shrink: 0; }
        .sort-btn { background: var(--item-bg); border: 1px solid #ccc; padding: 6px 10px; border-radius: 4px; cursor: pointer; color: var(--text-main); }
        .sort-btn.active { background: var(--primary); color: white; border-color: var(--primary); }

        #grid-overlay {
            position: absolute; inset: 0; background: var(--overlay-bg); border-radius: 10px;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 20; color: white; text-align: center;
        }

        #pause-overlay {
            position: absolute; inset: 0; background: var(--bg); border-radius: 10px;
            display: none; justify-content: center; align-items: center;
            z-index: 50; color: var(--text-main); font-size: 2rem; font-weight: bold; letter-spacing: 2px;
            flex-direction: column; gap: 10px;
        }

        #btn-via {
            width: 100px; height: 100px; border-radius: 50%; background: #e74c3c; border: 4px solid white;
            color: white; font-size: 1.8rem; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 15px rgba(0,0,0,0.5); animation: pulseBtn 1.5s infinite; margin-top: 15px;
        }
        
        .confetti { position: fixed; width: 10px; height: 10px; z-index: 9999; pointer-events: none; }
        .bonus-legend-item { display:flex; align-items:center; gap:10px; margin-bottom:5px; }
        
        #loading-msg {
            position: fixed; inset: 0; background: var(--bg);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-size: 1.2rem; font-weight: bold; color: var(--primary); z-index: 5000;
        }
			#ach-notification {
				 position: absolute; /* Ora √® assoluto rispetto alla sidebar */
				 top: 50%; left: 50%; /* Centrato nella sidebar */
				 transform: translate(-50%, -50%) scale(0);
				 width: 90%; /* Occupa quasi tutta la larghezza della sidebar */
				 
				 background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%); /* Verde brillante */
				 color: white;
				 padding: 15px;
				 border-radius: 10px;
				 font-weight: bold;
				 font-size: 1.1rem; /* Font pi√π piccolo per starci dentro */
				 z-index: 100; /* Sopra la lista parole */
				 box-shadow: 0 5px 15px rgba(0,0,0,0.3);
				 text-align: center;
				 border: 2px solid white;
				 transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
				 display: flex; flex-direction: column; align-items: center; gap: 5px;
				 pointer-events: none; /* Cos√¨ puoi cliccare sotto se serve */
			}

			#ach-notification.show { 
				 transform: translate(-50%, -50%) scale(1); 
			}

			 @keyframes popIn {
				  0% { transform: scale(0); opacity: 0; }
				  60% { transform: scale(1.1); opacity: 1; }
				  100% { transform: scale(1); }
			 }
        
		 /* MODAL FINE PARTITA - STILE EPICO */
		 #game-end-modal .modal-content {
			  /* Gradiente diverso dagli achievement (Blu/Viola/Indaco) */
			  background: linear-gradient(135deg, #2c3e50 0%, #2980b9 50%, #8e44ad 100%);
			  color: white;
			  
			  /* Bordo e Ombre come richiesto */
			  border: 6px solid white;
			  box-shadow: 0 0 60px rgba(52, 152, 219, 0.6), 0 0 0 15px rgba(255, 255, 255, 0.1);
			  border-radius: 25px;
			  
			  /* Dimensioni e layout */
			  max-width: 450px;
			  width: 90%;
			  padding: 40px 20px;
			  text-align: center;
			  
			  /* Animazione ingresso */
        animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
		      margin: auto; 

		 }

		 /* Rimuoviamo lo sfondo grigio dal box del punteggio per farlo stare bene sul gradiente */
		 #game-end-modal .score-container-inner {
			  background: rgba(0, 0, 0, 0.2); /* Sfondo semitrasparente scuro */
			  padding: 20px;
			  border-radius: 15px;
			  margin-bottom: 25px;
			  border: 1px solid rgba(255,255,255,0.2);
		 }

		 /* Bottone speciale per il modale finale */
		 #game-end-modal .btn-action {
			  background: white;
			  color: #2980b9;
			  font-size: 1.1rem;
			  font-weight: 900;
			  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
			  transition: transform 0.2s;
		 }
		 #game-end-modal .btn-action:hover {
			  transform: scale(1.05);
			  background: #ecf0f1;
		 }
		  
        /* Aggiungi un sottotitolo all'achievement nel JS se vuoi, o usa quello esistente */
        #ach-text { text-shadow: 2px 2px 0px rgba(0,0,0,0.2); }

        .processing-blur {
             filter: blur(8px);
             pointer-events: none;
             user-select: none;
             transition: filter 0.3s ease;
        }
        
		   #start-screen {
            position: absolute; inset: 0; 
            background: var(--panel-bg); 
            border-radius: 10px;
            display: flex; flex-direction: column; 
            justify-content: center; align-items: center;
            z-index: 100; /* Sopra a tutto */
            color: var(--text-main); 
            text-align: center;
            padding: 20px;
        }
		  
        #calculation-overlay {
             position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999;
             display: none; justify-content: center; align-items: center; flex-direction: column;
        }
        #calculation-overlay .msg-box {
             background: rgba(0, 0, 0, 0.8); color: white; padding: 20px 40px; border-radius: 10px;
             font-size: 1.5rem; font-weight: bold; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body class="dark-mode">
<div id="calculation-overlay">
    <div class="msg-box">üß† Calcolo Soluzioni...</div>
</div>
<div id="loading-msg">
    Caricamento Dizionario...
    <div style="font-size:0.9rem; color:#777; margin-top:10px; font-weight:normal;">(Database parole)</div>
</div>

<div class="app-wrapper">
    <!-- Header Allineato -->
    <div class="header-bar">
            <h1>Paroliere dei maiali üê∑</h1>
            <button class="theme-btn" onclick="toggleTheme()" title="Cambia Tema">üåó</button>
    </div>

    <div class="game-container">
        
        <div class="board-wrapper">
            <!-- Configurazione -->
            <div class="config-bar">
                <div class="config-row">
                    <span style="font-weight:bold; opacity:0.8;">Codice:</span>
                    <span class="code-display" id="display-seed" onclick="copySeed()" title="Copia">----</span>
                </div>
                <div class="config-row">
                    <div class="switch-container">Modalit√† Click <label class="switch"><input type="checkbox" id="input-mode-toggle"><span class="slider"></span></label></div>
                </div>
            </div>

            <div class="status-bar">
                <span>Tempo: <span id="timer">03:00</span></span>
					 <span>Trovabili: <span id="possible-count" style="opacity:0.6;">...</span></span>
                <button id="manual-rotate-btn" class="rotate-btn" onclick="rotateGrid()" title="Ruota Griglia">üîÑ</button>
            </div>
            
            <div id="current-word"></div>

				<div class="grid-container">
					 <svg id="line-layer" width="100%" height="100%"></svg>
					 
					 <!-- --- NUOVO: SCHERMATA INIZIALE --- -->
					 <div id="start-screen">
						  <div style="font-size:3rem; margin-bottom:10px;">üé≤</div>
						  <h2>BENVENUTO</h2>
						  <p style="margin-bottom:20px; opacity:0.8;">Inizia una nuova sfida o unisciti a un amico</p>
					 </div>
					 <!-- --------------------------------- -->

					 <div id="grid-overlay">
                    <div style="font-size:1rem;">Codice: <span id="overlay-seed" style="color:#f1c40f; font-weight:bold;"></span></div>
                    <div style="margin-top:5px; font-size:0.9rem; opacity:0.8;">Premi VIA per svelare</div>
                    <button id="btn-via" onclick="startRound()">VIA!</button>
                </div>
                <!-- PAUSA: OPACO -->
                <div id="pause-overlay">
                    <div>‚è∏Ô∏è IN PAUSA</div>
                    <div style="font-size:0.9rem; opacity:0.7;">Premi RIPRENDI per continuare</div>
                </div>
                <div class="grid" id="grid"></div>
            </div>
            
            <!-- CONTROLLI PARTITA -->
            <div id="in-game-controls" class="game-controls" style="display:none;">
                <button id="btn-pause" class="btn-action btn-pause" onclick="togglePause()">PAUSA</button>
                <button id="btn-terminate" class="btn-action btn-end-now" onclick="endGameManually()">TERMINA ORA</button>
            </div>
            
            <button id="btn-sandbox" class="btn-action btn-sandbox" onclick="startSandbox()">SBLOCCA GRIGLIA (LIBERA)</button>
            <button id="btn-reset-selection" class="btn-action btn-reset" onclick="clearSelection()">AZZERA SELEZIONE</button>
            
            <div class="btn-group">
                <button class="btn-action btn-new" onclick="startNewGame()">NUOVA</button>
                <button class="btn-action btn-join" onclick="joinGame()">UNISCITI</button>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <div class="score-box-container">
                <div class="score-box">
                    <div style="font-size:0.8rem; font-weight:bold;">PUNTEGGIO</div>
                    <div class="score-val" id="total-score">0</div>
                </div>
                <button class="info-btn" onclick="openLegend()" title="Legenda">i</button>
            </div>
            
            <div style="display:flex; justify-content:space-between; font-weight:bold; margin-bottom:5px; flex-shrink:0;">
                <span>Parole: <span id="word-count">0</span></span>
            </div>

            <!-- Sort -->
            <div class="sort-controls" id="sort-controls">
                <button class="sort-btn" title="Cronologico" onclick="setSortMode('chrono')">üïí</button>
                <button class="sort-btn active" title="Alfabetico" onclick="setSortMode('alpha')">üî§</button>
                <button class="sort-btn" title="Punteggio" onclick="setSortMode('score')">üèÜ</button>
                <button class="sort-btn" title="Ordinamento" onclick="toggleSortDirection()" id="sort-dir-btn">‚¨áÔ∏è</button>
            </div>

            <!-- Compare -->
            <div class="compare-tools" id="compare-tools">
                <div class="compare-title">Confronto con Avversari</div>
                <div class="compare-btns">
                    <button class="btn-compare btn-copy" onclick="copyWords()">COPIA</button>
                    <button class="btn-compare btn-verify" onclick="pasteAndVerify()">VERIFICA</button>
                </div>
            </div>

            <div style="font-size:0.8rem; color:var(--accent); margin-bottom:5px; display:none; flex-shrink:0;" id="analysis-msg">Clicca per eliminare una parola</div>
            <div id="ach-notification">üèÜ <span id="ach-text">Obiettivo Sbloccato!</span></div>
            <ul class="words-list" id="found-words"></ul>
            
            <button id="btn-missed" class="btn-missed" onclick="showMissedWords()">üîç COSA MI SONO PERSO?</button>
            <button class="btn-action btn-history" onclick="openStats()">STORICO & STATS</button>
        </div>

    </div>
</div>

<div id="new-game-modal" class="modal-overlay">
    <div class="modal-content" style="text-align:center;">
        <span class="close-modal" onclick="closeNewGameModal()">&times;</span>
        <h2>Nuova Partita</h2>
        
        <div style="margin-bottom: 20px;">
            <label for="modal-timer-select" style="font-weight:bold; display:block; margin-bottom:5px;">Durata:</label>
            <select id="modal-timer-select" style="width: 100%; padding: 8px; font-size: 1rem;">
                <option value="45">45s (Fulmine)</option>
					 <option value="60">60s (Blitz)</option>
                <option value="90">90s</option>
                <option value="180" selected>180s (Standard)</option>
                <option value="300">300s (Relax)</option>
            </select>
        </div>

        <!-- NUOVO SELETTORE GRIGLIA -->
        <div style="margin-bottom: 20px;">
            <label for="modal-grid-select" style="font-weight:bold; display:block; margin-bottom:5px;">Dimensione Griglia:</label>
				<select id="modal-grid-select" style="width: 100%; padding: 8px; font-size: 1rem;">
					 <option value="4">4x4 (Easy)</option>
					 <option value="5" selected>5x5 (Classica)</option>
					 <option value="6">6x6 (Intermedia)</option>
					 <option value="7">7x7 (Grande)</option>
					 <option value="10">10x10 (Estrema!)</option>
				</select>
        </div>

        <p style="margin-bottom:20px; color:var(--text-main);">Scegli la modalit√† di gioco:</p>
        
		<div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
			 <!-- confirmNewGame(Bonus, Crazy, Biatch) -->
			 <button class="btn-action" style="background:#7f8c8d; width:auto; padding:15px 30px; margin-top:0;" onclick="confirmNewGame(false, false, false)">CLASSICA</button>
			 <button class="btn-action" style="background:#e67e22; width:auto; padding:15px 30px; margin-top:0;" onclick="confirmNewGame(true, false, false)">BONUS ‚≠ê</button>
			 <button class="btn-action" style="background:#9b59b6; width:auto; padding:15px 30px; margin-top:0;" onclick="confirmNewGame(true, true, false)">CRAZY ü§™</button>
			 <button class="btn-action" style="background:#ff00ff; color:white; width:auto; padding:15px 30px; margin-top:0;" onclick="confirmNewGame(true, true, true)">BIATCH üíÖ</button>
		</div>
    </div>
</div>

<!-- Modal Storico & Stats -->
<div id="stats-modal" class="modal-overlay">
    <div class="modal-content">
        <span class="close-modal" onclick="closeStats()">&times;</span>
        <h2>Statistiche</h2>
        
        <div class="stats-grid">
            <div class="stat-card"><span class="stat-val" id="stat-total-games">0</span><span class="stat-label">Partite</span></div>
            <div class="stat-card"><span class="stat-val" id="stat-high-score">0</span><span class="stat-label">Record</span></div>
            <div class="stat-card"><span class="stat-val" id="stat-total-score">0</span><span class="stat-label">Punti Totali</span></div>
            <div class="stat-card"><span class="stat-val" id="stat-avg-score">0</span><span class="stat-label">Media Punti</span></div>
            <div class="stat-card"><span class="stat-val" id="stat-best-word">-</span><span class="stat-label">Pi√π Preziosa</span></div>
            <div class="stat-card" style="grid-column: span 1;"><span class="stat-val" id="stat-longest-word">-</span><span class="stat-label">Pi√π Lunga</span></div>
        </div>

        <h3>Obiettivi</h3>
        <div id="achievements-list" style="margin-bottom:20px; font-size:0.9rem;"></div>

        <h3>Storico Partite</h3>
        <table class="history-table">
            <thead><tr><th>Data</th><th>Codice</th><th>Punti</th></tr></thead>
            <tbody id="history-list-body"></tbody>
        </table>
        
        <div style="margin-top:20px; text-align:center;">
            <button class="btn-action" style="background-color: var(--accent);" onclick="clearData()">RESET DATA</button>
        </div>
    </div>
</div>

<!-- Modal Legenda -->
<div id="legend-modal" class="modal-overlay">
    <div class="modal-content">
        <span class="close-modal" onclick="closeLegend()">&times;</span>
        <h2>Legenda Punti</h2>
        <table class="legend-table">
            <thead><tr><th>Lunghezza</th><th>Punti Base</th></tr></thead>
            <tbody>
                <tr><td>4 lettere</td><td>1</td></tr>
                <tr><td>5 lettere</td><td>2</td></tr>
                <tr><td>6 lettere</td><td>3</td></tr>
                <tr><td>7 lettere</td><td>5</td></tr>
                <tr><td>8+ lettere</td><td>11</td></tr>
            </tbody>
        </table>
        <div style="margin-top:20px; font-size:0.9rem;">
            <p><b>Q</b> = <b>Qu</b> (Conta come 2 lettere!)</p>
            <hr style="margin:10px 0; border:0; border-top:1px solid #ccc;">
            <p style="font-weight:bold; margin-bottom:10px;">Bonus:</p>
            <div class="bonus-legend-item"><span class="bonus-badge b-2l" style="position:relative;">2L</span> +2 Punti al totale</div>
            <div class="bonus-legend-item"><span class="bonus-badge b-3l" style="position:relative;">3L</span> +3 Punti al totale</div>
            <div class="bonus-legend-item"><span class="bonus-badge b-2p" style="position:relative;">2P</span> Punteggio parola x2</div>
            <div class="bonus-legend-item"><span class="bonus-badge b-3p" style="position:relative;">3P</span> Punteggio parola x3</div>
        </div>
    </div>
</div>

<!-- Modal Fine Partita Aggiornato -->
<div id="game-end-modal" class="modal-overlay" style="z-index: 5000;">
    <div class="modal-content">
        <!-- Icona animata -->
        <div style="font-size: 5rem; margin-bottom: 10px; animation: bounceIn 0.8s;">üèÅ</div>
        
        <h2 style="margin: 0 0 10px 0; font-size: 2.5rem; text-transform: uppercase; text-shadow: 0 2px 10px rgba(0,0,0,0.3);">Tempo Scaduto!</h2>
        <p style="opacity: 0.9; margin-bottom: 30px; font-size: 1.1rem;">La partita √® terminata.</p>
        
        <!-- Contenitore punteggio semitrasparente -->
        <div class="score-container-inner">
            <div style="font-size: 1rem; text-transform: uppercase; letter-spacing: 2px; opacity: 0.8;">Punteggio Finale</div>
            <div id="end-score-val" style="font-size: 5rem; font-weight: 900; line-height: 1; text-shadow: 0 5px 0 rgba(0,0,0,0.2);">0</div>
        </div>
    </div>
</div>

<script>
		// --- CONFIGURAZIONE FIREBASE (Incolla qui le tue chiavi) ---
    const firebaseConfig = {
        apiKey: "AIzaSyCNo7o2Ft22JDEyJ97BspE3Kur5DNAPKQc",
        authDomain: "funatwork-cd237.firebaseapp.com",
        projectId: "funatwork-cd237",
        storageBucket: "funatwork-cd237.firebasestorage.app",
        messagingSenderId: "798226885203",
        appId: "1:798226885203:web:ce83f4d9e96b82266274a6"
    };
	firebase.initializeApp(firebaseConfig);
	const db = firebase.firestore();
	
	// Variabili per il match live
	const urlParams = new URLSearchParams(window.location.search);
	const matchId = urlParams.get('matchId');
	const mioNome = localStorage.getItem('mioNome');
	// -----------------------------------------------------------
    // --- CONFIGURAZIONE ---
    let gridSize = 5; // Variabile dinamica (default 5)
    const MIN_WORD_LENGTH = 4;
    const LETTER_POOL = "AAAAAAAABBCCDDEEEEEEEEFFGGGHHIIIIIILLLMMNNOOOOOOPPQRRSSTTTUUUVVZ";
    const EXTRA_WORDS = ["ASIA","EUROPA","AFRICA","AMERICA","OCEANIA","ANTARTIDE","ITALIA","CINA","INDIA","USA","RUSSIA","FRANCIA","SPAGNA","GERMANIA","PERU","CILE","IRAN","IRAQ","LAOS","MALI","CUBA","FIJI","TOGO","ROMA","MILANO","NAPOLI","TORINO","BARI","OSLO","LIMA","RIGA","BONN","NILO","RENO","PO","TEVERE","ARNO","ADIGE","PIAVE","ADDA","ALPI","ANDE","URALI","ETNA","LAGO","MARE","MONTE","CITTA","ISOLA","BELA","LOBO","LOGO","JAVA","HTML","WEB","EMAIL","FILE","APP","GODITI","DIMMI","DAMMI","FAMMI","DILLO","FALLO","VATTENE","PIGLIAMI","SENTIMI",
    "ANITA","LUCA","MARCO","ANNA","MARIA","PAOLO","LUIGI","SARA","ELENA","ROSA","VIOLA","GIOIA","SOLE","LUNA","STELLA",
    "PISA","SIENA","PARMA","COMO","LECCO","LODI","ENNA","RAGUSA","FOGGIA","TERNI","AOSTA","MONZA","MEGA","EZIO","PORCHI","MAMELI","GARDA","MASAI","MAASAI","PABLO","SELINA","LAVAREDO","LARA","PETO","GENE","ENNE","ALARE","RAGU","MONA","GASAI","FETA","FETE","MASO","MASI","MEME","GASI","CAGA","SITE","CASIO","ALONSO","DRENI","CEDO","PENTO","PENTE","ERMA","ERMI",
    "SITA","TOFU","POTAI","PIPPE","CALCIA","ERSE","ERSI","QUINOA","GASO","BUSET","MISO","NASA","EBOLA","TERA","NONE","ZORRO","EOLIE","SERI","SILE","PELMO","PITA"];
	 const EXCLUDED_WORDS = ["SAETTI","BIFFE","PIATO","PIOTA","GILE","GLIE","GIOI","POPE","RAFFA","RAFFI","ZAFFI","PASCI","MEVE","MINO","BASTE","DIANE","MAIO","SPALLI","RENA","FELA","FERA","GATO","ZOIA","ANCE","ELISE","ELSE","FIFE","PILLI","PILLO","BASA","INIO","PIVA","PIVE","ROMI","ALPA","ALPO","BIDE","LARIO","LARO","LAURI","PROTI","NESTO","TOSONE","GORE","BIAVA","FOIA","PASSE","SAPA","LETO","LETA","ORTE","TORE","SILA","SERPA","ENEO","LENE","LENO","LIANO","IANO","MALO","BALIO",
	 "TELMA","TALLO","GRUMA","GIACO","PASCO","CIRA","VAGITA","FEDO","PRECI","SIRO","QUIRO","POTTE","ROSI","POTTA","PELUTO","BOVO","BETTO","CIANA","CIANE","CIANI","VELIE","FAGO","CORE","RICO","BOVE","CEBO","LIMANA","GIANA","MUFFI","MUFFO","NILA","FOGNATA","NASATE","LICE","GERI","MITRE","TOMA","PELTA","POLTA","FANNE","INNA","GENICA","AGIEA","FANNI","SANNA","SANNE","GINNO","FANNI","OLGO","CALE","IMMO","MITRE","TREVO","MESCE","PINGE","NINI","ANITO","OVATO",
	 "GELSA","TOSSO","COTI","BAULA","BAULO","CARMI","LORA","SIMO","BOTRO","EOLA","AGGIO","ALIA","BORNI","BORNIA"];

    // --- ACHIEVEMENTS ---
    const ACHIEVEMENTS = [
        { id: 'not_now', title: 'Anti-sgamo', desc: 'Metti in pausa il gioco', check: (ctx) => ctx.game.isPaused === true },
		  { id: 'blender', title: 'Frullatore', desc: 'Ruota la griglia 20 volte in una partita', check: (ctx) => rotationCount >= 20 },
        { id: 'flash', title: 'Flash', desc: 'Trova una parola nei primi 3 secondi', check: (ctx) => ctx.last.word && ctx.game.elapsedTime <= 3 },
		  { id: 'fotofinish', title: 'Fotofinish', desc: 'Trova una parola negli ultimi 3 secondi', check: (ctx) => ctx.last.word && ctx.game.timeRemaining <= 3 && !ctx.game.isOver },
		  { id: 'sloth', title: 'Bradipo', desc: 'Trova la prima parola quando mancano meno di 30 secondi', check: (ctx) => ctx.game.wordCount === 1 && ctx.game.timeRemaining < 30 },
		  { id: 'parkinson', title: 'Parkinson', desc: 'Sbaglia parola per 15 volte', check: (ctx) => errorCount >= 15 },
        { id: 'long_one', title: 'Linguista', desc: 'Trova una parola da 8 o pi√π lettere', check: (ctx) => ctx.last.word && ctx.last.word.length >= 8 },
        { id: 'palindromo', title: 'Specchio Riflesso', desc: 'Trova una parola palindroma', check: (ctx) => { const w = ctx.last.word; return w && w.length >= 4 && w === w.split('').reverse().join(''); }},
		  { id: 'sniper', title: 'Cecchino', desc: 'Trova una parola da almeno 30 punti', check: (ctx) => ctx.last.points >= 30 },
        { id: 'words_40', title: 'Mitragliatrice', desc: 'Trova 40 parole in una partita', check: (ctx) => ctx.game.wordCount >= 40 },
		  { id: 'score_200', title: 'Fuoriclasse', desc: 'Fai 200 punti in una partita', check: (ctx) => ctx.game.score >= 200 && ctx.game.score < 300 },
		  { id: 'score_300', title: 'Einstein', desc: 'Fai 300 punti in una partita', check: (ctx) => ctx.game.score >= 300 },
		  { id: 'gandhi', title: 'Gandhi', desc: 'Fai 0 punti in una partita', check: (ctx) => ctx.game.isOver && ctx.game.score === 0 && !ctx.game.isPaused },
        { id: 'copione', title: 'Copione', desc: 'Elimina il 95% delle tue parole in fase di verifica', check: (ctx) => ctx.game.wordCount >= 10 && (ctx.game.deletedCount / ctx.game.wordCount) >= 0.9 },
		  { id: 'buset', title: 'BUSET MAIALONE', desc: 'Hai trovato l amore della tua vita!', check: (ctx) => ctx.last.word === 'BUSET' },
          { id: 'biatch_move', title: 'MAL DI TESTA üíÖ', desc: 'Hai fatto girare la griglia tante volte!', check: (ctx) => isBiatchMode && rotationCount > 10 }
    ];

    // --- STATO ---
    let dictionary = new Set();
    let gridLetters = []; 
    let gridBonuses = []; 
    let selectedCells = []; 
    let foundWords =	new Map(); 
    let score = 0;
	 let isRotating = false;
	 let errorTimeout = null;
	 let rotationCount = 0;
	 let errorCount = 0;
	 let fireworksInterval = null;
    let timerInterval;
    let timeRemaining = 180;
    let initialTime = 180;
    let isGameActive = false;
    let isPaused = false; 
    let isDragging = false;
    let isSandboxMode = false; 
    let inputMode = 'drag'; 
    let currentSeed = "";
    let isAnalysisPhase = false;
    let wordCounter = 0; 
    let sortMode = 'chrono'; 
    let sortDescending = true; 
    let rotationIndex = 0; 
    let useBonuses = false;
    let currentGameTimestamp = null; 
    let currentHighlightedWord = null;
	 let isCrazyMode = false;
	 let isBiatchMode = false;
	     // --- TRIE (struttura veloce per cercare prefissi) ---
    class TrieNode {
        constructor() { this.children = {}; this.isWord = false; }
    }
    let trieRoot = null;

    function buildTrie() {
        trieRoot = new TrieNode();
        dictionary.forEach(word => {
            let node = trieRoot;
            for (const ch of word) {
                if (!node.children[ch]) node.children[ch] = new TrieNode();
                node = node.children[ch];
            }
            node.isWord = true;
        });
    }

    function hasPrefix(prefix) {
        let node = trieRoot;
        for (const ch of prefix) {
            if (!node.children[ch]) return false;
            node = node.children[ch];
        }
        return true;
    }

    // --- RNG ---
    function cyrb128(str) {
        let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;
        for (let i = 0, k; i < str.length; i++) { k = str.charCodeAt(i); h1 = h2 ^ Math.imul(h1 ^ k, 597399067); h2 = h3 ^ Math.imul(h2 ^ k, 2869860233); h3 = h4 ^ Math.imul(h3 ^ k, 951274213); h4 = h1 ^ Math.imul(h4 ^ k, 2716044179); }
        h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067); h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233); h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213); h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
        return [(h1^h2^h3^h4)>>>0, (h2^h1)>>>0, (h3^h1)>>>0, (h4^h1)>>>0];
    }
    function sfc32(a, b, c, d) {
        return function() { a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; var t = (a + b) | 0; a = b ^ b >>> 9; b = c + (c << 3) | 0; c = (c << 21 | c >>> 11); d = (d + 1) | 0; t = (t + d) | 0; c = (c + t) | 0; return (t >>> 0) / 4294967296; }
    }

    // --- DOM ---
    const gridEl = document.getElementById('grid');
    const wordDisplay = document.getElementById('current-word');
    const scoreDisplay = document.getElementById('total-score');
    const wordsListEl = document.getElementById('found-words');
    const timerDisplay = document.getElementById('timer');
    const loadingMsg = document.getElementById('loading-msg');
    const gridOverlay = document.getElementById('grid-overlay');
    const displaySeed = document.getElementById('display-seed');
    const overlaySeed = document.getElementById('overlay-seed');
    const gameControls = document.getElementById('in-game-controls');
    const btnPause = document.getElementById('btn-pause');
    const pauseOverlay = document.getElementById('pause-overlay');
    const wordCountDisplay = document.getElementById('word-count');
    const lineLayer = document.getElementById('line-layer');
    const analysisMsg = document.getElementById('analysis-msg');
    const sortControls = document.getElementById('sort-controls');
    const compareTools = document.getElementById('compare-tools');
    const btnMissed = document.getElementById('btn-missed');
    const sortDirBtn = document.getElementById('sort-dir-btn');
    const statsModal = document.getElementById('stats-modal');
    const historyListBody = document.getElementById('history-list-body');
    const legendModal = document.getElementById('legend-modal');
    const achNotif = document.getElementById('ach-notification');
    const newGameModal = document.getElementById('new-game-modal');
    const btnSandbox = document.getElementById('btn-sandbox');
    const btnResetSelection = document.getElementById('btn-reset-selection');
    const btnTerminate = document.getElementById('btn-terminate');
    const toggleInput = document.getElementById('input-mode-toggle');
    const modalGridSelect = document.getElementById('modal-grid-select'); 
	 const gameEndModal = document.getElementById('game-end-modal');
    // --- INIT ---
    async function loadDictionary() {
        try {
            // 1. LISTA DEGLI URL
            const urls = [
                'https://raw.githubusercontent.com/napolux/paroleitaliane/refs/heads/main/paroleitaliane/280000_parole_italiane.txt',
                'https://raw.githubusercontent.com/napolux/paroleitaliane/refs/heads/main/paroleitaliane/9000_nomi_propri.txt'
            ];

            // 2. FILTRA E SCARICA
            // .filter(u => u) rimuove le stringhe vuote automaticamente
            const responses = await Promise.all(
                urls.filter(u => u).map(u => fetch(u))
            );

            // 3. CONVERTI I TESTI
            const texts = await Promise.all(responses.map(r => r.text()));

            // 4. FUNZIONE DI PULIZIA
            const addWordsToDictionary = (textData) => {
                textData.split('\n').forEach(w => {
                    const clean = w.trim().toUpperCase()
                                   .normalize('NFD')
                                   .replace(/[\u0300-\u036f]/g, "")
                                   .replace(/[^A-Z]/g, "");
                    if (clean.length >= MIN_WORD_LENGTH && !EXCLUDED_WORDS.includes(clean)) {
                        dictionary.add(clean);}
                });
            };

            // 5. AGGIUNGI TUTTO AL DIZIONARIO
            texts.forEach(t => addWordsToDictionary(t));

            // Aggiunge le parole extra manuali
            EXTRA_WORDS.forEach(w => dictionary.add(w));
            // Costruisce il Trie per ricerche veloci
            buildTrie();
            
            // Aggiorna la UI
            loadingMsg.style.display = 'none';
            console.log(`Dizionario caricato: ${dictionary.size} parole totali.`);
            
            // Gestione URL param code
            const urlParams = new URLSearchParams(window.location.search);
            const codeParam = urlParams.get('code');
            
            if(codeParam) {
                initGame(codeParam);
            } else {
                gridEl.innerHTML = '';
                displaySeed.textContent = "----";
            }
            
        } catch (error) { 
            console.error(error);
            loadingMsg.innerHTML = "Errore caricamento dizionari.<br>Controlla i link o la connessione."; 
        }
    }

    // --- CORE GAME LOGIC ---
    function startNewGame() { newGameModal.style.display = 'flex'; }
    
		function confirmNewGame(withBonus, isCrazy = false, isBiatch = false) {
			 useBonuses = withBonus || isCrazy; // Crazy usa sempre i bonus
			 isCrazyMode = isCrazy; 
			 isBiatchMode = isBiatch;
			 const selectedSize = parseInt(modalGridSelect.value) || 5;
			 gridSize = selectedSize;
			 newGameModal.style.display = 'none';
			 initGame(null);
			 copySeedNewGame();
		}
    
    function closeNewGameModal() { newGameModal.style.display = 'none'; }
    function joinGame() {
        const code = prompt("Inserisci il Codice Partita:");
        if (code && code.trim().length > 0) initGame(code.trim().toUpperCase());
    }

    function initGame(forceSeed) {
	     timerDisplay.style.color = "";
		  document.getElementById('start-screen').style.display = 'none';
        clearInterval(timerInterval);
        isGameActive = false; isAnalysisPhase = false; isPaused = false; isSandboxMode = false;
        
        // Cleanup effetti visivi precedenti
        document.body.classList.remove('mega-win-effect');
        stopFireworks();
        
        score = 0; foundWords.clear(); selectedCells = []; wordCounter = 0; rotationIndex = 0; rotationCount = 0; errorCount = 0;
        currentGameTimestamp = null;
        
        scoreDisplay.textContent = "0"; wordCountDisplay.textContent = "0";
        wordsListEl.innerHTML = ""; wordsListEl.classList.remove('interactive');
        analysisMsg.style.display = "none"; sortControls.style.display = "none";
        compareTools.style.display = "none"; btnMissed.style.display = "none";
        btnSandbox.style.display = 'none';
        setSortMode('chrono');
        
        wordDisplay.textContent = ""; lineLayer.innerHTML = '';
        document.getElementById('possible-count').textContent = '...';
        document.getElementById('possible-count').style.opacity = '0.6';
        gameControls.style.display = 'none';
        pauseOverlay.style.display = 'none';
        btnPause.textContent = "PAUSA";
        btnPause.style.backgroundColor = "#f39c12";

        inputMode = toggleInput.checked ? 'click' : 'drag';
        btnResetSelection.style.display = (inputMode === 'click') ? 'block' : 'none';
        btnTerminate.style.display = 'none';

        // --- GESTIONE CODICE E MODALIT√Ä (BIATCH & CRAZY) ---
        if (forceSeed) {
            currentSeed = forceSeed;
            // Legge i flag dal codice incollato
            isBiatchMode = currentSeed.includes('-B1');
            isCrazyMode = currentSeed.includes('-C1');
            useBonuses = currentSeed.endsWith('+') || isCrazyMode || isBiatchMode;
            
            // Estrae dimensione griglia
            const sizeMatch = currentSeed.match(/-S(\d+)/);
            if(sizeMatch && sizeMatch[1]) {
                gridSize = parseInt(sizeMatch[1]);
            } else {
                gridSize = 5; 
            }

            // Estrae durata timer
            const timeMatch = currentSeed.match(/-T(\d+)/);
            if(timeMatch && timeMatch[1]) {
                timeRemaining = parseInt(timeMatch[1]);
            } else {
                const modalTimer = document.getElementById('modal-timer-select');
                timeRemaining = parseInt(modalTimer ? modalTimer.value : 180);
            }
        } else {
            // Crea una nuova partita
            const baseSeed = Math.random().toString(36).substring(7).toUpperCase();
            const modalTimer = document.getElementById('modal-timer-select');
            const selectedTime = parseInt(modalTimer ? modalTimer.value : 180);
            timeRemaining = selectedTime;

            // Costruisce i tag per il codice (Seed)
            let tags = `-S${gridSize}-T${timeRemaining}`;
            if (isBiatchMode) tags += "-B1";
            if (isCrazyMode) tags += "-C1";
            else if (useBonuses) tags += "+";
            
            currentSeed = baseSeed + tags;
        }
        
        // --- UI BIATCH ---
        // Nascondi il pulsante di rotazione manuale se sei in modalit√† Biatch
        const manualRotBtn = document.getElementById('manual-rotate-btn');
        if(manualRotBtn) manualRotBtn.style.display = isBiatchMode ? 'none' : 'block';

        initialTime = timeRemaining;
        if (gridSize === 4 && timeRemaining === 45) showElenaPopup();

        timerDisplay.textContent = formatTime(timeRemaining);
        timerDisplay.className = "";
        displaySeed.textContent = currentSeed;
        overlaySeed.textContent = currentSeed;

        // Estrae il seme pulito per l'RNG (tutto ci√≤ che precede il primo trattino)
        const cleanSeed = currentSeed.split('-')[0];
        
        generateGridData(cleanSeed);
        renderGrid();
        gridOverlay.style.display = 'flex';
        
        const newUrl = window.location.protocol + "//" + window.location.host + window.location.pathname + '?code=' + currentSeed;
        window.history.pushState({path:newUrl},'',newUrl);
    }

    function generateGridData(rngSeedStr) {
        const seedHash = cyrb128(rngSeedStr);
        // Generatore di numeri casuali basato sul seme (uguale per tutti i giocatori)
        const rand = sfc32(seedHash[0], seedHash[1], seedHash[2], seedHash[3]);
        
        gridLetters = []; 
        gridBonuses = [];
        const totalCells = gridSize * gridSize;
        
        // 1. Generazione standard lettere
        for (let i = 0; i < totalCells; i++) gridLetters.push(LETTER_POOL.charAt(Math.floor(rand() * LETTER_POOL.length)));
        
        // 2. Generazione bonus
        for (let i = 0; i < totalCells; i++) {
            let bonus = null;
            let rngVal = rand(); 
				let bonusProbability = isCrazyMode ? 0.70 : 0.20; //70% di probabilit√† invece di 20%
            if(rngVal < bonusProbability) {
                const r = rand(); 
					if (isCrazyMode) {
						 // In modalit√† Crazy, i bonus 3P e 3L sono molto pi√π comuni
						 if(r < 0.30) bonus = "2L"; 
						 else if(r < 0.50) bonus = "3L"; 
						 else if(r < 0.75) bonus = "2P"; 
						 else bonus = "3P"; 
					} else {
						 // Modalit√† standard
						 if(r < 0.60) bonus = "2L"; else if(r < 0.85) bonus = "3L"; else if(r < 0.95) bonus = "2P"; else bonus = "3P"; 
					}
			  }
			  gridBonuses.push(useBonuses ? bonus : null);
		 }

        // --- INIEZIONE CODICE CAMUFFATO (SECRET MODE) ---
        // Se il codice contiene "B7S3T", inseriamo la parola in modo "naturale" (serpeggiante)
        if (rngSeedStr.includes("B7S3T") && totalCells >= 5) {
            const secretWord = ['B', 'U', 'S', 'E', 'T'];
            let inserted = false;
            let attempts = 0;

            // Tentiamo di inserire la parola (max 500 tentativi per evitare blocchi infiniti)
            while (!inserted && attempts < 500) {
                attempts++;
                let currentPath = [];
                let usedIndices = new Set();

                // A. Scegli un punto di partenza casuale
                let currentIdx = Math.floor(rand() * totalCells);
                currentPath.push(currentIdx);
                usedIndices.add(currentIdx);

                // B. Cerca di piazzare le lettere successive
                for (let i = 1; i < secretWord.length; i++) {
                    // Trova vicini validi (adiacenti e non usati)
                    let r = Math.floor(currentIdx / gridSize);
                    let c = currentIdx % gridSize;
                    let validNeighbors = [];

                    for (let nr = r - 1; nr <= r + 1; nr++) {
                        for (let nc = c - 1; nc <= c + 1; nc++) {
                            // Controlla confini griglia
                            if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize) {
                                let nIdx = nr * gridSize + nc;
                                // Non deve essere la cella stessa e non deve essere gi√† usata
                                if (nIdx !== currentIdx && !usedIndices.has(nIdx)) {
                                    validNeighbors.push(nIdx);
                                }
                            }
                        }
                    }

                    // Se siamo in un vicolo cieco, interrompi questo tentativo
                    if (validNeighbors.length === 0) break;

                    // C. Scegli un vicino a caso (usa rand() per sincronia tra giocatori)
                    let nextIdx = validNeighbors[Math.floor(rand() * validNeighbors.length)];
                    currentPath.push(nextIdx);
                    usedIndices.add(nextIdx);
                    currentIdx = nextIdx;
                }

                // D. Se abbiamo piazzato tutte le 5 lettere, applichiamo alla griglia
                if (currentPath.length === secretWord.length) {
                    for (let k = 0; k < secretWord.length; k++) {
                        gridLetters[currentPath[k]] = secretWord[k];
                    }
                    inserted = true;
                }
            }
        }
    }

    function renderGrid() {
        gridEl.innerHTML = '';
        // Set CSS Variable for grid size
        gridEl.style.setProperty('--grid-cols', gridSize);
        
        let displayLetters = [...gridLetters];
        let displayBonuses = [...gridBonuses];
        for(let r=0; r<rotationIndex; r++) { displayLetters = rotateArray(displayLetters); displayBonuses = rotateArray(displayBonuses); }
        
        const totalCells = gridSize * gridSize;

        for (let i = 0; i < totalCells; i++) {
            const char = displayLetters[i];
            const bonus = displayBonuses[i];
            const tile = document.createElement('div');
            tile.classList.add('tile');
            if(!isGameActive && !isAnalysisPhase && !isPaused && !isSandboxMode) tile.classList.add('blurred');
            
            // --- GESTIONE CLASSI DIMENSIONI ---
            if(gridSize === 4) tile.classList.add('medium-font'); 
				else if(gridSize === 5) tile.classList.add('six-font'); 				
            else if(gridSize === 7) tile.classList.add('compact-font'); 
            else if(gridSize >= 10) tile.classList.add('small-font');   

            tile.textContent = char === 'Q' ? 'Qu' : char;
            
            // --- GESTIONE SPECIFICA DELLA "Q" ---
            if(char === 'Q') {
                if(gridSize <= 5) tile.style.fontSize = "1.3rem"; 
					 else if(gridSize === 6) tile.style.fontSize = "1.15rem"; 
                else if(gridSize === 7) tile.style.fontSize = "1.0rem"; 
            }
            
            tile.dataset.index = i;
            tile.dataset.bonus = bonus || "";

            if(bonus) {
                const badge = document.createElement('span');
                badge.className = `bonus-badge b-${bonus.toLowerCase()}`;
                badge.textContent = bonus;
                tile.appendChild(badge);
            }
            
            const startHandler = (e) => {
					if(errorTimeout){
					clearTimeout(errorTimeout);
					errorTimeout=null;
					wordDisplay.style.background="#dfe6e9";
					document.querySelectorAll('.tile').forEach(t => t.classList.remove('anim-invalid'));
					clearSelection();
					}
                if(!isGameActive) return;
                if (inputMode === 'drag') { e.preventDefault(); isDragging = true; selectTile(i); }
                else handleClickMode(i);
            };

            tile.addEventListener('mousedown', startHandler);
            tile.addEventListener('touchstart', startHandler, {passive:false});
            gridEl.appendChild(tile);
        }
        gridEl.dataset.letters = JSON.stringify(displayLetters);
        gridEl.dataset.bonuses = JSON.stringify(displayBonuses);
    }

    // Generic Rotation for N x N
    function rotateArray(arr) {
        const newArr = new Array(gridSize * gridSize);
        for(let r=0; r<gridSize; r++) {
            for(let c=0; c<gridSize; c++) {
                // Formula: newArr[col * N + (N - 1 - row)] = arr[row * N + col]
                newArr[c * gridSize + (gridSize - 1 - r)] = arr[r * gridSize + c];
            }
        }
        return newArr;
    }

    function rotateGrid() {
        // 1. BLOCCO ANTI-SPAM: Se sta gi√† girando, ignora il click
        if (isRotating) return; 
        
        // Controlli standard
        if ((!isGameActive && !isAnalysisPhase) || isPaused) return; 
        
        // Attiva il blocco
        isRotating = true;
        clearSelection();

        // Configurazione Animazione: SCATTANTE E VELOCE (0.3s)
        const duration = 300; 
        const easing = "cubic-bezier(0.25, 1, 0.5, 1)"; 

        // 2. Applica transizione
        const transitionStyle = `transform ${duration}ms ${easing}`;
        gridEl.style.transition = transitionStyle;
        
        const tiles = document.querySelectorAll('.tile');
        tiles.forEach(t => t.style.transition = transitionStyle);

        // 3. Esegui la rotazione visiva
        gridEl.style.transform = "rotate(90deg)";
        tiles.forEach(t => t.style.transform = "rotate(-90deg)");

        // 4. Aspetta la fine dell'animazione
        setTimeout(() => {
            gridEl.style.transition = "none";
            rotationIndex = (rotationIndex + 1) % 4;
            if(typeof rotationCount !== 'undefined') rotationCount++; 
            runAchievementCheck();
            renderGrid();
            gridEl.style.transform = "rotate(0deg)";
            isRotating = false;
        }, duration);
    }
	 
    function startRound() {
        isGameActive = true; isPaused = false; gridOverlay.style.display = 'none';
        gameControls.style.display = 'flex'; btnTerminate.style.display = 'block';
        document.querySelectorAll('.tile').forEach(t => t.classList.remove('blurred'));
        updateTimerDisplay();
        timerInterval = setInterval(() => {
            timeRemaining--; updateTimerDisplay();
            if (timeRemaining <= 0) endGame();
        }, 1000);
    // --- CALCOLO PAROLE TROVABILI (in background) ---
    const countEl = document.getElementById('possible-count');
    countEl.textContent = '...';
    countEl.style.opacity = '0.6';

    setTimeout(() => {
        if (!trieRoot) { countEl.textContent = '?'; return; }

        const vizL = JSON.parse(gridEl.dataset.letters);
        const total = gridSize * gridSize;
        const adjMap = Array.from({length: total}, (_, i) => getNeighbors(i));
        const found = new Set();
        const maxTime = 8000; // massimo 8 secondi di calcolo
        const startCalc = performance.now();

        function countSolve(idx, word, visited) {
            if (performance.now() - startCalc > maxTime) return;
            visited[idx] = true;

            // PRUNING: se nessuna parola inizia cos√¨, taglia subito
            if (!hasPrefix(word)) { visited[idx] = false; return; }

            if (word.length >= MIN_WORD_LENGTH && dictionary.has(word)) {
                found.add(word);
            }

            // Limite profondit√† per evitare blocchi su griglie grandi
            if (word.length >= 12) { visited[idx] = false; return; }

            for (let n of adjMap[idx]) {
                if (!visited[n]) {
                    let ch = vizL[n];
                    if (ch === 'Q') ch = 'QU';
                    countSolve(n, word + ch, visited);
                }
            }
            visited[idx] = false;
        }

        for (let i = 0; i < total; i++) {
            if (performance.now() - startCalc > maxTime) break;
            let ch = vizL[i];
            if (ch === 'Q') ch = 'QU';
            countSolve(i, ch, new Array(total).fill(false));
        }

        countEl.textContent = found.size;
        countEl.style.opacity = '1';
    }, 300);
    }

    function togglePause() {
        if(!isGameActive && !isPaused) return;
        const listEl = document.getElementById('found-words');
        if(!isPaused) {
            isPaused = true; isGameActive = false; clearInterval(timerInterval);
				runAchievementCheck();
            pauseOverlay.style.display = 'flex'; listEl.classList.add('blurred-list');
            btnPause.textContent = "RIPRENDI"; btnPause.style.backgroundColor = "#27ae60"; 
            clearSelection();
        } else {
            isPaused = false; isGameActive = true; pauseOverlay.style.display = 'none';
            listEl.classList.remove('blurred-list'); btnPause.textContent = "PAUSA"; btnPause.style.backgroundColor = "#f39c12"; 
            timerInterval = setInterval(() => { timeRemaining--; updateTimerDisplay(); if (timeRemaining <= 0) endGame(); }, 1000);
        }
    }

    function endGameManually() { if(confirm("Terminare ora?")) endGame(); }
    
    function endGame() {
        // 1. Ferma il timer e la logica di gioco "a punti"
        clearInterval(timerInterval);
		  
		  // --- FIX PER GANDHI ---
        // Forziamo un controllo manuale in questo momento esatto
        // Creiamo un contesto fittizio perfetto per questo check
        const gandhiContext = {
            game: {
                isOver: true,      // Siamo in endGame, quindi √® finita per forza
                score: score,      // Il punteggio attuale
                isPaused: false,   // Non √® in pausa, √® finita
                wordCount: foundWords.size,
                elapsedTime: initialTime // Tempo scaduto
            },
            stats: { totalGames: 100, totalScore: 100, highScore: 100 }, // Dati dummy, non servono per Gandhi
            last: { word: null, points: 0 }
        };
        
        // Controlliamo manualmente l'achievement
        const gandhiAch = ACHIEVEMENTS.find(a => a.id === 'gandhi');
        const data = getStorageData();
        
        if (gandhiAch && !data.achievements.includes('gandhi')) {
            if (gandhiAch.check(gandhiContext)) {
                data.achievements.push('gandhi');
                localStorage.setItem('paroliere_data', JSON.stringify(data));
                showAchievement(gandhiAch.title);
            }
        }
		  
        timerDisplay.classList.remove('timer-alert');
        
        // 2. Salva statistiche
		  currentGameTimestamp = Date.now();
        updateStats(); 
        
        // 3. UI Updates
        gameControls.style.display = 'none'; 
        pauseOverlay.style.display = 'none';
        
        // 4. --- SBLOCCO GRIGLIA (Modalit√† Libera Automatica) ---
        isGameActive = true;   // Lasciamo attivo il motore di input
        isSandboxMode = true;  // Ma attiviamo la modalit√† "senza regole"
        isAnalysisPhase = true;// Attiva gli strumenti di analisi
        
        // Rimuove il blur immediatamente
        document.querySelectorAll('.tile').forEach(t => t.classList.remove('blurred'));
        
        // Nascondi il bottone "Sblocca Griglia" perch√© √® gi√† sbloccata
        btnSandbox.style.display = 'none'; 
        
        // Mostra strumenti di analisi nella sidebar
        document.getElementById('found-words').classList.remove('blurred-list');
        clearSelection(); 
        wordDisplay.textContent = ""; 
        lineLayer.innerHTML = '';
        
        sortDescending = true; 
        document.getElementById('sort-dir-btn').textContent = "‚¨áÔ∏è";
        setSortMode('alpha');

        wordsListEl.classList.add('interactive');
        analysisMsg.style.display = "block"; 
        sortControls.style.display = "flex";
        compareTools.style.display = "flex"; 
        btnMissed.style.display = "block";

		// Mostra Modale
		 const modal = document.getElementById('game-end-modal');
		 modal.style.display = 'flex';
		 document.getElementById('end-score-val').textContent = score;

		 // Fuochi d'artificio
		 startEndGameCelebration(); 

		 // --- AUTO-CHIUSURA ---
		 // Timer unico e sicuro
		 setTimeout(() => {
			  document.getElementById('game-end-modal').style.display = 'none';
			  stopFireworks(); // <--- AGGIUNGI QUESTO: Ferma i lanci immediatamente
		 }, 5000); 
    }

    function startSandbox() {
        isSandboxMode = true; isGameActive = true; isAnalysisPhase = true; btnSandbox.style.display = 'none';
        document.querySelectorAll('.tile').forEach(t => t.classList.remove('blurred'));
        timerDisplay.textContent = "MODALIT√Ä LIBERA"; timerDisplay.style.color = "var(--primary)";
    }

    // --- INPUT SYSTEM (SMART) ---
    function getCenter(el) { const r = el.getBoundingClientRect(); return { x: r.left + r.width/2, y: r.top + r.height/2 }; }
    function dist(p1, p2) { return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)); }
    
    function handleClickMode(i) {
        if(selectedCells.includes(i)) {
             if(i === selectedCells[selectedCells.length-1]) validateWord();
             else if(selectedCells.length > 1 && i === selectedCells[selectedCells.length-2]) { selectedCells.pop(); updateVisuals(); }
             return;
        }
        if(selectedCells.length === 0 || isAdjacent(selectedCells[selectedCells.length-1], i)) { selectedCells.push(i); updateVisuals(); }
    }
    
    const moveListener = (x, y) => {
        if (inputMode !== 'drag' || !isDragging || !isGameActive) return;
        let closest = -1, minD = 9999;
        const last = selectedCells[selectedCells.length - 1];
        const candidates = getNeighbors(last); candidates.push(last);
        if(selectedCells.length > 1) candidates.push(selectedCells[selectedCells.length - 2]);
        candidates.forEach(idx => {
            const tile = gridEl.children[idx]; const d = dist({x, y}, getCenter(tile));
            if (d < tile.offsetWidth * 0.45 && d < minD) { minD = d; closest = idx; }
        });
        if (closest !== -1) attemptSelection(closest);
    };

    document.addEventListener('mousemove', (e) => { if (inputMode==='drag' && isDragging) moveListener(e.clientX, e.clientY); });
    document.addEventListener('touchmove', (e) => { if (inputMode==='drag' && isDragging) { e.preventDefault(); moveListener(e.touches[0].clientX, e.touches[0].clientY); } }, {passive:false});
    document.addEventListener('mouseup', () => endDrag()); document.addEventListener('touchend', () => endDrag());
    const endDrag = () => { if(isDragging) { isDragging = false; try { validateWord(); } catch(e){} if(!isSandboxMode) clearSelection(); } };

    function selectTile(i) { selectedCells = [i]; updateVisuals(); }
    function attemptSelection(i) {
        const last = selectedCells[selectedCells.length - 1];
        if (i === last) return;
        if (selectedCells.length > 1 && i === selectedCells[selectedCells.length - 2]) { selectedCells.pop(); updateVisuals(); return; }
        if (!selectedCells.includes(i) && isAdjacent(last, i)) { selectedCells.push(i); updateVisuals(); }
    }

    // Generic Neighbor check for N x N
    function getNeighbors(idx) {
        const n = [], r = Math.floor(idx / gridSize), c = idx % gridSize;
        for(let i=r-1; i<=r+1; i++) 
            for(let j=c-1; j<=c+1; j++) 
                if(i>=0 && i<gridSize && j>=0 && j<gridSize && !(i===r && j===c)) 
                    n.push(i * gridSize + j);
        return n;
    }
    
    function isAdjacent(i1, i2) { return getNeighbors(i1).includes(i2); }
    
    function updateVisuals() {
        document.querySelectorAll('.tile').forEach(t => t.classList.remove('selected'));
        let txt = ""; const letters = JSON.parse(gridEl.dataset.letters);
        selectedCells.forEach(idx => { gridEl.children[idx].classList.add('selected'); txt += (letters[idx] === 'Q' ? 'QU' : letters[idx]); });
        wordDisplay.textContent = txt; drawLine();
    }
    function clearSelection() { selectedCells = []; updateVisuals(); lineLayer.innerHTML = ''; wordDisplay.textContent = ""; currentHighlightedWord = null; }
    
    function drawLine() {
        lineLayer.innerHTML = ''; if (selectedCells.length < 2) return;
        let points = selectedCells.map(idx => { const t = gridEl.children[idx]; return `${t.offsetLeft + t.offsetWidth/2},${t.offsetTop + t.offsetHeight/2}`; }).join(" ");
        const poly = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
        poly.setAttribute("points", points); poly.setAttribute("fill", "none"); poly.setAttribute("stroke", "var(--line-color)"); poly.setAttribute("stroke-width", gridSize >= 10 ? "4" : "8");
        poly.setAttribute("stroke-linecap", "round"); poly.setAttribute("stroke-linejoin", "round");
        lineLayer.appendChild(poly);
    }

    function getVisualIndexFromOriginal(originalIdx, rot) {
        let curr = originalIdx;
        for(let i=0; i<rot; i++) { 
            const r = Math.floor(curr/gridSize), c = curr%gridSize; 
            curr = c*gridSize + (gridSize - 1 - r); 
        }
        return curr;
    }
    function getOriginalIndexFromVisual(visualIdx, rot) {
        let curr = visualIdx; const inverseRot = (4 - (rot % 4)) % 4;
        for(let i=0; i<inverseRot; i++) { 
            const r = Math.floor(curr/gridSize), c = curr%gridSize; 
            curr = c*gridSize + (gridSize - 1 - r); 
        }
        return curr;
    }
    
    function showWordOnGrid(word) {
        if(currentHighlightedWord === word) { clearSelection(); return; }
        if(!foundWords.has(word)) return;
        const data = foundWords.get(word); if(!data.path) return;
        clearSelection(); currentHighlightedWord = word;
        selectedCells = data.path.map(idx => getVisualIndexFromOriginal(idx, rotationIndex));
        updateVisuals();
        selectedCells.forEach(i => gridEl.children[i].classList.add('anim-valid'));
        setTimeout(() => { document.querySelectorAll('.tile').forEach(t=>t.classList.remove('anim-valid')); }, 1500);
    }

    function triggerBusetExplosion() {
        // 1. Aggiungi classe CSS al body per l'effetto terremoto e flash
        document.body.classList.add('mega-win-effect');

        // 2. Fuochi d'artificio infiniti
        if (fireworksInterval) clearInterval(fireworksInterval);
        fireworksInterval = setInterval(() => {
            launchFirework();
            launchFirework();
        }, 150);

        // 3. Ferma tutto dopo 5 secondi (opzionale, altrimenti continua finch√© non finisce la partita)
        setTimeout(() => {
            document.body.classList.remove('mega-win-effect');
            stopFireworks();
        }, 5000);
    }
    function validateWord() {
        const word = wordDisplay.textContent;
        if (isSandboxMode) {
            if (word.length >= MIN_WORD_LENGTH && dictionary.has(word)) {
                // Calcola punti (solo per visualizzazione)
                const pts = calculateScoreWithBonuses(word, selectedCells);                
                // Mostra parola + punti
                wordDisplay.textContent = `${word} (${pts} pt)`; // <--- MODIFICA QUI
					 wordDisplay.style.background = "#2ecc71";
                selectedCells.forEach(i => gridEl.children[i].classList.add('anim-valid'));
                setTimeout(()=>document.querySelectorAll('.tile').forEach(t=>t.classList.remove('anim-valid')),500);
            } else { wordDisplay.style.background = "#e74c3c"; shakeInvalid(); }
				if(errorTimeout) clearTimeout(errorTimeout);
            errorTimeout = setTimeout(() => { wordDisplay.style.background = "#dfe6e9"; clearSelection(); errorTimeout=null;}, 2000);
            return;
        }

        if (word.length < MIN_WORD_LENGTH) { shakeInvalid(); return; }
        if (foundWords.has(word)) { wordDisplay.style.background = "#f1c40f"; setTimeout(()=>wordDisplay.style.background="#dfe6e9",400); return; }

        if (dictionary.has(word)) {
            const pts = calculateScoreWithBonuses(word, selectedCells);
            const originalPath = selectedCells.map(vIdx => getOriginalIndexFromVisual(vIdx, rotationIndex));
            foundWords.set(word, { points: pts, active: true, index: ++wordCounter, path: originalPath });
            
            if (pts >= 10) fireConfetti();
				if (word === "BUSET") {
                triggerBusetExplosion();
            }
            
            // --- TRIGGER BIATCH MODE: RUOTA QUANDO TROVI UNA PAROLA ---
            if (isBiatchMode) {
                    rotateGrid();
                    showBiatchOverlay();
            }
            // ----------------------------------------------------------

            runAchievementCheck(word, pts);

            updateTotalScore();
            selectedCells.forEach(i => gridEl.children[i].classList.add('anim-valid'));
            setTimeout(()=>document.querySelectorAll('.tile').forEach(t=>t.classList.remove('anim-valid')),500);
            wordCountDisplay.textContent = foundWords.size;
            
            const li = document.createElement('li'); li.dataset.word = word;
            li.innerHTML = `<div class="word-item-left"><button class="btn-eye" onclick="showWordOnGrid('${word}')" title="Mostra">üëÅÔ∏è</button><span>${word}</span></div><span class="pts">+${pts}</span>`;
            li.addEventListener('click', (e) => { if(isAnalysisPhase && !e.target.classList.contains('btn-eye')) toggleWord(word, li); });
            wordsListEl.insertBefore(li, wordsListEl.firstChild);
				li.addEventListener('dblclick', () => {
            window.open(`https://www.treccani.it/vocabolario/${word.toLowerCase()}`, '_blank');
            });
            wordDisplay.style.background = "#2ecc71";
        } else { shakeInvalid(); wordDisplay.style.background = "#e74c3c"; }
        setTimeout(()=>wordDisplay.style.background="#dfe6e9",400);
    }

    function calculateScoreWithBonuses(word, cells) {
        let pts = 0;
        if (word.length === 4) pts = 1; else if (word.length === 5) pts = 2; else if (word.length === 6) pts = 3; else if (word.length === 7) pts = 5; else if (word.length >= 8) pts = 11;
        let wordMult = 1; const bonuses = JSON.parse(gridEl.dataset.bonuses);
        cells.forEach(idx => {
            const b = bonuses[idx];
            if(b === "2L") pts += 2; else if(b === "3L") pts += 3; else if(b === "2P") wordMult *= 2; else if(b === "3P") wordMult *= 3;
        });
        return pts * wordMult;
    }
    
	function updateTotalScore() {
	    score = 0; 
	    foundWords.forEach(v => { if(v.active) score += v.points; });
	    scoreDisplay.textContent = score;
	    if(isAnalysisPhase) updateHistoryScore();
	
	    // --- AGGIUNTA PER LIVE SCORE ---
	    if (matchId && db) {
	        db.collection("partite").doc(matchId).update({
	            [`punteggi.${mioNome}`]: score
	        }).catch(err => console.error("Errore aggiornamento score:", err));
	    }
	    // -------------------------------
	}
    
    function toggleWord(w, li) {
        const d = foundWords.get(w); d.active = !d.active;
        li.classList.toggle('deleted', !d.active); li.querySelector('.pts').textContent = d.active ? "+" + d.points : "0";
        updateTotalScore();
		  runAchievementCheck();
    }
    function shakeInvalid() {
		errorCount++;
        selectedCells.forEach(i => gridEl.children[i].classList.add('anim-invalid'));
        setTimeout(()=>document.querySelectorAll('.tile').forEach(t=>t.classList.remove('anim-invalid')),400);
    }

    // --- ACHIEVEMENTS E STATISTICHE ---
    function getStorageData() {
        return JSON.parse(localStorage.getItem('paroliere_data')) || {
            games: [], totalGames: 0, totalScore: 0, highScore: 0, 
            bestWord: "", bestWordVal: 0, bestWordLen: 0, bestWordLenW: "", 
            achievements: []
        };
    }

    function runAchievementCheck(lastWord = null, lastPts = 0) {
        let data = getStorageData();
        const unlockedNow = [];
		  let activeCount = 0;
        foundWords.forEach(v => { if(v.active) activeCount++; });
        const deletedCount = foundWords.size - activeCount;
        const context = {
            stats: {
                totalGames: data.totalGames + (isGameActive ? 0 : 1),
                totalScore: data.totalScore + score,
                highScore: Math.max(data.highScore, score)
            },
            game: {
                score: score,
                wordCount: foundWords.size,
					 deletedCount: deletedCount,
					 rotationCount: rotationCount,
					 errorCount: errorCount,
                elapsedTime: initialTime - timeRemaining,
					 timeRemaining: timeRemaining,
                isOver: !isGameActive,
					 isPaused: isPaused
            },
            last: { word: lastWord, points: lastPts }
        };

        ACHIEVEMENTS.forEach(ach => {
            if (!data.achievements.includes(ach.id)) {
                try {
                    if (ach.check(context)) {
                        data.achievements.push(ach.id);
                        unlockedNow.push(ach.title);
                        showAchievement(ach.title);
                    }
                } catch(e) { console.error("Err ach", ach.id, e); }
            }
        });
        if(unlockedNow.length > 0) localStorage.setItem('paroliere_data', JSON.stringify(data));
    }

    function updateStats() {
        let data = getStorageData();
        let maxLen = 0; let bestLenW = "";
        let maxScore = 0; let bestScoreW = "";

        foundWords.forEach((v, k) => { 
            if(v.active) {
                if(k.length > maxLen) { maxLen = k.length; bestLenW = k; }
                if(v.points > maxScore) { maxScore = v.points; bestScoreW = k; }
            } 
        });

        data.totalGames++;
        data.totalScore += score;
        if(score > data.highScore) data.highScore = score;
        if(maxLen > data.bestWordLen) { data.bestWordLen = maxLen; data.bestWordLenW = bestLenW; }
        if(maxScore > data.bestWordVal) { data.bestWordVal = maxScore; data.bestWord = bestScoreW; }

        const entry = { date: new Date().toLocaleDateString('it-IT', {hour:'2-digit', minute:'2-digit'}), seed: currentSeed, score: score, id: currentGameTimestamp };
        data.games.unshift(entry);
        if(data.games.length > 20) data.games = data.games.slice(0, 20);

        localStorage.setItem('paroliere_data', JSON.stringify(data));
        currentGameTimestamp = Date.now();
        runAchievementCheck(null, 0);
    }
    
	 function showElenaPopup() {
  // usa la stessa grafica della ach-notification ma SENZA confetti
  const box = document.getElementById('ach-notification');
  const txt = document.getElementById('ach-text');
  if (!box || !txt) return;

  txt.textContent = "GRAZIE ELENA PER QUESTA GENIALATA";
  box.classList.add('show');
  fireConfetti(box);
  setTimeout(() => box.classList.remove('show'), 2500);
}
	 
		function showAchievement(text) {
			 const el = document.getElementById('ach-text');
			 const notifBox = document.getElementById('ach-notification');
			 
			 el.textContent = text;
			 notifBox.classList.add('show');
			 
			 setTimeout(() => notifBox.classList.remove('show'), 2000);
			 
			 // Confetti che partono dal centro del box degli achievement
			 fireConfetti(notifBox);
		}

    function openStats() {
        const data = getStorageData();
        document.getElementById('stat-total-games').textContent = data.totalGames;
        document.getElementById('stat-high-score').textContent = data.highScore;
        document.getElementById('stat-total-score').textContent = data.totalScore;
        document.getElementById('stat-best-word').textContent = data.bestWordVal > 0 ? `${data.bestWord} (${data.bestWordVal})` : "-";
        document.getElementById('stat-longest-word').textContent = data.bestWordLen > 0 ? `${data.bestWordLenW} (${data.bestWordLen})` : "-";
        const avg = data.totalGames > 0 ? Math.round(data.totalScore / data.totalGames) : 0;
        document.getElementById('stat-avg-score').textContent = avg; 

        const achDiv = document.getElementById('achievements-list');
        achDiv.innerHTML = ACHIEVEMENTS.map(ach => {
            const unlocked = data.achievements && data.achievements.includes(ach.id);
            return `<div style="padding:5px; margin-bottom:5px; border-radius:4px; background:${unlocked ? 'rgba(39, 174, 96, 0.1)' : 'transparent'}; border-left:3px solid ${unlocked ? '#27ae60' : '#ccc'}">
                <div style="font-weight:bold; color:${unlocked ? '#27ae60' : '#7f8c8d'}">${unlocked ? 'üèÜ' : 'üîí'} ${ach.title}</div>
                <div style="font-size:0.85rem; opacity:0.8;">${ach.desc}</div>
            </div>`;
        }).join('');

        historyListBody.innerHTML = "";
        data.games.forEach(g => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${g.date}</td><td>${g.seed}</td><td style="font-weight:bold; color:var(--primary)">${g.score}</td>`;
            historyListBody.appendChild(tr);
        });
        statsModal.style.display = 'flex';
    }

    function updateHistoryScore() {
        if(!currentGameTimestamp) return;
        let data = getStorageData();
        const index = data.games.findIndex(g => g.id === currentGameTimestamp);
        if(index !== -1) {
             data.games[index].score = score;
             localStorage.setItem('paroliere_data', JSON.stringify(data));
        }
    }
    
    function clearData() {
        if(confirm("Cancellare TUTTI i dati?")) { localStorage.removeItem('paroliere_data'); openStats(); }
    }

    // --- SOLVER & UTILS ---
    function showMissedWords() {
        if(!confirm("L'analisi potrebbe richiedere del tempo. Continuare?")) return;
		  
		  const container = document.querySelector('.game-container');
		  const overlay = document.getElementById('calculation-overlay');
		  
		  container.classList.add('processing-blur');
		  overlay.style.display = 'flex';
		  
		  setTimeout(() => {
				try {
					  const visualLetters = JSON.parse(gridEl.dataset.letters); 
					  const visualBonuses = JSON.parse(gridEl.dataset.bonuses);
                      // Parametric adjacency map for any grid size
					  const adjMap = Array.from({length: gridSize * gridSize}, (_, i) => getNeighbors(i));
					  const possibleWords = [];
					  const start = performance.now();
					  const foundSet = new Set();
                      const maxTime = 10000;
                      const totalCells = gridSize * gridSize;

					  function solve(idx, currentWord, visited, currentPath) {
							if(performance.now() - start > maxTime) return; 
							visited[idx] = true; currentPath.push(idx);
							
							// PRUNING con Trie: se nessuna parola inizia cos√¨, taglia
							if(trieRoot && !hasPrefix(currentWord)) { visited[idx] = false; currentPath.pop(); return; }
							
							if(currentWord.length >= MIN_WORD_LENGTH && dictionary.has(currentWord) && !foundWords.has(currentWord) && !foundSet.has(currentWord)) {
								 foundSet.add(currentWord);
								 const pts = calculateScoreWithBonusesSolver(currentWord, [...currentPath], visualBonuses);
								 possibleWords.push({w: currentWord, p: pts});
							}
							if(currentWord.length >= 12) { visited[idx] = false; currentPath.pop(); return; }
							for(let n of adjMap[idx]) { if(!visited[n]) { let nextChar = visualLetters[n]; if(nextChar === 'Q') nextChar = 'QU'; solve(n, currentWord + nextChar, visited, currentPath); } }
							visited[idx] = false; currentPath.pop();
					  }
					  function calculateScoreWithBonusesSolver(word, cells, bonuses) {
							let pts = 0;
							if (word.length === 4) pts = 1; else if (word.length === 5) pts = 2; else if (word.length === 6) pts = 3; else if (word.length === 7) pts = 5; else if (word.length >= 8) pts = 11;
							let wordMult = 1;
							cells.forEach(idx => { const b = bonuses[idx]; if(b === "2L") pts += 2; else if(b === "3L") pts += 3; else if(b === "2P") wordMult *= 2; else if(b === "3P") wordMult *= 3; });
							return pts * wordMult;
					  }
					  for(let i=0; i<totalCells; i++) { 
                          if(performance.now() - start > maxTime) break;
                          let char = visualLetters[i]; if(char === 'Q') char = 'QU'; 
                          solve(i, char, new Array(totalCells).fill(false), []); 
                      }
					  
                      possibleWords.sort((a,b) => b.p - a.p);
					  const top = possibleWords.slice(0, 10);
					  if(top.length === 0) alert("Hai trovato tutto (o limite di tempo raggiunto)!");
					  else alert("Top 10 parole mancate:\n\n" + top.map(x => `${x.w} (${x.p} pt)`).join('\n'));
            } catch(e) {
                console.error(e);
                alert("Si √® verificato un errore durante il calcolo.");
            } finally {
                container.classList.remove('processing-blur');
                overlay.style.display = 'none';
            }
    }, 100); 
}

    function formatTime(s) { return `${Math.floor(s/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`; }
    function updateTimerDisplay() {
        timerDisplay.textContent = formatTime(timeRemaining);

        // Calcola la percentuale di tempo rimasto (1 = tutto, 0 = scaduto)
        const ratio = Math.max(0, timeRemaining / initialTime);

        // Colore graduale: Verde (120¬∞) ‚Üí Giallo (60¬∞) ‚Üí Rosso (0¬∞)
        const hue = Math.round(ratio * 120); // 120=verde, 60=giallo, 0=rosso
        timerDisplay.style.color = `hsl(${hue}, 85%, 50%)`;

        // Effetto pulsante negli ultimi 10 secondi
        if (timeRemaining <= 10 && timeRemaining > 0) {
            timerDisplay.classList.add('timer-alert');
        } else {
            timerDisplay.classList.remove('timer-alert');
        }
    }
    
    function copySeed() { navigator.clipboard.writeText(currentSeed).then(() => alert("Codice copiato!")); }
	 function copySeedNewGame() { navigator.clipboard.writeText(currentSeed); }
    function pasteAndVerify() {
        const input = prompt("Incolla lista avversaria:"); if(!input) return;
        let c = 0; input.toUpperCase().split(',').forEach(w => {
            w = w.trim();
            if(foundWords.has(w) && foundWords.get(w).active) {
                const lis = document.querySelectorAll('#found-words li');
                lis.forEach(li => { if(li.dataset.word === w) { toggleWord(w, li); c++; } });
            }
        });
        alert(`Eliminate ${c} parole.`);
    }
	  function copyWords() { 
	  // 1. Selezioniamo gli elementi HTML della lista. 
	  // Questo garantisce che l'ordine sia esattamente quello che vedi a schermo (Alfabetico, Punti, ecc.)
	  const listItems = document.querySelectorAll('#found-words li');
	  const exportList = [];

	  listItems.forEach(li => {
			// 2. Controlliamo se la parola ha la classe "deleted" (barrata)
			// Se NON √® cancellata, la aggiungiamo alla lista da copiare
			if (!li.classList.contains('deleted')) {
				 exportList.push(li.dataset.word);
			}
	  });

	  if (exportList.length === 0) {
			alert("Nessuna parola valida da copiare.");
			return;
	  }

	  // 3. Copia negli appunti separando con virgola
	  navigator.clipboard.writeText(exportList.join(',')).then(() => {
			alert(`Copiato! (${exportList.length} parole attive)`);
	  });
    }

	function setSortMode(m) { 
		 sortMode = m; 
		 const btns = document.querySelectorAll('.sort-btn');
		 btns.forEach(b => b.classList.remove('active')); 
		 if(m === 'chrono' && btns[0]) btns[0].classList.add('active');
		 if(m === 'alpha' && btns[1]) btns[1].classList.add('active');
		 if(m === 'score' && btns[2]) btns[2].classList.add('active');
		 sortList(); 
	}
    function toggleSortDirection() { sortDescending = !sortDescending; document.getElementById('sort-dir-btn').textContent = sortDescending ? "‚¨áÔ∏è" : "‚¨ÜÔ∏è"; sortList(); }
    function sortList() {
        const items = Array.from(wordsListEl.children); const m = sortDescending ? 1 : -1;
        items.sort((a,b) => {
            const wA = a.dataset.word, wB = b.dataset.word; const dA = foundWords.get(wA), dB = foundWords.get(wB);
            if(sortMode === 'alpha') return wA.localeCompare(wB) * m;
            if(sortMode === 'score') return (dB.points - dA.points) * m || wA.localeCompare(wB);
            return (dB.index - dA.index) * m;
        });
        wordsListEl.innerHTML = ""; items.forEach(i=>wordsListEl.appendChild(i));
    }

    function closeStats() { statsModal.style.display = 'none'; }
    function openLegend() { legendModal.style.display = 'flex'; }
    function closeLegend() { legendModal.style.display = 'none'; }
    function toggleTheme() { document.body.classList.toggle('dark-mode'); }
    toggleInput.addEventListener('change', () => { clearSelection(); inputMode = toggleInput.checked ? 'click' : 'drag'; btnResetSelection.style.display = inputMode==='click'?'block':'none'; });
    
function fireConfetti(originElement = null) {
    const colors = ['#f1c40f', '#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#ffffff', '#ff00ff'];
    const count = 150; // Quanti confetti? TANTI.

    // Centro di default: centro schermo (come prima)
    let centerXPercent = 50;
    let centerYPercent = 50;

    // Se passo un elemento, uso il suo centro geometrico
    if (originElement) {
        const rect = originElement.getBoundingClientRect();
        centerXPercent = ((rect.left + rect.width / 2) / window.innerWidth) * 100;
        centerYPercent = ((rect.top + rect.height / 2) / window.innerHeight) * 100;
    }

    for (let i = 0; i < count; i++) {
        const p = document.createElement('div');
        p.className = 'confetti';

        // Zona di partenza: intorno al centro calcolato (come il tuo 50% ¬± 10)
        const startX = centerXPercent + (Math.random() - 0.5) * 20; 
        const startY = centerYPercent + (Math.random() - 0.5) * 20;
        
        p.style.position = 'fixed'; // cos√¨ % √® rispetto al viewport
        p.style.left = startX + '%';
        p.style.top = startY + '%';
        p.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        
        // Dimensioni variabili (da piccoli a ENORMI)
        const size = Math.random() * 15 + 5; 
        p.style.width = size + 'px';
        p.style.height = size + 'px';
        
        // Forma casuale (quadrati o cerchi)
        if (Math.random() > 0.5) p.style.borderRadius = '50%';
        
        p.style.zIndex = '10000';
        p.style.pointerEvents = 'none';

        document.body.appendChild(p);

        // Calcolo traiettoria esplosiva
        const angle = Math.random() * Math.PI * 2;
        const velocity = 200 + Math.random() * 400; // Esplosione potente
        const tx = Math.cos(angle) * velocity;
        const ty = Math.sin(angle) * velocity;
        const rot = (Math.random() - 0.5) * 1000; // Rotazione pazza

        p.animate([
            { transform: `translate(0,0) rotate(0deg) scale(1)`, opacity: 1 },
            { transform: `translate(${tx}px, ${ty}px) rotate(${rot}deg) scale(0.5)`, opacity: 0 }
        ], {
            // Allunghiamo un po' rispetto all‚Äôoriginale, per farli durare di pi√π
            duration: 2000 + Math.random() * 1500, 
            easing: 'cubic-bezier(0.25, 1, 0.5, 1)'
        }).onfinish = () => p.remove();
    }
}

    function startEndGameCelebration() {
        // Se ce n'era uno attivo, fermalo prima
        if(fireworksInterval) clearInterval(fireworksInterval);
        
        let count = 0;
        fireworksInterval = setInterval(() => {
            launchFirework();
            launchFirework();
            count++;
            // Limite di sicurezza (es. 40 cicli)
            if(count > 40) stopFireworks(); 
        }, 200);
    }
    
    function stopFireworks() {
        if(fireworksInterval) {
            clearInterval(fireworksInterval);
            fireworksInterval = null;
        }
    }

    function launchFirework() {
        const colors = ['#ff0044', '#ffff00', '#00ff44', '#00ccff', '#ff00ff'];
        
        // Posizione di partenza casuale in basso
        const startX = Math.random() * window.innerWidth;
        const startY = window.innerHeight;
        
        // Punto di esplosione (casuale nella met√† alta dello schermo)
        const endX = startX + (Math.random() - 0.5) * 200;
        const endY = window.innerHeight * 0.2 + Math.random() * window.innerHeight * 0.4;
        const color = colors[Math.floor(Math.random() * colors.length)];

        // 1. Il razzo che sale
        const rocket = document.createElement('div');
        rocket.style.position = 'fixed';
        rocket.style.left = startX + 'px';
        rocket.style.top = startY + 'px';
        rocket.style.width = '4px';
        rocket.style.height = '12px';
        rocket.style.background = color;
        rocket.style.borderRadius = '2px';
        rocket.style.zIndex = '9998';
        document.body.appendChild(rocket);

        rocket.animate([
            { transform: `translate(0, 0)` },
            { transform: `translate(${endX - startX}px, ${endY - startY}px)` }
        ], {
            duration: 1000,
            easing: 'ease-out'
        }).onfinish = () => {
            rocket.remove();
            explode(endX, endY, color); // Esplosione!
        };

        // 2. L'esplosione
        function explode(x, y, color) {
            for (let i = 0; i < 80; i++) { //quanti pallini colorati per questa singola esplosione
                const p = document.createElement('div');
                p.style.position = 'fixed';
                p.style.left = x + 'px';
                p.style.top = y + 'px';
                p.style.width = '6px';
                p.style.height = '6px';
                p.style.backgroundColor = color;
                p.style.borderRadius = '50%';
                p.style.zIndex = '9998';
                
                // Fisica particella
                const angle = Math.random() * Math.PI * 2;
                const velocity = Math.random() * 100; //quanto distanti vanno dal centro
                const tx = Math.cos(angle) * velocity;
                const ty = Math.sin(angle) * velocity;
                
                document.body.appendChild(p);

                p.animate([
                    // START: Centro
                    { transform: `translate(0,0) scale(1)`, opacity: 1, offset: 0 },
                    
                    // FASE 1: ESPLOSIONE SFERICA
                    // I pallini raggiungono la massima espansione in tutte le direzioni
                    { transform: `translate(${tx}px, ${ty}px) scale(0.9)`, opacity: 0.9, offset: 0.2 },
                    
                    // FASE 2: CADUTA LENTA (dal 20% al 100%)
                    // Mantengono la posizione orizzontale (tx) ma cadono in verticale (ty + gravit√†)
                    { transform: `translate(${tx}px, ${ty + 500}px) scale(0)`, opacity: 0, offset: 1 }
                ], {
                    duration: 2000 + Math.random() * 2000,
                    easing: 'linear' // Usiamo linear perch√© controlliamo noi il movimento con i keyframes
                }).onfinish = () => p.remove();
            }
        }
    }

		function showBiatchOverlay() {
			 // Easter Egg 1: Messaggio a schermo gigante
			 const texts = ["GIRA BIATCH!", "OPS!", "DI QUA!", "MUOVITI!", "üê∑üê∑üê∑"];
			 const overlay = document.createElement('div');
			 overlay.style = "position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); font-size:5rem; font-weight:900; color:#ff00ff; z-index:10000; pointer-events:none; text-shadow: 5px 5px 0px black;";
			 overlay.textContent = texts[Math.floor(Math.random() * texts.length)];
			 document.body.appendChild(overlay);
			 
			 // Easter Egg 2: Confetti fucsia ad ogni giro
			 fireConfetti(overlay); 

			 setTimeout(() => overlay.remove(), 800);
		}

    // CHIUSURA MODAL CLICCANDO FUORI
    window.addEventListener('click', (e) => {
        // Se clicco sullo sfondo scuro (overlay)
        if (e.target.classList.contains('modal-overlay')) {
            
            // 1. Se sto chiudendo il modale di fine partita, FERMA I FUOCHI
            if (e.target.id === 'game-end-modal') {
                stopFireworks();
            }

            // 2. Chiudi il modale cliccato
            e.target.style.display = 'none';
        }
    });
		document.addEventListener('visibilitychange', () => {
			 if (document.hidden && isGameActive && !isPaused && !isSandboxMode) togglePause();
		});
    // Sostituisci la parte finale (dove c'√® loadDictionary) con questo:

async function avviaPartitaSincronizzata() {
    // Prima carichiamo il dizionario
    await loadDictionary();

    if (matchId) {
        // Se c'√® un matchId, leggiamo i dati dal database
        db.collection("partite").doc(matchId).onSnapshot(doc => {
            const p = doc.data();
            
            // Se il gioco non √® ancora iniziato, impostiamo tutto
            if (!isGameActive && !isAnalysisPhase && !isPaused) {
                gridSize = parseInt(p.opzioni.griglia);
                timeRemaining = parseInt(p.opzioni.tempo);
                initialTime = timeRemaining;
                currentSeed = p.opzioni.seed;
                useBonuses = (p.opzioni.mode !== 'classic');
                isCrazyMode = (p.opzioni.mode === 'crazy');
                
                // Avvia la griglia con i dati del database
                initGame(currentSeed);
            }

            // Mostriamo il punteggio dell'avversario a video
            let avversarioNome = p.partecipanti.find(n => n !== mioNome);
            let scoreAvv = p.punteggi[avversarioNome] || 0;
            
            let displayAvv = document.getElementById('live-opponent-score');
            if(!displayAvv) {
                // Crea il widget del punteggio avversario se non esiste
                const timerCont = document.querySelector('.status-bar');
                timerCont.insertAdjacentHTML('beforeend', `<div id="live-opponent-score" style="color:#e74c3c; font-size:0.9rem;">üÜö ${avversarioNome}: 0</div>`);
                displayAvv = document.getElementById('live-opponent-score');
            }
            displayAvv.textContent = `üÜö ${avversarioNome}: ${scoreAvv}`;
        });
    } else {
        // Se apri ruzzle.html da solo (senza sfida), carica normalmente
        // (Opzionale: puoi anche decidere di reindirizzare alla dashboard)
        console.log("Nessuna sfida rilevata, modalit√† libera.");
    }
}

// Avviamo tutto
avviaPartitaSincronizzata();
</script>
</body>

</html>
