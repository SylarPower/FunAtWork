<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ruzzle dei üê∑</title>
	<script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-app-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-firestore-compat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');

        :root {
            /* LIGHT THEME */
            --primary: #3498db;
            --accent: #e74c3c;
            --bg: #ecf0f1;
            --text-main: #2c3e50;
            --tile-bg: #fff;
            --tile-text: #34495e;
            --tile-shadow: #95a5a6;
            --tile-selected: #f1c40f;
            --tile-valid: #2ecc71;
            --panel-bg: #fff;
            --item-bg: #f8f9fa;
            --line-color: rgba(44, 62, 80, 0.8);
            --overlay-bg: rgba(44, 62, 80, 0.98);
            
            /* Variabile Dinamica per le colonne della griglia */
            --grid-cols: 5; 
        }

        body.dark-mode {
            /* DARK THEME */
            --primary: #3498db;
            --accent: #ff6b6b;
            --bg: #121212;
            --text-main: #ecf0f1;
            --tile-bg: #2c3e50;
            --tile-text: #ecf0f1;
            --tile-shadow: #000;
            --tile-selected: #f39c12;
            --tile-valid: #27ae60;
            --panel-bg: #1e1e1e;
            --item-bg: #2d2d2d;
            --line-color: rgba(241, 196, 15, 0.8);
            --overlay-bg: rgba(0, 0, 0, 0.95);
        }

        @keyframes earthquake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        @keyframes disco-flash {
            0% { background-color: #e74c3c; }
            25% { background-color: #f1c40f; }
            50% { background-color: #2ecc71; }
            75% { background-color: #9b59b6; }
            100% { background-color: #3498db; }
        }

		@keyframes pulse-ready {
			 0%, 100% { 
				  transform: scale(1); 
				  box-shadow: 0 8px 25px rgba(3, 218, 198, 0.4);
			 }
			 50% { 
				  transform: scale(1.05); 
				  box-shadow: 0 12px 35px rgba(3, 218, 198, 0.6);
			 }
		}
		
		@keyframes urgentPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); color: red; } }
		@keyframes pulseGreen { 0% { background: var(--tile-valid); } 100% { background: var(--tile-bg); } }
       @keyframes shakeRed { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); background: var(--accent); } 75% { transform: translateX(5px); } }
		@keyframes pulseBtn {
			0%, 100% { transform: scale(1); }
			50% { transform: scale(1.05); box-shadow: 0 0 25px rgba(231, 76, 60, 0.8); }
		}
		@keyframes popIn {
			0% { transform: scale(0); opacity: 0; }
			60% { transform: scale(1.1); opacity: 1; }
			100% { transform: scale(1); }
		}
		@keyframes slideDown {
		    from { transform: translateY(-100%); }
		    to { transform: translateY(0); }
		}
        body.mega-win-effect {
            animation: earthquake 0.5s infinite, disco-flash 0.5s infinite;
        }
        /* ----------------------------------- */

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            display: flex; flex-direction: column; align-items: center;
            min-height: 100vh; margin: 0; padding: 10px;
            overflow-x: hidden; transition: background 0.3s, color 0.3s;
        }

        /* LAYOUT GLOBALE */
        .app-wrapper {
            width: 100%; max-width: 875px;	
            display: flex;flex-direction: column; padding: 0 10px;
        }

        /* HEADER ALLINEATO */
        .header-bar {
            display: flex; justify-content: space-between; align-items: center;
            width: 100%; margin-bottom: 10px;
        }
        h1 { margin: 0; font-size: 1.5rem; text-transform: uppercase; letter-spacing: 1px; color: var(--text-main); }

        .theme-btn {
            background: none; border: none; font-size: 1.5rem; cursor: pointer;
            padding: 5px; border-radius: 50%; transition: background 0.2s;
        }
        .theme-btn:hover { background: rgba(0,0,0,0.1); }
        body.dark-mode .theme-btn:hover { background: rgba(255,255,255,0.1); }

        .game-container {
            display: flex; flex-direction: column; gap: 20px; align-items: center;
            max-width: 950px; width: 100%; height: auto;
        }

        @media (min-width: 850px) {
            .game-container { 
                flex-direction: row; 
                align-items: stretch; 
                justify-content: center; 
                gap: 40px; 
            }
            .board-wrapper { flex: 0 0 450px; } 
            .sidebar { flex: 1; }
        }

        /* CONFIG BAR */
        .config-bar {
            width: 100%; background: var(--panel-bg); padding: 15px; border-radius: 10px;
            margin-bottom: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex; flex-direction: column; gap: 12px;
        }
        .config-row { display: flex; justify-content: space-between; align-items: center; }
        
        .code-display {
            font-family: monospace; font-weight: bold; font-size: 1.1rem;
            color: var(--primary); background: var(--bg); padding: 6px 10px; border-radius: 4px;
            cursor: pointer; border: 1px solid #ccc;
        }

        select { padding: 5px; border-radius: 4px; background: var(--bg); color: var(--text-main); border: 1px solid #7f8c8d; }

        /* BOARD AREA */
        .board-wrapper {
            display: flex; flex-direction: column; width: 100%;
        }

        .status-bar {
            display: flex; justify-content: space-between; width: 100%;
            margin-bottom: 8px; font-weight: bold; font-size: 1.2rem; align-items: center;
        }
        #timer { color: var(--accent); font-feature-settings: "tnum"; }
        .timer-alert { animation: urgentPulse 0.8s infinite; font-weight: 900; }

        #current-word {
            height: 45px; display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; font-weight: 900; color: #2c3e50;
            background: #dfe6e9; width: 100%; border-radius: 8px; margin-bottom: 15px;
            text-transform: uppercase; letter-spacing: 2px; position: relative; z-index: 2;
        }

        .grid-container { position: relative; width: 100%; aspect-ratio: 1 / 1; touch-action: none; }
        #line-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }

        .grid {
            display: grid; 
            /* MODIFICA: Colonne dinamiche */
            grid-template-columns: repeat(var(--grid-cols), 1fr); 
            gap: 6px;
            background: #95a5a6; padding: 6px; border-radius: 10px;
            width: 100%; height: 100%; box-sizing: border-box; user-select: none;
        }

        /* TILES */
        .tile {
            background-color: var(--tile-bg); border-radius: 6px;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.8rem; font-weight: bold; color: var(--tile-text);
            cursor: pointer; box-shadow: 0 3px 0 var(--tile-shadow);
            position: relative; z-index: 2; user-select: none;
            transition: transform 0.2s ease, background-color 0.2s;
        }
        /* Stili specifici per griglie dense */
        .tile.small-font { font-size: 0.9rem; border-radius: 3px; box-shadow: 0 1px 0 var(--tile-shadow); }
        .tile.medium-font { font-size: 2.2rem; } /* Per 4x4 */

			.tile.five-font { font-size: 1.8rem; }

        /* Stile per la griglia 6x6 */
        .tile.six-font { font-size: 1.55rem; }
        .tile.six-font .bonus-badge { font-size: 0.58rem; padding: 1px 3px; }

        /* Stile per la griglia 7x7 */
        .tile.compact-font { font-size: 1.35rem; }
        .tile.compact-font .bonus-badge { font-size: 0.55rem; padding: 1px 3px; }

        .tile.blurred { color: transparent; text-shadow: 0 0 10px rgba(0,0,0,0.5); }
        .tile.selected { background-color: var(--tile-selected); transform: translateY(2px); box-shadow: 0 1px 0 var(--tile-shadow); color: #fff; }
        .tile.anim-valid { animation: pulseGreen 0.5s; }
        .tile.anim-invalid { animation: shakeRed 0.4s; }

        .bonus-badge {
            position: absolute; top: 2px; right: 2px;
            font-size: 0.6rem; font-weight: 900; padding: 2px 4px;
            border-radius: 3px; color: white; line-height: 1; pointer-events: none;
        }
        /* Badge pi√π piccoli per la 10x10 */
        .tile.small-font .bonus-badge { font-size: 0.5rem; padding: 1px 2px; top: 1px; right: 1px; }

        .b-2l { background: #3498db; }
        .b-3l { background: #2980b9; }
        .b-2p { background: #e67e22; }
        .b-3p { background: #e74c3c; }

        .rotate-btn {
            background: none; border: none; font-size: 1.5rem; cursor: pointer;
            transition: transform 0.2s; padding: 5px; color: var(--text-main);
        }
        .rotate-btn:hover { transform: rotate(90deg); }

        /* SIDEBAR */
        .sidebar {
            width: 100%; max-width: 400px; background: var(--panel-bg);
            padding: 15px; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            display: flex; flex-direction: column; position: relative;
            min-height: 600px; 
        }
        @media (max-width: 800px) { .sidebar { flex: 1; min-height: 500px; } }

        .score-box-container { 
            position: relative; text-align: center; 
            border-bottom: 2px solid var(--bg); padding-bottom: 10px; margin-bottom: 10px; 
        }
        .score-box { display: inline-block; }
        .score-val { font-size: 2.2rem; color: var(--primary); font-weight: bold; line-height: 1.1; }
        .info-btn { 
            position: absolute; right: 0; top: 0;
            width: 24px; height: 24px; border-radius: 50%; background: #95a5a6; color: white; 
            border: none; font-weight: bold; cursor: pointer; 
        }

        .words-list { flex: 1; overflow-y: auto; list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 5px; min-height: 0; transition: filter 0.3s; }
        .words-list.blurred-list { filter: blur(8px); pointer-events: none; user-select: none; }

        .words-list li {
            padding: 8px 10px; background: var(--item-bg); border-radius: 4px; display: flex; justify-content: space-between; align-items: center;
            transition: all 0.2s; border: 1px solid transparent;
        }
        .words-list li.deleted { text-decoration: line-through; opacity: 0.5; }
        .words-list li.missed { border-left: 4px solid var(--accent); background: rgba(231, 76, 60, 0.1); }
        .words-list.interactive li:hover { background: #ffe0b2; color: #333; }

        .word-item-left { display: flex; align-items: center; gap: 8px; }
        .btn-eye { 
            background: none; border: none; cursor: pointer; font-size: 1.1rem; padding: 0;
            opacity: 0.5; transition: all 0.2s; display: flex; align-items: center;
        }
        .btn-eye:hover { opacity: 1; transform: scale(1.2); }

        /* COMMON UI BUTTONS */
.btn-action {
    width: 100%; 
    padding: 12px; 
    font-size: 0.9rem; 
    border: none; 
    border-radius: 6px;
    color: white; 
    cursor: pointer; 
    font-weight: bold; 
    text-transform: uppercase; 
    margin-top: 10px;
}

.btn-new { background-color: #34495e; }
.btn-reset { background-color: #e67e22; display: none; }
.btn-end-now { background-color: var(--accent); display: none; }
.btn-pause { background-color: #f39c12; }
.btn-sandbox { background-color: #95a5a6; display: none; }

.btn-history { background-color: #8e44ad; }

.btn-missed { 
    background-color: #16a085; 
    margin-bottom: 5px; 
    margin-top: 0;
    display: none; 
}

        .btn-group { display: flex; gap: 10px; width: 100%; margin-top: 10px; flex-shrink: 0;}
        .game-controls { display: flex; gap:10px; margin-top: 10px; }
        .game-controls .btn-action { margin-top: 0; }
        
        .btn-action:hover { filter: brightness(1.1); }

        /* SWITCH */
        .switch-container { display: flex; align-items: center; font-size: 0.9rem; }
        .switch { position: relative; display: inline-block; width: 40px; height: 22px; margin-left: 10px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 22px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary); }
        input:checked + .slider:before { transform: translateX(18px); }

        /* MODALS */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 3000;
            display: none; justify-content: center; align-items: center;
        }
        .modal-content {
            background: var(--panel-bg); padding: 25px; border-radius: 10px;
            width: 90%; max-width: 500px; max-height: 85vh; overflow-y: auto;
            position: relative; display: flex; flex-direction: column; color: var(--text-main);
        }
        .close-modal { position: absolute; top: 10px; right: 15px; font-size: 2rem; cursor: pointer; line-height: 1; }
        
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
        .stat-card { background: var(--item-bg); padding: 10px; border-radius: 8px; text-align: center; }
        .stat-val { font-size: 1.2rem; font-weight: bold; color: var(--primary); display:block; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
        .stat-label { font-size: 0.75rem; opacity: 0.8; }

        .legend-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .legend-table th, .legend-table td { border-bottom: 1px solid #ccc; padding: 8px; text-align: left; }
        
        .history-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .history-table th, .history-table td { border-bottom: 1px solid #ccc; padding: 8px; text-align: left; font-size: 0.9rem;}
        
        .sort-controls { display: none; justify-content: center; gap: 8px; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px dashed #ccc; flex-shrink: 0; }
        .sort-btn { background: var(--item-bg); border: 1px solid #ccc; padding: 6px 10px; border-radius: 4px; cursor: pointer; color: var(--text-main); }
        .sort-btn.active { background: var(--primary); color: white; border-color: var(--primary); }

        #grid-overlay {
            position: absolute; inset: 0; background: var(--overlay-bg); border-radius: 10px;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 20; color: white; text-align: center;
        }

        #pause-overlay {
            position: absolute; inset: 0; background: var(--bg); border-radius: 10px;
            display: none; justify-content: center; align-items: center;
            z-index: 50; color: var(--text-main); font-size: 2rem; font-weight: bold; letter-spacing: 2px;
            flex-direction: column; gap: 10px;
        }
#wait-banner {
    animation: slideDown 0.3s ease;
}
		#wait-banner button:active {
    transform: scale(0.95) !important;
}
        #btn-via {
            width: 100px; height: 100px; border-radius: 50%; background: #e74c3c; border: 4px solid white;
            color: white; font-size: 1.8rem; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 15px rgba(0,0,0,0.5); animation: pulseBtn 1.5s infinite; margin-top: 15px;
        }
        
        .confetti { position: fixed; width: 10px; height: 10px; z-index: 9999; pointer-events: none; }
        .bonus-legend-item { display:flex; align-items:center; gap:10px; margin-bottom:5px; }
        
        #loading-msg {
            position: fixed; inset: 0; background: var(--bg);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-size: 1.2rem; font-weight: bold; color: var(--primary); z-index: 5000;
        }
			#ach-notification {
				 position: absolute; /* Ora √® assoluto rispetto alla sidebar */
				 top: 50%; left: 50%; /* Centrato nella sidebar */
				 transform: translate(-50%, -50%) scale(0);
				 width: 90%; /* Occupa quasi tutta la larghezza della sidebar */
				 
				 background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%); /* Verde brillante */
				 color: white;
				 padding: 15px;
				 border-radius: 10px;
				 font-weight: bold;
				 font-size: 1.1rem; /* Font pi√π piccolo per starci dentro */
				 z-index: 100; /* Sopra la lista parole */
				 box-shadow: 0 5px 15px rgba(0,0,0,0.3);
				 text-align: center;
				 border: 2px solid white;
				 transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
				 display: flex; flex-direction: column; align-items: center; gap: 5px;
				 pointer-events: none; /* Cos√¨ puoi cliccare sotto se serve */
			}

			#ach-notification.show { 
				 transform: translate(-50%, -50%) scale(1); 
			}
        
		 /* MODAL FINE PARTITA - STILE EPICO */
		 #game-end-modal .modal-content {
			  /* Gradiente diverso dagli achievement (Blu/Viola/Indaco) */
			  background: linear-gradient(135deg, #2c3e50 0%, #2980b9 50%, #8e44ad 100%);
			  color: white;
			  
			  /* Bordo e Ombre come richiesto */
			  border: 6px solid white;
			  box-shadow: 0 0 60px rgba(52, 152, 219, 0.6), 0 0 0 15px rgba(255, 255, 255, 0.1);
			  border-radius: 25px;
			  
			  /* Dimensioni e layout */
			  max-width: 450px;
			  width: 90%;
			  padding: 40px 20px;
			  text-align: center;
			  
			  /* Animazione ingresso */
        animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
		      margin: auto; 

		 }

		 /* Rimuoviamo lo sfondo grigio dal box del punteggio per farlo stare bene sul gradiente */
		 #game-end-modal .score-container-inner {
			  background: rgba(0, 0, 0, 0.2); /* Sfondo semitrasparente scuro */
			  padding: 20px;
			  border-radius: 15px;
			  margin-bottom: 25px;
			  border: 1px solid rgba(255,255,255,0.2);
		 }

		 /* Bottone speciale per il modale finale */
		 #game-end-modal .btn-action {
			  background: white;
			  color: #2980b9;
			  font-size: 1.1rem;
			  font-weight: 900;
			  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
			  transition: transform 0.2s;
		 }
		 #game-end-modal .btn-action:hover {
			  transform: scale(1.05);
			  background: #ecf0f1;
		 }
		.btn-fancy {
		    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
		    color: white;
		    border: none;
		    padding: 15px 40px;
		    border-radius: 50px;
		    font-weight: 900;
		    font-size: 1.1rem;
		    cursor: pointer;
		    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
		    transition: all 0.3s ease;
		    text-transform: uppercase;
		    letter-spacing: 1px;
		}
		
		.btn-fancy:hover {
		    transform: translateY(-3px);
		    box-shadow: 0 12px 35px rgba(102, 126, 234, 0.6);
		}
		
		.btn-fancy:active {
		    transform: translateY(0);
		}
		
		.btn-fancy.gold {
		    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
		    box-shadow: 0 8px 25px rgba(245, 87, 108, 0.4);
		}

		.btn-fancy.gold:hover {
		    box-shadow: 0 15px 40px rgba(241, 196, 15, 0.7);
		} 

		.header-bar button {
		    background: linear-gradient(135deg, #3498db 0%, #2c3e50 100%) !important;
		    padding: 10px 20px !important;
		    border-radius: 25px !important;
		    font-weight: 700 !important;
		    font-size: 0.9rem !important;
		    box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3) !important;
		    transition: all 0.3s ease !important;
		}
		
		.header-bar button:hover {
		    transform: translateY(-2px);
		    box-shadow: 0 6px 20px rgba(52, 152, 219, 0.5) !important;
		}
        /* Aggiungi un sottotitolo all'achievement nel JS se vuoi, o usa quello esistente */
        #ach-text { text-shadow: 2px 2px 0px rgba(0,0,0,0.2); }

        .processing-blur {
             filter: blur(8px);
             pointer-events: none;
             user-select: none;
             transition: filter 0.3s ease;
        }
        
		   #start-screen {
            position: absolute; inset: 0; 
            background: var(--panel-bg); 
            border-radius: 10px;
            display: flex; flex-direction: column; 
            justify-content: center; align-items: center;
            z-index: 100; /* Sopra a tutto */
            color: var(--text-main); 
            text-align: center;
            padding: 20px;
        }
		  
        #calculation-overlay {
             position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999;
             display: none; justify-content: center; align-items: center; flex-direction: column;
        }
        #calculation-overlay .msg-box {
             background: rgba(0, 0, 0, 0.8); color: white; padding: 20px 40px; border-radius: 10px;
             font-size: 1.5rem; font-weight: bold; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body class="dark-mode">
	<!-- INNESTO 1: LOBBY MULTIPLAYER -->
<div id="multiplayer-lobby" style="position:fixed; inset:0; background:rgba(0,0,0,0.98); z-index:10000; display:none; flex-direction:column; justify-content:center; align-items:center; text-align:center; color:white;">
    <h1 id="lobby-title" style="font-size:3rem; margin-bottom:10px;">SALA D'ATTESA üê∑</h1>
    <p id="lobby-info" style="opacity:0.8;">Sincronizzazione sfida in corso...</p>
    <div id="lobby-status" style="margin: 30px; font-size: 1.5rem; color: #03dac6; font-weight:bold;"></div>
    <div id="lobby-action"></div>
</div>
<div id="calculation-overlay">
    <div class="msg-box">üß† Calcolo Soluzioni...</div>
</div>
<div id="loading-msg">
    Caricamento Dizionario...
    <div style="font-size:0.9rem; color:#777; margin-top:10px; font-weight:normal;">(Database parole)</div>
</div>

<div class="app-wrapper">
    <!-- Header Allineato -->
	<div class="header-bar">
	    <div style="display:flex; align-items:center; gap:15px;">
	        <button onclick="tornaHome()" style="background:#34495e; color:white; border:none; border-radius:5px; padding:8px 12px; cursor:pointer; font-weight:bold;">üè† HOME</button>
	        <h1>Ruzzle dei üê∑</h1>
	    </div>
	    <button class="theme-btn" onclick="toggleTheme()" title="Cambia Tema">üåó</button>
	</div>

    <div class="game-container">
        
        <div class="board-wrapper">
            <!-- Configurazione -->
            <div class="config-bar">
                <div class="config-row">
                    <span style="font-weight:bold; opacity:0.8;">Codice:</span>
                    <span class="code-display" id="display-seed" onclick="copySeed()" title="Copia">----</span>
                </div>
                <div class="config-row">
                    <div class="switch-container">Modalit√† Click <label class="switch"><input type="checkbox" id="input-mode-toggle"><span class="slider"></span></label></div>
                </div>
            </div>

            <div class="status-bar">
                <span>Tempo: <span id="timer">03:00</span></span>
					 <span>Trovabili: <span id="possible-count" style="opacity:0.6;">...</span></span>
                <button id="manual-rotate-btn" class="rotate-btn" onclick="rotateGrid()" title="Ruota Griglia">üîÑ</button>
            </div>
            
            <div id="current-word"></div>

				<div class="grid-container">
					 <svg id="line-layer" width="100%" height="100%"></svg>
					 
					 <div id="start-screen">
						  <div style="font-size:3rem; margin-bottom:10px;">üé≤</div>
						  <h2>BENVENUTO</h2>
						  <p style="margin-bottom:20px; opacity:0.8;">Inizia una nuova sfida o unisciti a un amico</p>
					 </div>
					 <!-- --------------------------------- -->

					 <div id="grid-overlay">
                    <div style="font-size:1rem;">Codice: <span id="overlay-seed" style="color:#f1c40f; font-weight:bold;"></span></div>
                    <div style="margin-top:5px; font-size:0.9rem; opacity:0.8;">Premi VIA per svelare</div>
                    <button id="btn-via" onclick="startRound()">VIA!</button>
                </div>
                <!-- PAUSA: OPACO -->
                <div id="pause-overlay">
                    <div>‚è∏Ô∏è IN PAUSA</div>
                    <div style="font-size:0.9rem; opacity:0.7;">Premi RIPRENDI per continuare</div>
                </div>
                <div class="grid" id="grid"></div>
            </div>
            
            <!-- CONTROLLI PARTITA -->
            <div id="in-game-controls" class="game-controls" style="display:none;">
                <button id="btn-pause" class="btn-action btn-pause" onclick="togglePause()">PAUSA</button>
                <button id="btn-terminate" class="btn-action btn-end-now" onclick="endGameManually()">TERMINA ORA</button>
            </div>
            
            <button id="btn-sandbox" class="btn-action btn-sandbox" onclick="startSandbox()">SBLOCCA GRIGLIA (LIBERA)</button>
            <button id="btn-reset-selection" class="btn-action btn-reset" onclick="clearSelection()">AZZERA SELEZIONE</button>
            
            <div class="btn-group">
                <button class="btn-action btn-new" onclick="startNewGame()">NUOVA</button>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <div class="score-box-container">
                <div class="score-box">
                  <div style="font-size:0.8rem; font-weight:bold;">PUNTEGGIO</div>
                  <div class="score-val" id="total-score">0</div>
						<div id="live-opponent-score" style="color: #ff4081; font-weight: 900; font-size: 1.1rem; margin-top:10px;"></div>
                </div>
                <button class="info-btn" onclick="openLegend()" title="Legenda">i</button>
            </div>
            <!-- INNESTO SIDEBAR: Campo proposta nuove parole -->
<div id="proposta-manuale-container" style="display:none; background:rgba(3,218,198,0.1); padding:10px; border-radius:8px; margin-bottom:10px; border:1px dashed #03dac6;">
    <input type="text" id="input-nuova-parola" placeholder="Parola non letta? Scrivila..." style="width:100%; margin:0; font-size:0.8rem; text-transform:uppercase;">
    <button onclick="proponiParolaManuale()" style="width:100%; margin-top:5px; padding:5px; background:#03dac6; color:black; font-size:0.7rem; border-radius:4px; font-weight:bold;">PROPONI AGGIUNTA üì¢</button>
</div>
            <div style="display:flex; justify-content:space-between; font-weight:bold; margin-bottom:5px; flex-shrink:0;">
                <span>Parole: <span id="word-count">0</span></span>
            </div>

            <!-- Sort -->
            <div class="sort-controls" id="sort-controls">
                <button class="sort-btn" title="Cronologico" onclick="setSortMode('chrono')">üïí</button>
                <button class="sort-btn active" title="Alfabetico" onclick="setSortMode('alpha')">üî§</button>
                <button class="sort-btn" title="Punteggio" onclick="setSortMode('score')">üèÜ</button>
                <button class="sort-btn" title="Ordinamento" onclick="toggleSortDirection()" id="sort-dir-btn">‚¨áÔ∏è</button>
            </div>

            <div style="font-size:0.8rem; color:var(--accent); margin-bottom:5px; display:none; flex-shrink:0;" id="analysis-msg">Clicca per eliminare una parola</div>
            <div id="ach-notification">üèÜ <span id="ach-text">Obiettivo Sbloccato!</span></div>
            <ul class="words-list" id="found-words"></ul>
            
            <button id="btn-missed" class="btn-action btn-missed" onclick="showMissedWords()">üîç COSA MI SONO PERSO?</button>
            <button class="btn-action btn-history" onclick="openStats()">STORICO & STATS</button>
        </div>

    </div>
</div>

<div id="new-game-modal" class="modal-overlay">
    <div class="modal-content" style="text-align:center;">
        <span class="close-modal" onclick="closeNewGameModal()">&times;</span>
        <h2>Nuova Partita</h2>
        
        <div style="margin-bottom: 20px;">
            <label for="modal-timer-select" style="font-weight:bold; display:block; margin-bottom:5px;">Durata:</label>
            <select id="modal-timer-select" style="width: 100%; padding: 8px; font-size: 1rem;">
                <option value="45">45s (Fulmine)</option>
					 <option value="60">60s (Blitz)</option>
                <option value="90">90s</option>
                <option value="180" selected>180s (Standard)</option>
                <option value="300">300s (Relax)</option>
            </select>
        </div>

        <!-- NUOVO SELETTORE GRIGLIA -->
        <div style="margin-bottom: 20px;">
            <label for="modal-grid-select" style="font-weight:bold; display:block; margin-bottom:5px;">Dimensione Griglia:</label>
				<select id="modal-grid-select" style="width: 100%; padding: 8px; font-size: 1rem;">
					 <option value="4">4x4 (Easy)</option>
					 <option value="5" selected>5x5 (Classica)</option>
					 <option value="6">6x6 (Intermedia)</option>
					 <option value="7">7x7 (Grande)</option>
					 <option value="10">10x10 (Estrema!)</option>
				</select>
        </div>

        <p style="margin-bottom:20px; color:var(--text-main);">Scegli la modalit√† di gioco:</p>
        
		<div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
			 <!-- confirmNewGame(Bonus, Crazy, Biatch) -->
			 <button class="btn-action" style="background:#7f8c8d; width:auto; padding:15px 30px; margin-top:0;" onclick="confirmNewGame(false, false, false)">CLASSICA</button>
			 <button class="btn-action" style="background:#e67e22; width:auto; padding:15px 30px; margin-top:0;" onclick="confirmNewGame(true, false, false)">BONUS ‚≠ê</button>
			 <button class="btn-action" style="background:#9b59b6; width:auto; padding:15px 30px; margin-top:0;" onclick="confirmNewGame(true, true, false)">CRAZY ü§™</button>
			 <button class="btn-action" style="background:#ff00ff; color:white; width:auto; padding:15px 30px; margin-top:0;" onclick="confirmNewGame(true, true, true)">BIATCH üíÖ</button>
		</div>
    </div>
</div>

<!-- Modal Storico & Stats -->
<div id="stats-modal" class="modal-overlay">
    <div class="modal-content">
        <span class="close-modal" onclick="closeStats()">&times;</span>
        <h2>Statistiche</h2>
        
        <div class="stats-grid">
            <div class="stat-card"><span class="stat-val" id="stat-total-games">0</span><span class="stat-label">Partite</span></div>
            <div class="stat-card"><span class="stat-val" id="stat-high-score">0</span><span class="stat-label">Record</span></div>
            <div class="stat-card"><span class="stat-val" id="stat-total-score">0</span><span class="stat-label">Punti Totali</span></div>
            <div class="stat-card"><span class="stat-val" id="stat-avg-score">0</span><span class="stat-label">Media Punti</span></div>
            <div class="stat-card"><span class="stat-val" id="stat-best-word">-</span><span class="stat-label">Pi√π Preziosa</span></div>
            <div class="stat-card" style="grid-column: span 1;"><span class="stat-val" id="stat-longest-word">-</span><span class="stat-label">Pi√π Lunga</span></div>
        </div>

        <h3>Obiettivi</h3>
        <div id="achievements-list" style="margin-bottom:20px; font-size:0.9rem;"></div>

        <h3>Storico Partite</h3>
        <table class="history-table">
            <thead><tr><th>Data</th><th>Codice</th><th>Punti</th></tr></thead>
            <tbody id="history-list-body"></tbody>
        </table>
        
        <div style="margin-top:20px; text-align:center;">
            <button class="btn-action" style="background-color: var(--accent);" onclick="clearData()">RESET DATA</button>
        </div>
    </div>
</div>

<!-- Modal Legenda -->
<div id="legend-modal" class="modal-overlay">
    <div class="modal-content">
        <span class="close-modal" onclick="closeLegend()">&times;</span>
        <h2>Legenda Punti</h2>
        <table class="legend-table">
            <thead><tr><th>Lunghezza</th><th>Punti Base</th></tr></thead>
            <tbody>
                <tr><td>4 lettere</td><td>1</td></tr>
                <tr><td>5 lettere</td><td>2</td></tr>
                <tr><td>6 lettere</td><td>3</td></tr>
                <tr><td>7 lettere</td><td>5</td></tr>
                <tr><td>8+ lettere</td><td>11</td></tr>
            </tbody>
        </table>
        <div style="margin-top:20px; font-size:0.9rem;">
            <p><b>Q</b> = <b>Qu</b> (Conta come 2 lettere!)</p>
            <hr style="margin:10px 0; border:0; border-top:1px solid #ccc;">
            <p style="font-weight:bold; margin-bottom:10px;">Bonus:</p>
            <div class="bonus-legend-item"><span class="bonus-badge b-2l" style="position:relative;">2L</span> +2 Punti al totale</div>
            <div class="bonus-legend-item"><span class="bonus-badge b-3l" style="position:relative;">3L</span> +3 Punti al totale</div>
            <div class="bonus-legend-item"><span class="bonus-badge b-2p" style="position:relative;">2P</span> Punteggio parola x2</div>
            <div class="bonus-legend-item"><span class="bonus-badge b-3p" style="position:relative;">3P</span> Punteggio parola x3</div>
        </div>
    </div>
</div>

<!-- Modal Fine Partita Aggiornato -->
<div id="game-end-modal" class="modal-overlay" style="z-index: 5000;">
    <div class="modal-content">
        <!-- Icona animata -->
        <div style="font-size: 5rem; margin-bottom: 10px; animation: bounceIn 0.8s;">üèÅ</div>
        
        <h2 style="margin: 0 0 10px 0; font-size: 2.5rem; text-transform: uppercase; text-shadow: 0 2px 10px rgba(0,0,0,0.3);">Tempo Scaduto!</h2>
        <p style="opacity: 0.9; margin-bottom: 30px; font-size: 1.1rem;">La partita √® terminata.</p>
        
        <!-- Contenitore punteggio semitrasparente -->
        <div class="score-container-inner">
            <div style="font-size: 1rem; text-transform: uppercase; letter-spacing: 2px; opacity: 0.8;">Punteggio Finale</div>
            <div id="end-score-val" style="font-size: 5rem; font-weight: 900; line-height: 1; text-shadow: 0 5px 0 rgba(0,0,0,0.2);">0</div>
        </div>
    </div>
</div>

<script>
		// --- CONFIGURAZIONE FIREBASE (Incolla qui le tue chiavi) ---
    const firebaseConfig = {
        apiKey: "AIzaSyCNo7o2Ft22JDEyJ97BspE3Kur5DNAPKQc",
        authDomain: "funatwork-cd237.firebaseapp.com",
        projectId: "funatwork-cd237",
        storageBucket: "funatwork-cd237.firebasestorage.app",
        messagingSenderId: "798226885203",
        appId: "1:798226885203:web:ce83f4d9e96b82266274a6"
    };
	firebase.initializeApp(firebaseConfig);
	const db = firebase.firestore();
	
	const DEBUG_MODE = false;
	
	// Variabili per il match live
	const urlParams = new URLSearchParams(window.location.search);
	const matchId = urlParams.get('matchId');
	const mioNome = localStorage.getItem('mioNome');
	// -----------------------------------------------------------
    // --- CONFIGURAZIONE ---
    let gridSize = 5; // Variabile dinamica (default 5)
    const MIN_WORD_LENGTH = 4;
    const LETTER_POOL = "AAAAAAAABBCCDDEEEEEEEEFFGGGHHIIIIIILLLMMNNOOOOOOPPQRRSSTTTUUUVVZ";
    let EXTRA_WORDS = ["ASIA","EUROPA","AFRICA","AMERICA","OCEANIA","ANTARTIDE","ITALIA","CINA","INDIA","USA","RUSSIA","FRANCIA","SPAGNA","GERMANIA","PERU","CILE","IRAN","IRAQ","LAOS","MALI","CUBA","FIJI","TOGO","ROMA","MILANO","NAPOLI","TORINO","BARI","OSLO","LIMA","RIGA","BONN","NILO","RENO","PO","TEVERE","ARNO","ADIGE","PIAVE","ADDA","ALPI","ANDE","URALI","ETNA","LAGO","MARE","MONTE","CITTA","ISOLA","BELA","LOBO","LOGO","JAVA","HTML","WEB","EMAIL","FILE","APP","GODITI","DIMMI","DAMMI","FAMMI","DILLO","FALLO","VATTENE","PIGLIAMI","SENTIMI",
    "ANITA","LUCA","MARCO","ANNA","MARIA","PAOLO","LUIGI","SARA","ELENA","ROSA","VIOLA","GIOIA","SOLE","LUNA","STELLA",
    "PISA","SIENA","PARMA","COMO","LECCO","LODI","ENNA","RAGUSA","FOGGIA","TERNI","AOSTA","MONZA","MEGA","EZIO","PORCHI","MAMELI","GARDA","MASAI","MAASAI","PABLO","SELINA","LAVAREDO","LARA","PETO","GENE","ENNE","ALARE","RAGU","MONA","GASAI","FETA","FETE","MASO","MASI","MEME","GASI","CAGA","SITE","CASIO","ALONSO","DRENI","CEDO","PENTO","PENTE","ERMA","ERMI",
    "SITA","TOFU","POTAI","PIPPE","CALCIA","ERSE","ERSI","QUINOA","GASO","BUSET","MISO","NASA","EBOLA","TERA","NONE","ZORRO","EOLIE","SERI","SILE","PELMO","PITA"];
	 let EXCLUDED_WORDS = ["SAETTI","BIFFE","PIATO","PIOTA","GILE","GLIE","GIOI","POPE","RAFFA","RAFFI","ZAFFI","PASCI","MEVE","MINO","BASTE","DIANE","MAIO","SPALLI","RENA","FELA","FERA","GATO","ZOIA","ANCE","ELISE","ELSE","FIFE","PILLI","PILLO","BASA","INIO","PIVA","PIVE","ROMI","ALPA","ALPO","BIDE","LARIO","LARO","LAURI","PROTI","NESTO","TOSONE","GORE","BIAVA","FOIA","PASSE","SAPA","LETO","LETA","ORTE","TORE","SILA","SERPA","ENEO","LENE","LENO","LIANO","IANO","MALO","BALIO",
	 "TELMA","TALLO","GRUMA","GIACO","PASCO","CIRA","VAGITA","FEDO","PRECI","SIRO","QUIRO","POTTE","ROSI","POTTA","PELUTO","BOVO","BETTO","CIANA","CIANE","CIANI","VELIE","FAGO","CORE","RICO","BOVE","CEBO","LIMANA","GIANA","MUFFI","MUFFO","NILA","FOGNATA","NASATE","LICE","GERI","MITRE","TOMA","PELTA","POLTA","FANNE","INNA","GENICA","AGIEA","FANNI","SANNA","SANNE","GINNO","FANNI","OLGO","CALE","IMMO","MITRE","TREVO","MESCE","PINGE","NINI","ANITO","OVATO",
	 "GELSA","TOSSO","COTI","BAULA","BAULO","CARMI","LORA","SIMO","BOTRO","EOLA","AGGIO","ALIA","BORNI","BORNIA"];

    // --- ACHIEVEMENTS ---
    const ACHIEVEMENTS = [
        { id: 'not_now', title: 'Anti-sgamo', desc: 'Metti in pausa il gioco', check: (ctx) => ctx.game.isPaused === true },
		  { id: 'blender', title: 'Frullatore', desc: 'Ruota la griglia 20 volte in una partita', check: (ctx) => rotationCount >= 20 },
        { id: 'flash', title: 'Flash', desc: 'Trova una parola nei primi 3 secondi', check: (ctx) => ctx.last.word && ctx.game.elapsedTime <= 3 },
		  { id: 'fotofinish', title: 'Fotofinish', desc: 'Trova una parola negli ultimi 3 secondi', check: (ctx) => ctx.last.word && ctx.game.timeRemaining <= 3 && !ctx.game.isOver },
		  { id: 'sloth', title: 'Bradipo', desc: 'Trova la prima parola quando mancano meno di 30 secondi', check: (ctx) => ctx.game.wordCount === 1 && ctx.game.timeRemaining < 30 },
		  { id: 'parkinson', title: 'Parkinson', desc: 'Sbaglia parola per 15 volte', check: (ctx) => errorCount >= 15 },
        { id: 'long_one', title: 'Linguista', desc: 'Trova una parola da 8 o pi√π lettere', check: (ctx) => ctx.last.word && ctx.last.word.length >= 8 },
        { id: 'palindromo', title: 'Specchio Riflesso', desc: 'Trova una parola palindroma', check: (ctx) => { const w = ctx.last.word; return w && w.length >= 4 && w === w.split('').reverse().join(''); }},
		  { id: 'sniper', title: 'Cecchino', desc: 'Trova una parola da almeno 30 punti', check: (ctx) => ctx.last.points >= 30 },
        { id: 'words_40', title: 'Mitragliatrice', desc: 'Trova 40 parole in una partita', check: (ctx) => ctx.game.wordCount >= 40 },
		  { id: 'score_200', title: 'Fuoriclasse', desc: 'Fai 200 punti in una partita', check: (ctx) => ctx.game.score >= 200 && ctx.game.score < 300 },
		  { id: 'score_300', title: 'Einstein', desc: 'Fai 300 punti in una partita', check: (ctx) => ctx.game.score >= 300 },
		  { id: 'gandhi', title: 'Gandhi', desc: 'Fai 0 punti in una partita', check: (ctx) => ctx.game.isOver && ctx.game.score === 0 && !ctx.game.isPaused },
        { id: 'copione', title: 'Copione', desc: 'Elimina il 95% delle tue parole in fase di verifica', check: (ctx) => ctx.game.wordCount >= 10 && (ctx.game.deletedCount / ctx.game.wordCount) >= 0.9 },
		  { id: 'buset', title: 'BUSET MAIALONE', desc: 'Hai trovato l amore della tua vita!', check: (ctx) => ctx.last.word === 'BUSET' },
          { id: 'biatch_move', title: 'MAL DI TESTA üíÖ', desc: 'Hai fatto girare la griglia tante volte!', check: (ctx) => isBiatchMode && rotationCount > 10 }
    ];

    // --- STATO ---
    let dictionary = new Set();
    let gridLetters = []; 
    let gridBonuses = []; 
    let selectedCells = []; 
    let foundWords =	new Map(); 
    let score = 0;
	let isRotating = false;
	let errorTimeout = null;
	let rotationCount = 0;
	let errorCount = 0;
	let fireworksInterval = null;
    let timerInterval;
    let timeRemaining = 180;
    let initialTime = 180;
    let isGameActive = false;
    let isPaused = false; 
    let isDragging = false;
    let isSandboxMode = false; 
    let inputMode = 'drag'; 
    let currentSeed = "";
    let isAnalysisPhase = false;
    let wordCounter = 0; 
    let sortMode = 'chrono'; 
    let sortDescending = true; 
    let rotationIndex = 0; 
    let useBonuses = false;
    let currentGameTimestamp = null; 
    let currentHighlightedWord = null;
	let isCrazyMode = false;
	let isBiatchMode = false;
	let currentGameData = null;
	let dizionarioCustomApplicato = false;
	let unsubscribePartita = null;
	let unsubscribeProposte = null;
	let wordDisplayLocked = false;
	let dictionaryReady = false;

	     // --- TRIE (struttura veloce per cercare prefissi) ---
    class TrieNode {
        constructor() { this.children = {}; this.isWord = false; }
    }
    let trieRoot = null;

    function buildTrie() {
        trieRoot = new TrieNode();
        dictionary.forEach(word => {
            let node = trieRoot;
            for (const ch of word) {
                if (!node.children[ch]) node.children[ch] = new TrieNode();
                node = node.children[ch];
            }
            node.isWord = true;
        });
    }

    function hasPrefix(prefix) {
        let node = trieRoot;
        for (const ch of prefix) {
            if (!node.children[ch]) return false;
            node = node.children[ch];
        }
        return true;
    }

    // --- RNG ---
    function cyrb128(str) {
        let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;
        for (let i = 0, k; i < str.length; i++) { k = str.charCodeAt(i); h1 = h2 ^ Math.imul(h1 ^ k, 597399067); h2 = h3 ^ Math.imul(h2 ^ k, 2869860233); h3 = h4 ^ Math.imul(h3 ^ k, 951274213); h4 = h1 ^ Math.imul(h4 ^ k, 2716044179); }
        h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067); h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233); h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213); h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
        return [(h1^h2^h3^h4)>>>0, (h2^h1)>>>0, (h3^h1)>>>0, (h4^h1)>>>0];
    }
    function sfc32(a, b, c, d) {
        return function() { a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; var t = (a + b) | 0; a = b ^ b >>> 9; b = c + (c << 3) | 0; c = (c << 21 | c >>> 11); d = (d + 1) | 0; t = (t + d) | 0; c = (c + t) | 0; return (t >>> 0) / 4294967296; }
    }

    // --- DOM ---
    const gridEl = document.getElementById('grid');
    const wordDisplay = document.getElementById('current-word');
    const scoreDisplay = document.getElementById('total-score');
    const wordsListEl = document.getElementById('found-words');
    const timerDisplay = document.getElementById('timer');
    const loadingMsg = document.getElementById('loading-msg');
    const gridOverlay = document.getElementById('grid-overlay');
    const displaySeed = document.getElementById('display-seed');
    const overlaySeed = document.getElementById('overlay-seed');
    const gameControls = document.getElementById('in-game-controls');
    const btnPause = document.getElementById('btn-pause');
    const pauseOverlay = document.getElementById('pause-overlay');
    const wordCountDisplay = document.getElementById('word-count');
    const lineLayer = document.getElementById('line-layer');
    const analysisMsg = document.getElementById('analysis-msg');
    const sortControls = document.getElementById('sort-controls');
    const btnMissed = document.getElementById('btn-missed');
    const sortDirBtn = document.getElementById('sort-dir-btn');
    const statsModal = document.getElementById('stats-modal');
    const historyListBody = document.getElementById('history-list-body');
    const legendModal = document.getElementById('legend-modal');
    const achNotif = document.getElementById('ach-notification');
    const newGameModal = document.getElementById('new-game-modal');
    const btnSandbox = document.getElementById('btn-sandbox');
    const btnResetSelection = document.getElementById('btn-reset-selection');
    const btnTerminate = document.getElementById('btn-terminate');
    const toggleInput = document.getElementById('input-mode-toggle');
    const modalGridSelect = document.getElementById('modal-grid-select'); 
	 const gameEndModal = document.getElementById('game-end-modal');
    // --- INIT ---
    async function loadDictionary() {
        try {
            // 1. LISTA DEGLI URL
            const urls = [
                'https://raw.githubusercontent.com/napolux/paroleitaliane/refs/heads/main/paroleitaliane/280000_parole_italiane.txt',
                'https://raw.githubusercontent.com/napolux/paroleitaliane/refs/heads/main/paroleitaliane/9000_nomi_propri.txt'
            ];

            // 2. FILTRA E SCARICA
            // .filter(u => u) rimuove le stringhe vuote automaticamente
            const responses = await Promise.all(
                urls.filter(u => u).map(u => fetch(u))
            );

            // 3. CONVERTI I TESTI
            const texts = await Promise.all(responses.map(r => r.text()));

            // 4. FUNZIONE DI PULIZIA
            const addWordsToDictionary = (textData) => {
                textData.split('\n').forEach(w => {
                    const clean = w.trim().toUpperCase()
                                   .normalize('NFD')
                                   .replace(/[\u0300-\u036f]/g, "")
                                   .replace(/[^A-Z]/g, "");
                    if (clean.length >= MIN_WORD_LENGTH && !EXCLUDED_WORDS.includes(clean)) {
                        dictionary.add(clean);}
                });
            };

            // 5. AGGIUNGI TUTTO AL DIZIONARIO
            texts.forEach(t => addWordsToDictionary(t));

            // Aggiunge le parole extra manuali
            EXTRA_WORDS.forEach(w => dictionary.add(w));
            // Costruisce il Trie per ricerche veloci
            try {
    const globalDoc = await db.collection("config").doc("dizionario").get();
    if (globalDoc.exists) {
        const data = globalDoc.data();
        if (data.extra) {
            data.extra.forEach(w => {
                if (w && !EXTRA_WORDS.includes(w)) {
                    EXTRA_WORDS.push(w);
                    dictionary.add(w);
                }
            });
        }
        if (data.excluded) {
            data.excluded.forEach(w => {
                if (w && !EXCLUDED_WORDS.includes(w)) {
                    EXCLUDED_WORDS.push(w);
                    dictionary.delete(w);
                }
            });
        }
		  if (DEBUG_MODE) console.log("Dizionario permanente caricato.");
    }
} catch (e) { 
    console.error("Errore caricamento dizionario globale:", e); 
}
buildTrie();
dictionaryReady = true;		
            
            // Aggiorna la UI
            loadingMsg.style.display = 'none';
            if (DEBUG_MODE) console.log(`Dizionario caricato: ${dictionary.size} parole totali.`);
            // Gestione URL param code
            const urlParams = new URLSearchParams(window.location.search);
            const codeParam = urlParams.get('code');
            
            if(codeParam) {
                initGame(codeParam);
            } else {
                gridEl.innerHTML = '';
                displaySeed.textContent = "----";
            }
            
        } catch (error) { 
            console.error(error);
            loadingMsg.innerHTML = "Errore caricamento dizionari.<br>Controlla i link o la connessione."; 
        }
    }

    // --- CORE GAME LOGIC ---
    function startNewGame() { newGameModal.style.display = 'flex'; }
    
		function confirmNewGame(withBonus, isCrazy = false, isBiatch = false) {
		    if (typeof matchId !== 'undefined' && matchId) {
				creaRivincitaPersonalizzata(withBonus, isCrazy, isBiatch);
				return;
			}
			 useBonuses = withBonus || isCrazy; // Crazy usa sempre i bonus
			 isCrazyMode = isCrazy; 
			 isBiatchMode = isBiatch;
			 const selectedSize = parseInt(modalGridSelect.value) || 5;
			 gridSize = selectedSize;
			 newGameModal.style.display = 'none';
			 initGame(null);
			 copySeedNewGame();
		}
 
	async function creaRivincitaPersonalizzata(bonus, crazy, biatch) {
		 const snap = await db.collection("partite").doc(matchId).get();
		 const v = snap.data();
		 let mode = crazy ? 'crazy' : (biatch ? 'biatch' : (bonus ? 'bonus' : 'classic'));
		 
		 let pts = {}; let words = {}; v.partecipanti.forEach(p => { pts[p]=0; words[p]=[]; });
		 const doc = await db.collection("partite").add({
			  gioco: 'ruzzle',
			  partecipanti: v.partecipanti,
			  opzioni: {
					tempo: document.getElementById('modal-timer-select').value,
					griglia: document.getElementById('modal-grid-select').value,
					mode: mode,
					seed: Math.random().toString(36).substring(7).toUpperCase()
			  },
			  punteggi: pts, parole: words, pronti: [], finito: [], confermaVerifica: [], stato: "attesa", timestamp: Date.now(), dataOra: new Date().toLocaleString('it-IT')
		 });
		 db.collection("partite").doc(matchId).update({ prossimaPartita: doc.id });
	}
 
    function closeNewGameModal() { newGameModal.style.display = 'none'; }
    function joinGame() {
        const code = prompt("Inserisci il Codice Partita:");
        if (code && code.trim().length > 0) initGame(code.trim().toUpperCase());
    }

    function initGame(forceSeed) {
	     timerDisplay.style.color = "";
		  document.getElementById('start-screen').style.display = 'none';
        clearInterval(timerInterval);
        isGameActive = false; isAnalysisPhase = false; isPaused = false; isSandboxMode = false;
        
        // Cleanup effetti visivi precedenti
        document.body.classList.remove('mega-win-effect');
        stopFireworks();
        
        score = 0; foundWords.clear(); selectedCells = []; wordCounter = 0; rotationIndex = 0; rotationCount = 0; errorCount = 0;
		  wordDisplayLocked = false;
        currentGameTimestamp = null;
        
        scoreDisplay.textContent = "0"; wordCountDisplay.textContent = "0";
        wordsListEl.innerHTML = ""; wordsListEl.classList.remove('interactive');
        analysisMsg.style.display = "none"; sortControls.style.display = "none";
        btnMissed.style.display = "none";
        btnSandbox.style.display = 'none';
        setSortMode('chrono');
        
        wordDisplay.textContent = ""; lineLayer.innerHTML = '';
        document.getElementById('possible-count').textContent = '...';
        document.getElementById('possible-count').style.opacity = '0.6';
        gameControls.style.display = 'none';
        pauseOverlay.style.display = 'none';
        btnPause.textContent = "PAUSA";
        btnPause.style.backgroundColor = "#f39c12";

        inputMode = toggleInput.checked ? 'click' : 'drag';
        btnResetSelection.style.display = (inputMode === 'click') ? 'block' : 'none';
        btnTerminate.style.display = 'none';

        // --- GESTIONE CODICE E MODALIT√Ä (BIATCH & CRAZY) ---
        if (forceSeed) {
            currentSeed = forceSeed;
            // Legge i flag dal codice incollato
            isBiatchMode = currentSeed.includes('-B1');
            isCrazyMode = currentSeed.includes('-C1');
            useBonuses = currentSeed.endsWith('+') || isCrazyMode || isBiatchMode;
            
            // Estrae dimensione griglia
            const sizeMatch = currentSeed.match(/-S(\d+)/);
            if(sizeMatch && sizeMatch[1]) {
                gridSize = parseInt(sizeMatch[1]);
            } else {
                gridSize = 5; 
            }

            // Estrae durata timer
            const timeMatch = currentSeed.match(/-T(\d+)/);
            if(timeMatch && timeMatch[1]) {
                timeRemaining = parseInt(timeMatch[1]);
            } else {
                const modalTimer = document.getElementById('modal-timer-select');
                timeRemaining = parseInt(modalTimer ? modalTimer.value : 180);
            }
        } else {
            // Crea una nuova partita
            const baseSeed = Math.random().toString(36).substring(7).toUpperCase();
            const modalTimer = document.getElementById('modal-timer-select');
            const selectedTime = parseInt(modalTimer ? modalTimer.value : 180);
            timeRemaining = selectedTime;

            // Costruisce i tag per il codice (Seed)
            let tags = `-S${gridSize}-T${timeRemaining}`;
            if (isBiatchMode) tags += "-B1";
            if (isCrazyMode) tags += "-C1";
            else if (useBonuses) tags += "+";
            
            currentSeed = baseSeed + tags;
        }
        
        // --- UI BIATCH ---
        // Nascondi il pulsante di rotazione manuale se sei in modalit√† Biatch
			const manualRotBtn = document.getElementById('manual-rotate-btn');
			if(manualRotBtn) manualRotBtn.style.display = 'none';

        initialTime = timeRemaining;
        if (gridSize === 4 && timeRemaining === 45) showElenaPopup();

        timerDisplay.textContent = formatTime(timeRemaining);
        timerDisplay.className = "";
        displaySeed.textContent = currentSeed;
        overlaySeed.textContent = currentSeed;

        // Estrae il seme pulito per l'RNG (tutto ci√≤ che precede il primo trattino)
        const cleanSeed = currentSeed.split('-')[0];
        
			generateGridData(cleanSeed);
			renderGrid();
			
			// Calcola parole trovabili subito
			calculatePossibleWordsCount();
			
			// Mostra il contatore trovabili
			document.getElementById('possible-count').parentElement.style.visibility = 'visible';
			
		// FIX CRITICO: Gestisci overlay in base alla modalit√†
		if (matchId) {
			 // Multiplayer: nascondi overlay, la partita parte da Firebase
			 gridOverlay.style.display = 'none';
			 document.getElementById('start-screen').style.display = 'none';
		} else {
			 // Solitario: mostra overlay VIA
			 document.getElementById('start-screen').style.display = 'none';
			 gridOverlay.style.display = 'flex';
			 document.querySelectorAll('.tile').forEach(t => t.classList.add('blurred'));
		}

		const newUrl = window.location.protocol + "//" + window.location.host + window.location.pathname + '?code=' + currentSeed;
		window.history.pushState({path:newUrl},'',newUrl);
    }

    function generateGridData(rngSeedStr) {
        const seedHash = cyrb128(rngSeedStr);
        // Generatore di numeri casuali basato sul seme (uguale per tutti i giocatori)
        const rand = sfc32(seedHash[0], seedHash[1], seedHash[2], seedHash[3]);
        
        gridLetters = []; 
        gridBonuses = [];
        const totalCells = gridSize * gridSize;
        
        // 1. Generazione standard lettere
        for (let i = 0; i < totalCells; i++) gridLetters.push(LETTER_POOL.charAt(Math.floor(rand() * LETTER_POOL.length)));
        
        // 2. Generazione bonus
        for (let i = 0; i < totalCells; i++) {
            let bonus = null;
            let rngVal = rand(); 
				let bonusProbability = isCrazyMode ? 0.70 : 0.20; //70% di probabilit√† invece di 20%
            if(rngVal < bonusProbability) {
                const r = rand(); 
					if (isCrazyMode) {
						 // In modalit√† Crazy, i bonus 3P e 3L sono molto pi√π comuni
						 if(r < 0.30) bonus = "2L"; 
						 else if(r < 0.50) bonus = "3L"; 
						 else if(r < 0.75) bonus = "2P"; 
						 else bonus = "3P"; 
					} else {
						 // Modalit√† standard
						 if(r < 0.60) bonus = "2L"; else if(r < 0.85) bonus = "3L"; else if(r < 0.95) bonus = "2P"; else bonus = "3P"; 
					}
			  }
			  gridBonuses.push(useBonuses ? bonus : null);
		 }

        // --- INIEZIONE CODICE CAMUFFATO (SECRET MODE) ---
        // Se il codice contiene "B7S3T", inseriamo la parola in modo "naturale" (serpeggiante)
        if (rngSeedStr.includes("B7S3T") && totalCells >= 5) {
            const secretWord = ['B', 'U', 'S', 'E', 'T'];
            let inserted = false;
            let attempts = 0;

            // Tentiamo di inserire la parola (max 500 tentativi per evitare blocchi infiniti)
            while (!inserted && attempts < 500) {
                attempts++;
                let currentPath = [];
                let usedIndices = new Set();

                // A. Scegli un punto di partenza casuale
                let currentIdx = Math.floor(rand() * totalCells);
                currentPath.push(currentIdx);
                usedIndices.add(currentIdx);

                // B. Cerca di piazzare le lettere successive
                for (let i = 1; i < secretWord.length; i++) {
                    // Trova vicini validi (adiacenti e non usati)
                    let r = Math.floor(currentIdx / gridSize);
                    let c = currentIdx % gridSize;
                    let validNeighbors = [];

                    for (let nr = r - 1; nr <= r + 1; nr++) {
                        for (let nc = c - 1; nc <= c + 1; nc++) {
                            // Controlla confini griglia
                            if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize) {
                                let nIdx = nr * gridSize + nc;
                                // Non deve essere la cella stessa e non deve essere gi√† usata
                                if (nIdx !== currentIdx && !usedIndices.has(nIdx)) {
                                    validNeighbors.push(nIdx);
                                }
                            }
                        }
                    }

                    // Se siamo in un vicolo cieco, interrompi questo tentativo
                    if (validNeighbors.length === 0) break;

                    // C. Scegli un vicino a caso (usa rand() per sincronia tra giocatori)
                    let nextIdx = validNeighbors[Math.floor(rand() * validNeighbors.length)];
                    currentPath.push(nextIdx);
                    usedIndices.add(nextIdx);
                    currentIdx = nextIdx;
                }

                // D. Se abbiamo piazzato tutte le 5 lettere, applichiamo alla griglia
                if (currentPath.length === secretWord.length) {
                    for (let k = 0; k < secretWord.length; k++) {
                        gridLetters[currentPath[k]] = secretWord[k];
                    }
                    inserted = true;
                }
            }
        }
    }

    function renderGrid() {
        gridEl.innerHTML = '';
        // Set CSS Variable for grid size
        gridEl.style.setProperty('--grid-cols', gridSize);
        
        let displayLetters = [...gridLetters];
        let displayBonuses = [...gridBonuses];
        for(let r=0; r<rotationIndex; r++) { displayLetters = rotateArray(displayLetters); displayBonuses = rotateArray(displayBonuses); }
        
        const totalCells = gridSize * gridSize;

        for (let i = 0; i < totalCells; i++) {
            const char = displayLetters[i];
            const bonus = displayBonuses[i];
            const tile = document.createElement('div');
            tile.classList.add('tile');
            if(!isGameActive && !isAnalysisPhase && !isPaused && !isSandboxMode) tile.classList.add('blurred');
            
            // --- GESTIONE CLASSI DIMENSIONI ---
            if(gridSize === 4) tile.classList.add('medium-font'); 
				else if(gridSize === 5) tile.classList.add('five-font');
				else if(gridSize === 6) tile.classList.add('six-font'); 				
            else if(gridSize === 7) tile.classList.add('compact-font'); 
            else if(gridSize >= 10) tile.classList.add('small-font');   

            tile.textContent = char === 'Q' ? 'Qu' : char;
            
            // --- GESTIONE SPECIFICA DELLA "Q" ---
            if(char === 'Q') {
                if(gridSize <= 5) tile.style.fontSize = "1.3rem"; 
					 else if(gridSize === 6) tile.style.fontSize = "1.15rem"; 
                else if(gridSize === 7) tile.style.fontSize = "1.0rem"; 
            }
            
            tile.dataset.index = i;
            tile.dataset.bonus = bonus || "";

            if(bonus) {
                const badge = document.createElement('span');
                badge.className = `bonus-badge b-${bonus.toLowerCase()}`;
                badge.textContent = bonus;
                tile.appendChild(badge);
            }
            
				const startHandler = (e) => {
					 // Reset forzato di tutti i blocchi
					 if(errorTimeout){
						  clearTimeout(errorTimeout);
						  errorTimeout = null;
					 }
					 if(isRotating) return; // Blocca durante rotazione
					 
					 wordDisplay.style.background = "#dfe6e9";
					 document.querySelectorAll('.tile').forEach(t => {
						  t.classList.remove('anim-invalid');
						  t.classList.remove('anim-valid');
					 });
					 
					 // Sblocca wordDisplay se era bloccato da troppo tempo
					 wordDisplayLocked = false;
					 
					 if(!isGameActive) return;
                if (inputMode === 'drag') { e.preventDefault(); isDragging = true; selectTile(i); }
                else handleClickMode(i);
            };

            tile.addEventListener('mousedown', startHandler);
            tile.addEventListener('touchstart', startHandler, {passive:false});
            gridEl.appendChild(tile);
        }
        gridEl.dataset.letters = JSON.stringify(displayLetters);
        gridEl.dataset.bonuses = JSON.stringify(displayBonuses);
    }

    // Generic Rotation for N x N
    function rotateArray(arr) {
        const newArr = new Array(gridSize * gridSize);
        for(let r=0; r<gridSize; r++) {
            for(let c=0; c<gridSize; c++) {
                // Formula: newArr[col * N + (N - 1 - row)] = arr[row * N + col]
                newArr[c * gridSize + (gridSize - 1 - r)] = arr[r * gridSize + c];
            }
        }
        return newArr;
    }

    function rotateGrid() {
        // Esci se il gioco non √® attivo o se √® in pausa
    	if (!isGameActive || isPaused || isAnalysisPhase) return; 
		// 1. BLOCCO ANTI-SPAM: Se sta gi√† girando, ignora il click
        if (isRotating) return; 
        
        // Controlli standard
        if ((!isGameActive && !isAnalysisPhase) || isPaused) return; 
        
        // Attiva il blocco
        isRotating = true;
        clearSelection();

        // Configurazione Animazione: SCATTANTE E VELOCE (0.3s)
        const duration = 300; 
        const easing = "cubic-bezier(0.25, 1, 0.5, 1)"; 

        // 2. Applica transizione
        const transitionStyle = `transform ${duration}ms ${easing}`;
        gridEl.style.transition = transitionStyle;
        
        const tiles = document.querySelectorAll('.tile');
        tiles.forEach(t => t.style.transition = transitionStyle);

        // 3. Esegui la rotazione visiva
        gridEl.style.transform = "rotate(90deg)";
        tiles.forEach(t => t.style.transform = "rotate(-90deg)");

        // 4. Aspetta la fine dell'animazione
        setTimeout(() => {
            gridEl.style.transition = "none";
            rotationIndex = (rotationIndex + 1) % 4;
            if(typeof rotationCount !== 'undefined') rotationCount++; 
            runAchievementCheck();
            renderGrid();
            gridEl.style.transform = "rotate(0deg)";
            isRotating = false;
        }, duration);
    }
	
	function calculatePossibleWordsCount() {
    const countEl = document.getElementById('possible-count');
    countEl.textContent = '...';
    countEl.style.opacity = '0.6';

    setTimeout(() => {
        if (!trieRoot) { countEl.textContent = '?'; return; }

        const vizL = JSON.parse(gridEl.dataset.letters);
        const total = gridSize * gridSize;
        const adjMap = Array.from({length: total}, (_, i) => getNeighbors(i));
        const found = new Set();
        const maxTime = 8000;
        const startCalc = performance.now();

        function countSolve(idx, word, visited) {
            if (performance.now() - startCalc > maxTime) return;
            visited[idx] = true;
            if (!hasPrefix(word)) { visited[idx] = false; return; }
            if (word.length >= MIN_WORD_LENGTH && dictionary.has(word)) {
                found.add(word);
            }
            if (word.length >= 12) { visited[idx] = false; return; }
            for (let n of adjMap[idx]) {
                if (!visited[n]) {
                    let ch = vizL[n];
                    if (ch === 'Q') ch = 'QU';
                    countSolve(n, word + ch, visited);
                }
            }
            visited[idx] = false;
        }

        for (let i = 0; i < total; i++) {
            if (performance.now() - startCalc > maxTime) break;
            let ch = vizL[i];
            if (ch === 'Q') ch = 'QU';
            countSolve(i, ch, new Array(total).fill(false));
        }

        countEl.textContent = found.size;
        countEl.style.opacity = '1';
    }, 300);
}
	
	function startRound() {
    isGameActive = true; isPaused = false; gridOverlay.style.display = 'none';
    gameControls.style.display = 'flex'; btnTerminate.style.display = 'block';
    document.querySelectorAll('.tile').forEach(t => t.classList.remove('blurred'));
    
    // Mostra pulsante rotazione (tranne Biatch)
    const rotateBtn = document.getElementById('manual-rotate-btn');
    if (rotateBtn) {
        rotateBtn.style.display = isBiatchMode ? 'none' : 'block';
    }
    
    updateTimerDisplay();
    timerInterval = setInterval(() => {
        timeRemaining--; updateTimerDisplay();
        if (timeRemaining <= 0) endGame();
    }, 1000);
}

    function togglePause() {
        if(!isGameActive && !isPaused) return;
        const listEl = document.getElementById('found-words');
        if(!isPaused) {
            isPaused = true; isGameActive = false; clearInterval(timerInterval);
				runAchievementCheck();
            pauseOverlay.style.display = 'flex'; listEl.classList.add('blurred-list');
            btnPause.textContent = "RIPRENDI"; btnPause.style.backgroundColor = "#27ae60"; 
            clearSelection();
        } else {
            isPaused = false; isGameActive = true; pauseOverlay.style.display = 'none';
            listEl.classList.remove('blurred-list'); btnPause.textContent = "PAUSA"; btnPause.style.backgroundColor = "#f39c12"; 
            timerInterval = setInterval(() => { timeRemaining--; updateTimerDisplay(); if (timeRemaining <= 0) endGame(); }, 1000);
        }
    }

    function endGameManually() { if(confirm("Terminare ora?")) endGame(); }
   
	function closeEndGameModal() {
    const modal = document.getElementById('game-end-modal');
    if (modal) modal.style.display = 'none';
    stopFireworks();
    document.body.classList.remove('mega-win-effect');
    
    // Cancella timeout se esiste
    if (window.autoCloseEndGameTimeout) {
        clearTimeout(window.autoCloseEndGameTimeout);
        window.autoCloseEndGameTimeout = null;
    }
}	
	
	function endGame() {
	    if (typeof registraPartita === 'function') {
			  registraPartita('ruzzle');
		 } else {
			  // Salva in localStorage se non siamo nella homepage
			  const STATS_KEY = 'funatwork_daily_stats';
			  const oggi = new Date().toISOString().split('T')[0];
			  const stats = JSON.parse(localStorage.getItem(STATS_KEY) || '{"days":{},"totals":{}}');
			  if (!stats.days[oggi]) stats.days[oggi] = {};
			  stats.days[oggi].ruzzle = (stats.days[oggi].ruzzle || 0) + 1;
			  stats.totals.ruzzle = (stats.totals.ruzzle || 0) + 1;
			  localStorage.setItem(STATS_KEY, JSON.stringify(stats));
		 }
	    clearInterval(timerInterval);
	    isGameActive = false;
	
	    // --- FINE PARTITA INDIVIDUALE ---
	    if (typeof matchId !== 'undefined' && matchId) {
	        const mieParole = [];
	        foundWords.forEach((v, k) => { mieParole.push({w: k, p: v.points, path: v.path});});
	        
	        db.collection("partite").doc(matchId).update({
	            [`parole.${mioNome}`]: mieParole,
	            finito: firebase.firestore.FieldValue.arrayUnion(mioNome) 
	        });
	
	        document.getElementById('multiplayer-lobby').style.display = 'flex';
	        document.getElementById('lobby-title').textContent = "FINE TEMPO!";
	        document.getElementById('lobby-status').textContent = "Attendo che l'avversario finisca il suo tempo.";
	    }
	    // --------------------------------
		  // --- FIX PER GANDHI ---
        // Forziamo un controllo manuale in questo momento esatto
        // Creiamo un contesto fittizio perfetto per questo check
        const gandhiContext = {
            game: {
                isOver: true,      // Siamo in endGame, quindi √® finita per forza
                score: score,      // Il punteggio attuale
                isPaused: false,   // Non √® in pausa, √® finita
                wordCount: foundWords.size,
                elapsedTime: initialTime // Tempo scaduto
            },
            stats: { totalGames: 100, totalScore: 100, highScore: 100 }, // Dati dummy, non servono per Gandhi
            last: { word: null, points: 0 }
        };
        
        // Controlliamo manualmente l'achievement
        const gandhiAch = ACHIEVEMENTS.find(a => a.id === 'gandhi');
        const data = getStorageData();
        
        if (gandhiAch && !data.achievements.includes('gandhi')) {
            if (gandhiAch.check(gandhiContext)) {
                data.achievements.push('gandhi');
                localStorage.setItem('paroliere_data', JSON.stringify(data));
                showAchievement(gandhiAch.title);
            }
        }
		  
        timerDisplay.classList.remove('timer-alert');
        
        // 2. Salva statistiche
		  currentGameTimestamp = Date.now();
        updateStats(); 
        
        // 3. UI Updates
        gameControls.style.display = 'none'; 
        pauseOverlay.style.display = 'none';
        
        // 4. --- SBLOCCO GRIGLIA (Modalit√† Libera Automatica) ---
        isGameActive = true;   // Lasciamo attivo il motore di input
        isSandboxMode = true;  // Ma attiviamo la modalit√† "senza regole"
        isAnalysisPhase = true;// Attiva gli strumenti di analisi
        
        // Rimuove il blur immediatamente
        document.querySelectorAll('.tile').forEach(t => t.classList.remove('blurred'));
        
        // Nascondi il bottone "Sblocca Griglia" perch√© √® gi√† sbloccata
        btnSandbox.style.display = 'none'; 
        
        // Mostra strumenti di analisi nella sidebar
        document.getElementById('found-words').classList.remove('blurred-list');
        clearSelection(); 
        wordDisplay.textContent = ""; 
        lineLayer.innerHTML = '';
        
        sortDescending = true; 
        document.getElementById('sort-dir-btn').textContent = "‚¨áÔ∏è";
        setSortMode('alpha');

        wordsListEl.classList.add('interactive');
        analysisMsg.style.display = "block"; 
        sortControls.style.display = "flex";
        btnMissed.style.display = "block";

		// Mostra Modale
		 const modal = document.getElementById('game-end-modal');
		 modal.style.display = 'flex';
		 document.getElementById('end-score-val').textContent = score;

		 // Fuochi d'artificio
		 startEndGameCelebration(); 

		// FIX 4: AUTO-CHIUSURA CON CLEANUP GARANTITO
		let autoCloseTimeout = setTimeout(() => {
			 closeEndGameModal();
		}, 5000);

		// Salva il timeout per poterlo cancellare se chiuso prima
		window.autoCloseEndGameTimeout = autoCloseTimeout;
    }

    function startSandbox() {
        isSandboxMode = true; isGameActive = true; isAnalysisPhase = true; btnSandbox.style.display = 'none';
        document.querySelectorAll('.tile').forEach(t => t.classList.remove('blurred'));
        timerDisplay.textContent = "MODALIT√Ä LIBERA"; timerDisplay.style.color = "var(--primary)";
    }

    // --- INPUT SYSTEM (SMART) ---
    function getCenter(el) { const r = el.getBoundingClientRect(); return { x: r.left + r.width/2, y: r.top + r.height/2 }; }
    function dist(p1, p2) { return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)); }
    
    function handleClickMode(i) {
        if(selectedCells.includes(i)) {
             if(i === selectedCells[selectedCells.length-1]) validateWord();
             else if(selectedCells.length > 1 && i === selectedCells[selectedCells.length-2]) { selectedCells.pop(); updateVisuals(); }
             return;
        }
        if(selectedCells.length === 0 || isAdjacent(selectedCells[selectedCells.length-1], i)) { selectedCells.push(i); updateVisuals(); }
    }
    
    const moveListener = (x, y) => {
        if (inputMode !== 'drag' || !isDragging || !isGameActive) return;
        let closest = -1, minD = 9999;
        const last = selectedCells[selectedCells.length - 1];
        const candidates = getNeighbors(last); candidates.push(last);
        if(selectedCells.length > 1) candidates.push(selectedCells[selectedCells.length - 2]);
        candidates.forEach(idx => {
            const tile = gridEl.children[idx]; const d = dist({x, y}, getCenter(tile));
            if (d < tile.offsetWidth * 0.45 && d < minD) { minD = d; closest = idx; }
        });
        if (closest !== -1) attemptSelection(closest);
    };

    document.addEventListener('mousemove', (e) => { if (inputMode==='drag' && isDragging) moveListener(e.clientX, e.clientY); });
    document.addEventListener('touchmove', (e) => { if (inputMode==='drag' && isDragging) { e.preventDefault(); moveListener(e.touches[0].clientX, e.touches[0].clientY); } }, {passive:false});
    document.addEventListener('mouseup', () => endDrag()); document.addEventListener('touchend', () => endDrag());
    
	 
	function forceResetInputState() {
		 isDragging = false;
		 isRotating = false;
		 wordDisplayLocked = false;
		 if (errorTimeout) {
			  clearTimeout(errorTimeout);
			  errorTimeout = null;
		 }
	}
	 
	const endDrag = () => { 
	    if (!isDragging) return; // ‚úÖ Evita doppie chiamate
	    
	    isDragging = false;
	    
	    // ‚úÖ Salva selectedCells PRIMA di qualsiasi operazione asincrona
	    const cellsSnapshot = [...selectedCells];
	    const wordSnapshot = wordDisplay.textContent;
	    
	    if (cellsSnapshot.length >= MIN_WORD_LENGTH && wordSnapshot.length >= MIN_WORD_LENGTH) {
	        validateWord();
	    }
	    
	    if (!isSandboxMode && !wordDisplayLocked) {
	        setTimeout(() => {
	            if (!wordDisplayLocked) clearSelection();
	        }, 300);
	    }
	};

    function selectTile(i) { selectedCells = [i]; updateVisuals(); }
    function attemptSelection(i) {
        const last = selectedCells[selectedCells.length - 1];
        if (i === last) return;
        if (selectedCells.length > 1 && i === selectedCells[selectedCells.length - 2]) { selectedCells.pop(); updateVisuals(); return; }
        if (!selectedCells.includes(i) && isAdjacent(last, i)) { selectedCells.push(i); updateVisuals(); }
    }

    // Generic Neighbor check for N x N
    function getNeighbors(idx) {
        const n = [], r = Math.floor(idx / gridSize), c = idx % gridSize;
        for(let i=r-1; i<=r+1; i++) 
            for(let j=c-1; j<=c+1; j++) 
                if(i>=0 && i<gridSize && j>=0 && j<gridSize && !(i===r && j===c)) 
                    n.push(i * gridSize + j);
        return n;
    }
    
    function isAdjacent(i1, i2) { return getNeighbors(i1).includes(i2); }
    
	function updateVisuals() {
	    document.querySelectorAll('.tile').forEach(t => t.classList.remove('selected'));
	    let txt = ""; const letters = JSON.parse(gridEl.dataset.letters);
	    selectedCells.forEach(idx => { gridEl.children[idx].classList.add('selected'); txt += (letters[idx] === 'Q' ? 'QU' : letters[idx]); });
	    
	    // üîß FIX: Non sovrascrivere se √® bloccato (parola appena trovata)
	    if (!wordDisplayLocked) {
	        wordDisplay.textContent = txt;
	    }
	    drawLine();
	}
    function clearSelection() { 
    // ‚úÖ FIX: Rimuovi tutte le classi di selezione
    document.querySelectorAll('.tile').forEach(t => {
        t.classList.remove('selected');
        t.classList.remove('anim-valid');
        t.classList.remove('anim-invalid');
    });
    
    selectedCells = []; 
    lineLayer.innerHTML = ''; 
    
    if (!wordDisplayLocked) {
        wordDisplay.textContent = ""; 
    }
    
    currentHighlightedWord = null; 
}
    
    function drawLine() {
        lineLayer.innerHTML = ''; if (selectedCells.length < 2) return;
        let points = selectedCells.map(idx => { const t = gridEl.children[idx]; return `${t.offsetLeft + t.offsetWidth/2},${t.offsetTop + t.offsetHeight/2}`; }).join(" ");
        const poly = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
        poly.setAttribute("points", points); poly.setAttribute("fill", "none"); poly.setAttribute("stroke", "var(--line-color)"); poly.setAttribute("stroke-width", gridSize >= 10 ? "4" : "8");
        poly.setAttribute("stroke-linecap", "round"); poly.setAttribute("stroke-linejoin", "round");
        lineLayer.appendChild(poly);
    }

    function getVisualIndexFromOriginal(originalIdx, rot) {
        let curr = originalIdx;
        for(let i=0; i<rot; i++) { 
            const r = Math.floor(curr/gridSize), c = curr%gridSize; 
            curr = c*gridSize + (gridSize - 1 - r); 
        }
        return curr;
    }
    function getOriginalIndexFromVisual(visualIdx, rot) {
        let curr = visualIdx; const inverseRot = (4 - (rot % 4)) % 4;
        for(let i=0; i<inverseRot; i++) { 
            const r = Math.floor(curr/gridSize), c = curr%gridSize; 
            curr = c*gridSize + (gridSize - 1 - r); 
        }
        return curr;
    }
    
    function showWordOnGrid(word) {
        if(currentHighlightedWord === word) { clearSelection(); return; }
        if(!foundWords.has(word)) return;
        const data = foundWords.get(word); if(!data.path) return;
        clearSelection(); currentHighlightedWord = word;
        selectedCells = data.path.map(idx => getVisualIndexFromOriginal(idx, rotationIndex));
        updateVisuals();
        selectedCells.forEach(i => gridEl.children[i].classList.add('anim-valid'));
        setTimeout(() => { document.querySelectorAll('.tile').forEach(t=>t.classList.remove('anim-valid')); }, 1500);
    }

    function triggerBusetExplosion() {
        // 1. Aggiungi classe CSS al body per l'effetto terremoto e flash
        document.body.classList.add('mega-win-effect');

        // 2. Fuochi d'artificio infiniti
        if (fireworksInterval) clearInterval(fireworksInterval);
        fireworksInterval = setInterval(() => {
            launchFirework();
            launchFirework();
        }, 150);

        // 3. Ferma tutto dopo 5 secondi (opzionale, altrimenti continua finch√© non finisce la partita)
        setTimeout(() => {
            document.body.classList.remove('mega-win-effect');
            stopFireworks();
        }, 5000);
    }
    function validateWord() {
		const word = wordDisplay.textContent;
		if (!word || word.length === 0) {
			return;
		}
		if (errorTimeout) {
			clearTimeout(errorTimeout);
			errorTimeout = null;
		}
        if (isSandboxMode) {
            if (word.length >= MIN_WORD_LENGTH && dictionary.has(word)) {
                // Calcola punti (solo per visualizzazione)
                const pts = calculateScoreWithBonuses(word, selectedCells);                
                wordDisplayLocked = true;
                wordDisplay.textContent = `${word} (${pts} pt)`; // <--- MODIFICA QUI
					 wordDisplay.style.background = "#2ecc71";
                selectedCells.forEach(i => gridEl.children[i].classList.add('anim-valid'));
                setTimeout(()=>document.querySelectorAll('.tile').forEach(t=>t.classList.remove('anim-valid')),500);
            } else { wordDisplay.style.background = "#e74c3c"; shakeInvalid(); }
				if(errorTimeout) clearTimeout(errorTimeout);
            errorTimeout = setTimeout(() => { wordDisplay.style.background = "#dfe6e9"; wordDisplayLocked = false; clearSelection(); errorTimeout=null;}, 2000);
            return;
        }

        if (word.length < MIN_WORD_LENGTH) { shakeInvalid(); return; }
        if (foundWords.has(word)) { wordDisplay.style.background = "#f1c40f"; setTimeout(()=>wordDisplay.style.background="#dfe6e9",400); return; }
	    if (selectedCells.length === 0) {
	        console.warn("selectedCells vuoto durante validateWord");
	        return;
	    }
        if (dictionary.has(word)) {
            const pts = calculateScoreWithBonuses(word, selectedCells);
            const originalPath = selectedCells.map(vIdx => getOriginalIndexFromVisual(vIdx, rotationIndex));
            foundWords.set(word, { points: pts, active: true, index: ++wordCounter, path: originalPath });

            if (pts >= 10) fireConfetti();
				if (word === "BUSET") {
                triggerBusetExplosion();
            }
            
            // --- TRIGGER BIATCH MODE: RUOTA QUANDO TROVI UNA PAROLA ---
            if (isBiatchMode) {
				  rotateGrid();
				  showBiatchOverlay();
            }

            runAchievementCheck(word, pts);
            updateTotalScore();
		    selectedCells.forEach(i => {
		        gridEl.children[i].classList.remove('selected'); // Rimuovi arancione
		        gridEl.children[i].classList.add('anim-valid');   // Aggiungi verde
		    });
		    
		    setTimeout(() => {
		        document.querySelectorAll('.tile').forEach(t => t.classList.remove('anim-valid'));
		        lineLayer.innerHTML = ''; // ‚úÖ PULISCI LA LINEA
		        selectedCells = []; // ‚úÖ RESET ARRAY
		    }, 500);
            wordCountDisplay.textContent = foundWords.size;
            
            const li = document.createElement('li'); li.dataset.word = word;
            li.innerHTML = `<div class="word-item-left"><button class="btn-eye" onclick="showWordOnGrid('${word}')" title="Mostra">üëÅÔ∏è</button><span>${word}</span></div><span class="pts">+${pts}</span>`;
            li.addEventListener('click', (e) => { if(isAnalysisPhase && !e.target.classList.contains('btn-eye')) toggleWord(word, li); });
            wordsListEl.insertBefore(li, wordsListEl.firstChild);
				li.addEventListener('dblclick', () => {
            window.open(`https://www.treccani.it/vocabolario/${word.toLowerCase()}`, '_blank');
            });
				wordDisplayLocked = true;
            wordDisplay.textContent = `${word} (+${pts})`;
				wordDisplay.style.background = "#2ecc71";
				// Reset dopo 2 secondi
			  setTimeout(() => {
					wordDisplay.style.background = "#dfe6e9";
			  }, 400);
			  
			  setTimeout(() => {
					wordDisplayLocked = false;
					wordDisplay.textContent = "";
			  }, 2000);
        } else { shakeInvalid(); wordDisplay.style.background = "#e74c3c"; }
        setTimeout(()=>wordDisplay.style.background="#dfe6e9",400);
    }

    function calculateScoreWithBonuses(word, cells) {
        let pts = 0;
        if (word.length === 4) pts = 1; else if (word.length === 5) pts = 2; else if (word.length === 6) pts = 3; else if (word.length === 7) pts = 5; else if (word.length >= 8) pts = 11;
        let wordMult = 1; const bonuses = JSON.parse(gridEl.dataset.bonuses);
        cells.forEach(idx => {
            const b = bonuses[idx];
            if(b === "2L") pts += 2; else if(b === "3L") pts += 3; else if(b === "2P") wordMult *= 2; else if(b === "3P") wordMult *= 3;
        });
        return pts * wordMult;
    }
    
// INNESTO 3: UPDATE SCORE LIVE
function updateTotalScore() {
    score = 0; 
    foundWords.forEach(v => { if(v.active) score += v.points; });
    scoreDisplay.textContent = score;
    if(isAnalysisPhase) updateHistoryScore();

    // Invia il punteggio live se sei in sfida
    if (typeof matchId !== 'undefined' && matchId && db) {
        db.collection("partite").doc(matchId).update({
    punteggi: { [mioNome]: score }
}, { merge: true }).catch(e => {});
    }
}
    
    function toggleWord(w, li) {
        const d = foundWords.get(w); d.active = !d.active;
        li.classList.toggle('deleted', !d.active); li.querySelector('.pts').textContent = d.active ? "+" + d.points : "0";
        updateTotalScore();
		  runAchievementCheck();
    }
    function shakeInvalid() {
		errorCount++;
        selectedCells.forEach(i => gridEl.children[i].classList.add('anim-invalid'));
        setTimeout(()=>document.querySelectorAll('.tile').forEach(t=>t.classList.remove('anim-invalid')),400);
    }

    // --- ACHIEVEMENTS E STATISTICHE ---
    function getStorageData() {
        return JSON.parse(localStorage.getItem('paroliere_data')) || {
            games: [], totalGames: 0, totalScore: 0, highScore: 0, 
            bestWord: "", bestWordVal: 0, bestWordLen: 0, bestWordLenW: "", 
            achievements: []
        };
    }

    function runAchievementCheck(lastWord = null, lastPts = 0) {
        let data = getStorageData();
        const unlockedNow = [];
		  let activeCount = 0;
        foundWords.forEach(v => { if(v.active) activeCount++; });
        const deletedCount = foundWords.size - activeCount;
        const context = {
            stats: {
                totalGames: data.totalGames + (isGameActive ? 0 : 1),
                totalScore: data.totalScore + score,
                highScore: Math.max(data.highScore, score)
            },
            game: {
                score: score,
                wordCount: foundWords.size,
					 deletedCount: deletedCount,
					 rotationCount: rotationCount,
					 errorCount: errorCount,
                elapsedTime: initialTime - timeRemaining,
					 timeRemaining: timeRemaining,
                isOver: !isGameActive,
					 isPaused: isPaused
            },
            last: { word: lastWord, points: lastPts }
        };

        ACHIEVEMENTS.forEach(ach => {
            if (!data.achievements.includes(ach.id)) {
                try {
                    if (ach.check(context)) {
                        data.achievements.push(ach.id);
                        unlockedNow.push(ach.title);
                        showAchievement(ach.title);
                    }
                } catch(e) { console.error("Err ach", ach.id, e); }
            }
        });
        if(unlockedNow.length > 0) localStorage.setItem('paroliere_data', JSON.stringify(data));
    }

    function updateStats() {
        let data = getStorageData();
        let maxLen = 0; let bestLenW = "";
        let maxScore = 0; let bestScoreW = "";

        foundWords.forEach((v, k) => { 
            if(v.active) {
                if(k.length > maxLen) { maxLen = k.length; bestLenW = k; }
                if(v.points > maxScore) { maxScore = v.points; bestScoreW = k; }
            } 
        });

        data.totalGames++;
        data.totalScore += score;
        if(score > data.highScore) data.highScore = score;
        if(maxLen > data.bestWordLen) { data.bestWordLen = maxLen; data.bestWordLenW = bestLenW; }
        if(maxScore > data.bestWordVal) { data.bestWordVal = maxScore; data.bestWord = bestScoreW; }

        const entry = { date: new Date().toLocaleDateString('it-IT', {hour:'2-digit', minute:'2-digit'}), seed: currentSeed, score: score, id: currentGameTimestamp };
        data.games.unshift(entry);
        if(data.games.length > 20) data.games = data.games.slice(0, 20);

        localStorage.setItem('paroliere_data', JSON.stringify(data));
        currentGameTimestamp = Date.now();
        runAchievementCheck(null, 0);
    }
    
	 function showElenaPopup() {
  // usa la stessa grafica della ach-notification ma SENZA confetti
  const box = document.getElementById('ach-notification');
  const txt = document.getElementById('ach-text');
  if (!box || !txt) return;

  txt.textContent = "GRAZIE ELENA PER QUESTA GENIALATA";
  box.classList.add('show');
  fireConfetti(box);
  setTimeout(() => box.classList.remove('show'), 2500);
}
	 
		function showAchievement(text) {
			 const el = document.getElementById('ach-text');
			 const notifBox = document.getElementById('ach-notification');
			 
			 el.textContent = text;
			 notifBox.classList.add('show');
			 
			 setTimeout(() => notifBox.classList.remove('show'), 2000);
			 
			 // Confetti che partono dal centro del box degli achievement
			 fireConfetti(notifBox);
		}

    function openStats() {
        const data = getStorageData();
        document.getElementById('stat-total-games').textContent = data.totalGames;
        document.getElementById('stat-high-score').textContent = data.highScore;
        document.getElementById('stat-total-score').textContent = data.totalScore;
        document.getElementById('stat-best-word').textContent = data.bestWordVal > 0 ? `${data.bestWord} (${data.bestWordVal})` : "-";
        document.getElementById('stat-longest-word').textContent = data.bestWordLen > 0 ? `${data.bestWordLenW} (${data.bestWordLen})` : "-";
        const avg = data.totalGames > 0 ? Math.round(data.totalScore / data.totalGames) : 0;
        document.getElementById('stat-avg-score').textContent = avg; 

        const achDiv = document.getElementById('achievements-list');
        achDiv.innerHTML = ACHIEVEMENTS.map(ach => {
            const unlocked = data.achievements && data.achievements.includes(ach.id);
            return `<div style="padding:5px; margin-bottom:5px; border-radius:4px; background:${unlocked ? 'rgba(39, 174, 96, 0.1)' : 'transparent'}; border-left:3px solid ${unlocked ? '#27ae60' : '#ccc'}">
                <div style="font-weight:bold; color:${unlocked ? '#27ae60' : '#7f8c8d'}">${unlocked ? 'üèÜ' : 'üîí'} ${ach.title}</div>
                <div style="font-size:0.85rem; opacity:0.8;">${ach.desc}</div>
            </div>`;
        }).join('');

        historyListBody.innerHTML = "";
        data.games.forEach(g => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${g.date}</td><td>${g.seed}</td><td style="font-weight:bold; color:var(--primary)">${g.score}</td>`;
            historyListBody.appendChild(tr);
        });
        statsModal.style.display = 'flex';
    }

    function updateHistoryScore() {
        if(!currentGameTimestamp) return;
        let data = getStorageData();
        const index = data.games.findIndex(g => g.id === currentGameTimestamp);
        if(index !== -1) {
             data.games[index].score = score;
             localStorage.setItem('paroliere_data', JSON.stringify(data));
        }
    }
    
    function clearData() {
        if(confirm("Cancellare TUTTI i dati?")) { localStorage.removeItem('paroliere_data'); openStats(); }
    }

    // --- SOLVER & UTILS ---
    function showMissedWords() {
        if(!confirm("L'analisi potrebbe richiedere del tempo. Continuare?")) return;
		  
		  const container = document.querySelector('.game-container');
		  const overlay = document.getElementById('calculation-overlay');
		  
		  container.classList.add('processing-blur');
		  overlay.style.display = 'flex';
		  
		  setTimeout(() => {
				try {
					  const visualLetters = JSON.parse(gridEl.dataset.letters); 
					  const visualBonuses = JSON.parse(gridEl.dataset.bonuses);
                      // Parametric adjacency map for any grid size
					  const adjMap = Array.from({length: gridSize * gridSize}, (_, i) => getNeighbors(i));
					  const possibleWords = [];
					  const start = performance.now();
					  const foundSet = new Set();
                      const maxTime = 10000;
                      const totalCells = gridSize * gridSize;

					  function solve(idx, currentWord, visited, currentPath) {
							if(performance.now() - start > maxTime) return; 
							visited[idx] = true; currentPath.push(idx);
							
							// PRUNING con Trie: se nessuna parola inizia cos√¨, taglia
							if(trieRoot && !hasPrefix(currentWord)) { visited[idx] = false; currentPath.pop(); return; }
							
							if(currentWord.length >= MIN_WORD_LENGTH && dictionary.has(currentWord) && !foundWords.has(currentWord) && !foundSet.has(currentWord)) {
								 foundSet.add(currentWord);
								 const pts = calculateScoreWithBonusesSolver(currentWord, [...currentPath], visualBonuses);
								 possibleWords.push({w: currentWord, p: pts});
							}
							if(currentWord.length >= 12) { visited[idx] = false; currentPath.pop(); return; }
							for(let n of adjMap[idx]) { if(!visited[n]) { let nextChar = visualLetters[n]; if(nextChar === 'Q') nextChar = 'QU'; solve(n, currentWord + nextChar, visited, currentPath); } }
							visited[idx] = false; currentPath.pop();
					  }
					  function calculateScoreWithBonusesSolver(word, cells, bonuses) {
							let pts = 0;
							if (word.length === 4) pts = 1; else if (word.length === 5) pts = 2; else if (word.length === 6) pts = 3; else if (word.length === 7) pts = 5; else if (word.length >= 8) pts = 11;
							let wordMult = 1;
							cells.forEach(idx => { const b = bonuses[idx]; if(b === "2L") pts += 2; else if(b === "3L") pts += 3; else if(b === "2P") wordMult *= 2; else if(b === "3P") wordMult *= 3; });
							return pts * wordMult;
					  }
					  for(let i=0; i<totalCells; i++) { 
                          if(performance.now() - start > maxTime) break;
                          let char = visualLetters[i]; if(char === 'Q') char = 'QU'; 
                          solve(i, char, new Array(totalCells).fill(false), []); 
                      }
					  
                      possibleWords.sort((a,b) => b.p - a.p);
					  const top = possibleWords.slice(0, 10);
					  if(top.length === 0) alert("Hai trovato tutto (o limite di tempo raggiunto)!");
					  else alert("Top 10 parole mancate:\n\n" + top.map(x => `${x.w} (${x.p} pt)`).join('\n'));
            } catch(e) {
                console.error(e);
                alert("Si √® verificato un errore durante il calcolo.");
            } finally {
                container.classList.remove('processing-blur');
                overlay.style.display = 'none';
            }
    }, 100); 
}

    function formatTime(s) { return `${Math.floor(s/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`; }
    function updateTimerDisplay() {
        timerDisplay.textContent = formatTime(timeRemaining);

        // Calcola la percentuale di tempo rimasto (1 = tutto, 0 = scaduto)
        const ratio = Math.max(0, timeRemaining / initialTime);

        // Colore graduale: Verde (120¬∞) ‚Üí Giallo (60¬∞) ‚Üí Rosso (0¬∞)
        const hue = Math.round(ratio * 120); // 120=verde, 60=giallo, 0=rosso
        timerDisplay.style.color = `hsl(${hue}, 85%, 50%)`;

        // Effetto pulsante negli ultimi 10 secondi
        if (timeRemaining <= 10 && timeRemaining > 0) {
            timerDisplay.classList.add('timer-alert');
        } else {
            timerDisplay.classList.remove('timer-alert');
        }
    }
    
    function copySeed() { navigator.clipboard.writeText(currentSeed).then(() => alert("Codice copiato!")); }
	 function copySeedNewGame() { navigator.clipboard.writeText(currentSeed); }
	  function copyWords() { 
	  // 1. Selezioniamo gli elementi HTML della lista. 
	  // Questo garantisce che l'ordine sia esattamente quello che vedi a schermo (Alfabetico, Punti, ecc.)
	  const listItems = document.querySelectorAll('#found-words li');
	  const exportList = [];

	  listItems.forEach(li => {
			// 2. Controlliamo se la parola ha la classe "deleted" (barrata)
			// Se NON √® cancellata, la aggiungiamo alla lista da copiare
			if (!li.classList.contains('deleted')) {
				 exportList.push(li.dataset.word);
			}
	  });

	  if (exportList.length === 0) {
			alert("Nessuna parola valida da copiare.");
			return;
	  }

	  // 3. Copia negli appunti separando con virgola
	  navigator.clipboard.writeText(exportList.join(',')).then(() => {
			alert(`Copiato! (${exportList.length} parole attive)`);
	  });
    }

	function setSortMode(m) { 
		 sortMode = m; 
		 const btns = document.querySelectorAll('.sort-btn');
		 btns.forEach(b => b.classList.remove('active')); 
		 if(m === 'chrono' && btns[0]) btns[0].classList.add('active');
		 if(m === 'alpha' && btns[1]) btns[1].classList.add('active');
		 if(m === 'score' && btns[2]) btns[2].classList.add('active');
		 sortList(); 
	}
    function toggleSortDirection() { sortDescending = !sortDescending; document.getElementById('sort-dir-btn').textContent = sortDescending ? "‚¨áÔ∏è" : "‚¨ÜÔ∏è"; sortList(); }
    function sortList() {
        const items = Array.from(wordsListEl.children); const m = sortDescending ? 1 : -1;
        items.sort((a,b) => {
            const wA = a.dataset.word, wB = b.dataset.word; const dA = foundWords.get(wA), dB = foundWords.get(wB);
            if(sortMode === 'alpha') return wA.localeCompare(wB) * m;
            if(sortMode === 'score') return (dB.points - dA.points) * m || wA.localeCompare(wB);
            return (dB.index - dA.index) * m;
        });
        wordsListEl.innerHTML = ""; items.forEach(i=>wordsListEl.appendChild(i));
    }

    function closeStats() { statsModal.style.display = 'none'; }
    function openLegend() { legendModal.style.display = 'flex'; }
    function closeLegend() { legendModal.style.display = 'none'; }
    function toggleTheme() { document.body.classList.toggle('dark-mode'); }
    toggleInput.addEventListener('change', () => { clearSelection(); inputMode = toggleInput.checked ? 'click' : 'drag'; btnResetSelection.style.display = inputMode==='click'?'block':'none'; });
    
function fireConfetti(originElement = null) {
    const colors = ['#f1c40f', '#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#ffffff', '#ff00ff'];
    const count = 150; // Quanti confetti? TANTI.

    // Centro di default: centro schermo (come prima)
    let centerXPercent = 50;
    let centerYPercent = 50;

    // Se passo un elemento, uso il suo centro geometrico
    if (originElement) {
        const rect = originElement.getBoundingClientRect();
        centerXPercent = ((rect.left + rect.width / 2) / window.innerWidth) * 100;
        centerYPercent = ((rect.top + rect.height / 2) / window.innerHeight) * 100;
    }

    for (let i = 0; i < count; i++) {
        const p = document.createElement('div');
        p.className = 'confetti';

        // Zona di partenza: intorno al centro calcolato (come il tuo 50% ¬± 10)
        const startX = centerXPercent + (Math.random() - 0.5) * 20; 
        const startY = centerYPercent + (Math.random() - 0.5) * 20;
        
        p.style.position = 'fixed'; // cos√¨ % √® rispetto al viewport
        p.style.left = startX + '%';
        p.style.top = startY + '%';
        p.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        
        // Dimensioni variabili (da piccoli a ENORMI)
        const size = Math.random() * 15 + 5; 
        p.style.width = size + 'px';
        p.style.height = size + 'px';
        
        // Forma casuale (quadrati o cerchi)
        if (Math.random() > 0.5) p.style.borderRadius = '50%';
        
        p.style.zIndex = '10000';
        p.style.pointerEvents = 'none';

        document.body.appendChild(p);

        // Calcolo traiettoria esplosiva
        const angle = Math.random() * Math.PI * 2;
        const velocity = 200 + Math.random() * 400; // Esplosione potente
        const tx = Math.cos(angle) * velocity;
        const ty = Math.sin(angle) * velocity;
        const rot = (Math.random() - 0.5) * 1000; // Rotazione pazza

        p.animate([
            { transform: `translate(0,0) rotate(0deg) scale(1)`, opacity: 1 },
            { transform: `translate(${tx}px, ${ty}px) rotate(${rot}deg) scale(0.5)`, opacity: 0 }
        ], {
            // Allunghiamo un po' rispetto all‚Äôoriginale, per farli durare di pi√π
            duration: 2000 + Math.random() * 1500, 
            easing: 'cubic-bezier(0.25, 1, 0.5, 1)'
        }).onfinish = () => p.remove();
    }
}

    function startEndGameCelebration() {
        // Se ce n'era uno attivo, fermalo prima
        if(fireworksInterval) clearInterval(fireworksInterval);
        
        let count = 0;
        fireworksInterval = setInterval(() => {
            launchFirework();
            launchFirework();
            count++;
            // Limite di sicurezza (es. 40 cicli)
            if(count > 40) stopFireworks(); 
        }, 200);
    }
    
    function stopFireworks() {
        if(fireworksInterval) {
            clearInterval(fireworksInterval);
            fireworksInterval = null;
        }
    }

    function launchFirework() {
        const colors = ['#ff0044', '#ffff00', '#00ff44', '#00ccff', '#ff00ff'];
        
        // Posizione di partenza casuale in basso
        const startX = Math.random() * window.innerWidth;
        const startY = window.innerHeight;
        
        // Punto di esplosione (casuale nella met√† alta dello schermo)
        const endX = startX + (Math.random() - 0.5) * 200;
        const endY = window.innerHeight * 0.2 + Math.random() * window.innerHeight * 0.4;
        const color = colors[Math.floor(Math.random() * colors.length)];

        // 1. Il razzo che sale
        const rocket = document.createElement('div');
        rocket.style.position = 'fixed';
        rocket.style.left = startX + 'px';
        rocket.style.top = startY + 'px';
        rocket.style.width = '4px';
        rocket.style.height = '12px';
        rocket.style.background = color;
        rocket.style.borderRadius = '2px';
        rocket.style.zIndex = '9998';
        document.body.appendChild(rocket);

        rocket.animate([
            { transform: `translate(0, 0)` },
            { transform: `translate(${endX - startX}px, ${endY - startY}px)` }
        ], {
            duration: 1000,
            easing: 'ease-out'
        }).onfinish = () => {
            rocket.remove();
            explode(endX, endY, color); // Esplosione!
        };

        // 2. L'esplosione
        function explode(x, y, color) {
            for (let i = 0; i < 80; i++) { //quanti pallini colorati per questa singola esplosione
                const p = document.createElement('div');
                p.style.position = 'fixed';
                p.style.left = x + 'px';
                p.style.top = y + 'px';
                p.style.width = '6px';
                p.style.height = '6px';
                p.style.backgroundColor = color;
                p.style.borderRadius = '50%';
                p.style.zIndex = '9998';
                
                // Fisica particella
                const angle = Math.random() * Math.PI * 2;
                const velocity = Math.random() * 100; //quanto distanti vanno dal centro
                const tx = Math.cos(angle) * velocity;
                const ty = Math.sin(angle) * velocity;
                
                document.body.appendChild(p);

                p.animate([
                    // START: Centro
                    { transform: `translate(0,0) scale(1)`, opacity: 1, offset: 0 },
                    
                    // FASE 1: ESPLOSIONE SFERICA
                    // I pallini raggiungono la massima espansione in tutte le direzioni
                    { transform: `translate(${tx}px, ${ty}px) scale(0.9)`, opacity: 0.9, offset: 0.2 },
                    
                    // FASE 2: CADUTA LENTA (dal 20% al 100%)
                    // Mantengono la posizione orizzontale (tx) ma cadono in verticale (ty + gravit√†)
                    { transform: `translate(${tx}px, ${ty + 500}px) scale(0)`, opacity: 0, offset: 1 }
                ], {
                    duration: 2000 + Math.random() * 2000,
                    easing: 'linear' // Usiamo linear perch√© controlliamo noi il movimento con i keyframes
                }).onfinish = () => p.remove();
            }
        }
    }

		function showBiatchOverlay() {
			 // Easter Egg 1: Messaggio a schermo gigante
			 const texts = ["GIRA BIATCH!", "OPS!", "DI QUA!", "MUOVITI!", "üê∑üê∑üê∑"];
			 const overlay = document.createElement('div');
			 overlay.style = "position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); font-size:5rem; font-weight:900; color:#ff00ff; z-index:10000; pointer-events:none; text-shadow: 5px 5px 0px black;";
			 overlay.textContent = texts[Math.floor(Math.random() * texts.length)];
			 document.body.appendChild(overlay);
			 
			 // Easter Egg 2: Confetti fucsia ad ogni giro
			 fireConfetti(overlay); 

			 setTimeout(() => overlay.remove(), 800);
		}

		// FIX 4: Listener chiusura modali con cleanup completo
		window.addEventListener('click', (e) => {
			 if (e.target.classList.contains('modal-overlay')) {
				  if (e.target.id === 'game-end-modal') {
						closeEndGameModal(); // Usa la funzione centralizzata
						return; // Evita doppia chiusura
				  }
				  e.target.style.display = 'none';
			 }
		});
		document.addEventListener('visibilitychange', () => {
			 if (!document.hidden || !isGameActive || isPaused || isSandboxMode || matchId) return;
			 togglePause();
		});

// --- LOGICA DI GESTIONE FINALE (PULITA E CORRETTA) ---

// Richiedi login SOLO in multiplayer
if (!mioNome && matchId) {
    alert("Effettua il login per giocare in multiplayer.");
    window.location.href = "index.html";
}
if (!matchId) {
    // MODALIT√Ä SOLO
    if(document.getElementById('multiplayer-lobby')) document.getElementById('multiplayer-lobby').style.display = 'none';
    if(document.getElementById('live-opponent-score')) document.getElementById('live-opponent-score').style.display = 'none';
	 document.getElementById('manual-rotate-btn').style.display = 'none';
	 document.getElementById('possible-count').parentElement.style.visibility = 'hidden';
    loadDictionary(); 
} else {
    // MODALIT√Ä MULTIPLAYER
    
    // üßπ SPEGNI LISTENER VECCHI (se esistono)
    if(unsubscribePartita) unsubscribePartita();
    if(unsubscribeProposte) unsubscribeProposte();
    
    // ‚úÖ ATTIVA NUOVO LISTENER E SALVA IL TELECOMANDO
    unsubscribePartita = db.collection("partite").doc(matchId).onSnapshot(doc => {
        const data = doc.data();
        if(!data) { window.location.href = "index.html"; return; }
        
        currentGameData = data;
    
	// FIX 3: APPLICA DIZIONARIO CUSTOM (con versioning)
	if(data.dizionarioCustom) {
		 const extraLen = (data.dizionarioCustom.extra || []).length;
		 const excludedLen = (data.dizionarioCustom.excluded || []).length;
		 const currentVersion = `${extraLen}-${excludedLen}`;
		 
		 // Riapplica solo se la versione √® cambiata
		 if(!dizionarioCustomApplicato || window.lastDictVersion !== currentVersion) {
			  (data.dizionarioCustom.extra || []).forEach(w => {
					if(w && !EXTRA_WORDS.includes(w)) {
						 EXTRA_WORDS.push(w);
						 dictionary.add(w);
					}
			  });
			  (data.dizionarioCustom.excluded || []).forEach(w => {
					if(w && !EXCLUDED_WORDS.includes(w)) {
						 EXCLUDED_WORDS.push(w);
						 dictionary.delete(w);
					}
			  });
			  
			  buildTrie();
			  dizionarioCustomApplicato = true;
			  window.lastDictVersion = currentVersion;
			  if (DEBUG_MODE) console.log("Dizionario custom aggiornato:", currentVersion);
		 }
	}
        const overlay = document.getElementById('multiplayer-lobby');
        const statusDiv = document.getElementById('lobby-status');
        const actionDiv = document.getElementById('lobby-action');
        const pronti = data.pronti || [];
        const finito = data.finito || [];

        // 1. ATTESA (Sincronizzazione Start)
        if (data.stato === "attesa") {
            overlay.style.display = 'flex';
            statusDiv.textContent = `Pronti: ${pronti.length} / ${data.partecipanti.length}`;
            actionDiv.innerHTML = !pronti.includes(mioNome) ? 
    `<button onclick="setProntoOnline()" class="btn-fancy">üöÄ AVVIA SFIDA!</button>` 
    : `<div style="background:rgba(3,218,198,0.1); padding:20px 40px; border-radius:15px; border:2px dashed #03dac6;">
        <div style="font-size:1.5rem; margin-bottom:10px;">‚è≥</div>
        <p style="margin:0; font-weight:bold;">In attesa dei colleghi...</p>
    </div>`;
            // Nella sezione "attesa"
actionDiv.innerHTML += `<br><button onclick="annullaPartita()" style="background:#e74c3c; color:white; border:none; padding:10px 20px; margin-top:20px; cursor:pointer; border-radius:5px; font-weight:bold;">üö´ ANNULLA E CANCELLA PARTITA</button>`;
            
			if (pronti.length >= data.partecipanti.length) {
			    db.collection("partite").doc(matchId).update({ 
			        stato: "in_corso"
			    });
			}
        }

        // 2. IN CORSO
        if (data.stato === "in_corso") {
		    const altri = data.partecipanti.filter(n => n !== mioNome);
		    let scoresHtml = "";
		    altri.forEach(a => {
		        const punteggio = data.punteggi && data.punteggi[a] ? data.punteggi[a] : 0;
		        scoresHtml += `<span style="margin:0 5px;">üÜö ${a}: <strong>${punteggio}</strong></span>`;
		    });
		    const scoreEl = document.getElementById('live-opponent-score');
		    if (scoreEl) {
		        scoreEl.innerHTML = scoresHtml;
		        scoreEl.style.display = 'block';
		    }
			if (!finito.includes(mioNome)) {
                overlay.style.display = 'none';
                if (!isGameActive && !isAnalysisPhase && !isPaused) {
                    gridSize = parseInt(data.opzioni.griglia);
						// FIX 1: Timer sincronizzato con timestamp server
							timeRemaining = parseInt(data.opzioni.tempo);
							initialTime = timeRemaining;
                    currentSeed = data.opzioni.seed;
                    isBiatchMode = (data.opzioni.mode === 'biatch');
                    isCrazyMode = (data.opzioni.mode === 'crazy');
                    useBonuses = (data.opzioni.mode !== 'classic');
                    generateGridData(currentSeed.split('-')[0]);
                    renderGrid();
                    document.getElementById('start-screen').style.display = 'none';
					gridOverlay.style.display = 'flex';
                    document.querySelectorAll('.tile').forEach(t => t.classList.add('blurred'));
					overlaySeed.textContent = currentSeed;
            		timerDisplay.textContent = formatTime(timeRemaining);
					document.getElementById('possible-count').parentElement.style.visibility = 'visible';
					calculatePossibleWordsCount();
                }
} else {
    // Ho finito il mio tempo
    if (finito.length < data.partecipanti.length) {
        // Nascondi overlay grande - posso continuare a esplorare
        overlay.style.display = 'none';
        
        // ‚úÖ NUOVO: Banner con pulsante VEDI RISULTATI
        let waitBanner = document.getElementById('wait-banner');
        if (!waitBanner) {
            waitBanner = document.createElement('div');
            waitBanner.id = 'wait-banner';
            waitBanner.style = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
                color: white;
                padding: 12px 20px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                z-index: 9999;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            `;
            document.body.appendChild(waitBanner);
        }
        
        waitBanner.innerHTML = `
            <div style="display:flex; align-items:center; gap:10px;">
                <span style="font-size:1.5rem;">‚è≥</span>
                <div>
                    <div style="font-weight:bold;">ATTESA COLLEGHI (${finito.length}/${data.partecipanti.length})</div>
                    <div style="font-size:0.8rem; opacity:0.8;">Esplora la griglia nel frattempo!</div>
                </div>
            </div>
            <button onclick="mostraLobbyTemporanea()" style="
                background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 25px;
                font-weight: bold;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(243, 156, 18, 0.4);
                transition: transform 0.2s;
            " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                üëÄ VEDI RISULTATI
            </button>
        `;
        
        // Attiva modalit√† esplorazione
        if (!isAnalysisPhase) {
            isAnalysisPhase = true;
            isGameActive = true;
            isSandboxMode = true;
            document.querySelectorAll('.tile').forEach(t => t.classList.remove('blurred'));
            sortControls.style.display = "flex";
            btnMissed.style.display = "block";
            analysisMsg.style.display = "block";
        }
    } else {
        // Tutti hanno finito, rimuovi banner e vai alla verifica
        const waitBanner = document.getElementById('wait-banner');
        if (waitBanner) waitBanner.remove();
        
        db.collection("partite").doc(matchId).update({ stato: "verifica" });
    }
}
            const altri = data.partecipanti.filter(n => n !== mioNome);
            let scoresHtml = "";
            altri.forEach(a => scoresHtml += ` üÜö ${a}: ${data.punteggi[a] || 0} `);
            document.getElementById('live-opponent-score').innerHTML = scoresHtml;
        }

        // 3. VERIFICA
        if (data.stato === "verifica") {
            overlay.style.display = 'flex';
            document.getElementById('lobby-title').textContent = "VERIFICA PAROLE";
            const conf = data.confermaVerifica || [];
            statusDiv.innerHTML = `<div style="font-size:2rem; margin:10px;">Conferme: ${conf.length} / ${data.partecipanti.length}</div>`;
            actionDiv.innerHTML = !conf.includes(mioNome) ? 
    `<button onclick="confermaVerificaOnline()" class="btn-fancy gold">üèÅ VEDI CHI HA VINTO</button>` 
    : `<p style="opacity:0.7;">‚è≥ Attendo gli altri...</p>`;
        }

        // 4. CONCLUSIONE (CON RIVINCITA)
        if (data.stato === "conclusa") {
            overlay.style.display = 'flex';
            if (data.prossimaPartita) {
                document.getElementById('lobby-title').textContent = "RIVINCITA!";
                setTimeout(() => { window.location.href = `ruzzle.html?matchId=${data.prossimaPartita}`; }, 1000);
                return;
            }
            let classifica = Object.entries(data.punteggi).sort((a,b) => b[1]-a[1]);
            document.getElementById('lobby-title').textContent = classifica[0][0] === mioNome ? "VITTORIA! üëë" : "SCONFITTA! üê∑";
            let html = ""; classifica.forEach(([p, s]) => { html += `${p}: ${s} PT<br>`; });
            statusDiv.innerHTML = `<div style='font-size:1.5rem; margin:15px;'>${html}</div><button onclick="attivaAnalisiMultiplayer()" style="padding:10px; background:#f39c12; border:none; cursor:pointer; border-radius:5px; font-weight:bold; margin-bottom:10px;">üîç ANALIZZA TUTTI</button>`;
            
			// TASTO RIVINCITA: apre modal per scegliere modalit√†
			actionDiv.innerHTML = `
			    <button onclick="apriModalRivincita()" class="btn-fancy">üîÑ RIVINCITA</button>
			    <button onclick="tornaHome()" class="btn-fancy" style="background: linear-gradient(135deg, #3498db 0%, #2c3e50 100%); padding:10px 20px; font-size:0.9rem;">üè† HOME</button>`;
            if(classifica[0][0] === mioNome) { fireConfetti(); startEndGameCelebration(); }
        }
    });
	// LISTENER PROPOSTE (SEPARATO E PULITO)
unsubscribeProposte = db.collection("partite").doc(matchId).collection("proposte").onSnapshot(snap => {
    snap.docChanges().forEach(async change => {
        if(change.type === "added" || change.type === "modified") {
            const prop = change.doc.data();
            
            // VOTO SE NON L'HO GI√Ä FATTO
            if(!prop.voti.includes(mioNome)) {
                const azione = prop.tipo === 'extra' ? 'AGGIUNGERE' : 'RIMUOVERE';
                if(confirm(`VOTAZIONE: ${prop.proponente} vuole ${azione} "${prop.parola}". Approvi?`)) {
                    await db.collection("partite").doc(matchId)
                        .collection("proposte").doc(prop.parola)
                        .update({
                            voti: firebase.firestore.FieldValue.arrayUnion(mioNome)
                        })
                        .catch(e => console.error("Errore voto:", e));
                }
            }
            
            // VERIFICA SE TUTTI HANNO VOTATO (usa currentGameData!)
            if(currentGameData && currentGameData.partecipanti) {
                const numPartecipanti = currentGameData.partecipanti.length;
                
                if(prop.voti.length >= numPartecipanti) {
                    // APPLICA MODIFICA
                    await applicaModificaDizionario(prop.parola, prop.tipo);
                    
                    // ELIMINA PROPOSTA
                    await db.collection("partite").doc(matchId)
                        .collection("proposte").doc(prop.parola)
                        .delete()
                        .catch(e => console.error("Errore delete:", e));
                }
            }
        }
    });
});
    
    loadDictionary();
}

function setProntoOnline() { 
    db.collection("partite").doc(matchId).update({ 
        pronti: firebase.firestore.FieldValue.arrayUnion(mioNome),
    }); 
}

async function confermaVerificaOnline() {
    await db.collection("partite").doc(matchId).update({ confermaVerifica: firebase.firestore.FieldValue.arrayUnion(mioNome) });
    const snap = await db.collection("partite").doc(matchId).get();
    const data = snap.data();
    if (data.confermaVerifica.length >= data.partecipanti.length) {
        let nuoviPunteggi = {};
        data.partecipanti.forEach(player => {
            let pFinal = 0; const mie = data.parole[player] || [];
            mie.forEach(par => {
                let comune = false;
                data.partecipanti.forEach(altro => { if(player !== altro && (data.parole[altro] || []).some(x => x.w === par.w)) comune = true; });
                if(!comune) pFinal += par.p;
            });
            nuoviPunteggi[player] = pFinal;
        });
        db.collection("partite").doc(matchId).update({ punteggi: nuoviPunteggi, stato: "conclusa" });
    }
}

async function attivaAnalisiMultiplayer() {
    const loadingDiv = document.createElement('div');
    loadingDiv.innerHTML = '<div style="text-align:center; padding:20px;">‚è≥ Caricamento analisi...</div>';
    document.getElementById('found-words').appendChild(loadingDiv);
    
    const snap = await db.collection("partite").doc(matchId).get();
    const data = snap.data();
	loadingDiv.remove(); // <-- Rimuovi dopo caricamento
	document.getElementById('multiplayer-lobby').style.display = 'none';
    document.getElementById('proposta-manuale-container').style.display = 'block'; // Mostra campo input
    isAnalysisPhase = true;
    isGameActive = true; 
    
    if(document.getElementById('analysis-msg')) document.getElementById('analysis-msg').style.display = "block";
    if(document.getElementById('btn-missed')) document.getElementById('btn-missed').style.display = "block";
    
    // 1. Calcola le parole comuni per sbarrarle
    let conteggioParoleGlobali = {};
    data.partecipanti.forEach(p => {
        (data.parole[p] || []).forEach(par => {
            conteggioParoleGlobali[par.w] = (conteggioParoleGlobali[par.w] || 0) + 1;
        });
    });

    const wordsListEl = document.getElementById('found-words');
    wordsListEl.innerHTML = "";

    // 2. Menu a Tendina (Se non gi√† presente)
    if(!document.getElementById('sel-analisi')) {
        const headerDiv = document.createElement('div');
        headerDiv.style = "background:#2c3e50; padding:10px; border-radius:5px; margin-bottom:10px;";
        headerDiv.innerHTML = `<label style="font-size:0.7rem; font-weight:bold; display:block; margin-bottom:5px;">MOSTRA PAROLE DI:</label>
                               <select id="sel-analisi" style="width:100%; background:#1e1e1e; color:white; border:1px solid #444; padding:5px;"></select>`;
        wordsListEl.parentNode.insertBefore(headerDiv, wordsListEl);
        
        const sel = document.getElementById('sel-analisi');
        data.partecipanti.forEach(p => {
            const o = document.createElement('option'); o.value = p; o.textContent = p + (p === mioNome ? " (TU)" : "");
            sel.appendChild(o);
        });
        sel.onchange = (e) => renderizzaAnalisiPlayer(e.target.value);
    }

    const renderizzaAnalisiPlayer = (nomePlayer) => {
        wordsListEl.innerHTML = "";
        // FIX: Ordina alfabeticamente
        const parole = (data.parole[nomePlayer] || []).sort((a,b) => a.w.localeCompare(b.w));
        
        parole.forEach(item => {
            foundWords.set(item.w, { points: item.p, path: item.path });
            const isDuplicata = conteggioParoleGlobali[item.w] > 1;
            const li = document.createElement('li');
            if(isDuplicata) { li.style.textDecoration = "line-through"; li.style.opacity = "0.5"; }

            li.innerHTML = `
                <div class="word-item-left">
                    <button class="btn-eye" onclick="showWordOnGrid('${item.w}')">üëÅÔ∏è</button>
                    <span>${item.w}</span>
                    <button onclick="inviaPropostaFirebase('${item.w}', 'exclude')" style="background:none; border:none; cursor:pointer;" title="Proponi Rimozione">üì¢</button>
                </div>
                <span class="pts">${isDuplicata ? 0 : item.p}</span>`;
            wordsListEl.appendChild(li);
        });
    };

    renderizzaAnalisiPlayer(mioNome);

// üîß NUOVO: Pulsante per tornare alla lobby
const btnTornaLobby = document.createElement('button');
btnTornaLobby.textContent = "‚¨ÖÔ∏è TORNA ALLA LOBBY / RIVINCITA";
btnTornaLobby.style = "width:100%; padding:12px; background:#03dac6; color:black; border:none; border-radius:8px; font-weight:bold; cursor:pointer; margin-top:15px;";
btnTornaLobby.onclick = () => {
    document.getElementById('multiplayer-lobby').style.display = 'flex';
    document.getElementById('proposta-manuale-container').style.display = 'none';
};
wordsListEl.parentNode.appendChild(btnTornaLobby);
}

// Proposta manuale (per EXTRA_WORDS)
function proponiParolaManuale() {
    const parola = document.getElementById('input-nuova-parola').value
        .trim()
        .toUpperCase()
        .replace(/[^A-Z]/g, ''); // <-- Rimuovi caratteri speciali
    
    if (parola.length < 4) return alert("Minimo 4 lettere!");
    if (parola.length > 20) return alert("Troppo lunga!");
    
    inviaPropostaFirebase(parola, 'extra');
}

// Invia al database la proposta
async function inviaPropostaFirebase(parola, tipo) {
    const azione = (tipo === 'extra') ? "AGGIUNGERE alle EXTRA" : "ELIMINARE (EXCLUDED)";
    if(!confirm(`Vuoi proporre al gruppo di ${azione} la parola: ${parola}?`)) return;

    await db.collection("partite").doc(matchId).collection("proposte").doc(parola).set({
        parola: parola,
        tipo: tipo,
        proponente: mioNome,
        voti: [mioNome] // Il proponente vota s√¨ automaticamente
    });
    alert("Proposta inviata! Gli altri devono approvare.");
}

async function applicaModificaDizionario(parola, tipo) {
    // 1. Aggiorna array locali
    if(tipo === 'extra') {
        if(!EXTRA_WORDS.includes(parola)) EXTRA_WORDS.push(parola);
        dictionary.add(parola);
    } else {
        if(!EXCLUDED_WORDS.includes(parola)) EXCLUDED_WORDS.push(parola);
        dictionary.delete(parola);
    }
    
    buildTrie(); // Ricostruisci il trie

    // 2. Salva su Firebase nella partita corrente
    if (matchId) {
        await db.collection("partite").doc(matchId).update({
            [`dizionarioCustom.extra`]: firebase.firestore.FieldValue.arrayUnion(tipo === 'extra' ? parola : null),
            [`dizionarioCustom.excluded`]: firebase.firestore.FieldValue.arrayUnion(tipo === 'exclude' ? parola : null)
        });
    }
    
    // 3. üîß SALVA PERMANENTEMENTE nel dizionario globale
    const globalRef = db.collection("config").doc("dizionario");
    if (tipo === 'extra') {
        await globalRef.set({
            extra: firebase.firestore.FieldValue.arrayUnion(parola)
        }, { merge: true });
    } else {
        await globalRef.set({
            excluded: firebase.firestore.FieldValue.arrayUnion(parola)
        }, { merge: true });
    }
    
    alert(`${tipo === 'extra' ? '‚úÖ Aggiunta' : 'üö´ Rimossa'} PERMANENTEMENTE: "${parola}"`);
}

// üö™ FIX 2: CLEANUP COMPLETO
function cleanupFirebaseListeners() {
    if(unsubscribePartita) { unsubscribePartita(); unsubscribePartita = null; }
    if(unsubscribeProposte) { unsubscribeProposte(); unsubscribeProposte = null; }
}

window.addEventListener('beforeunload', cleanupFirebaseListeners);
window.addEventListener('pagehide', cleanupFirebaseListeners); // Per mobile Safari

function tornaHome() {
    cleanupFirebaseListeners();
    window.location.href = 'index.html';
}

function apriModalRivincita() {
    // Chiudi la lobby
    document.getElementById('multiplayer-lobby').style.display = 'none';
    
    // ‚úÖ Pre-seleziona i settaggi della partita appena giocata
    if (currentGameData && currentGameData.opzioni) {
        const opts = currentGameData.opzioni;
        
        // Timer
        const timerSelect = document.getElementById('modal-timer-select');
        if (timerSelect && opts.tempo) {
            timerSelect.value = opts.tempo;
        }
        
        // Griglia
        const gridSelect = document.getElementById('modal-grid-select');
        if (gridSelect && opts.griglia) {
            gridSelect.value = opts.griglia;
        }
    }
    
    // Apri il modal di selezione
    newGameModal.style.display = 'flex';
}

// ‚úÖ NUOVA FUNZIONE: Mostra lobby senza bloccare il gioco
function mostraLobbyTemporanea() {
    const lobby = document.getElementById('multiplayer-lobby');
    lobby.style.display = 'flex';
    
    // Aggiungi pulsante per tornare alla griglia
    const actionDiv = document.getElementById('lobby-action');
    
    // Controlla se il pulsante esiste gi√†
    if (!document.getElementById('btn-torna-griglia')) {
        const btnTorna = document.createElement('button');
        btnTorna.id = 'btn-torna-griglia';
        btnTorna.innerHTML = 'üéÆ TORNA ALLA GRIGLIA';
        btnTorna.style = `
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-weight: bold;
            font-size: 1.1rem;
            cursor: pointer;
            margin-top: 15px;
            box-shadow: 0 8px 25px rgba(39, 174, 96, 0.4);
            transition: all 0.3s ease;
        `;
        btnTorna.onmouseover = () => btnTorna.style.transform = 'scale(1.05)';
        btnTorna.onmouseout = () => btnTorna.style.transform = 'scale(1)';
        btnTorna.onclick = () => {
            lobby.style.display = 'none';
        };
        actionDiv.appendChild(btnTorna);
    }
}
function setupHomeButtonCleanup() {
    // Intercetta TUTTI i link verso index.html
    document.addEventListener('click', (e) => {
        const target = e.target.closest('a, button');
        if (!target) return;
        
        const href = target.getAttribute('href') || '';
        const onclick = target.getAttribute('onclick') || '';
        
        if (href.includes('index.html') || onclick.includes('index.html')) {
            e.preventDefault();
            e.stopPropagation();
            cleanupFirebaseListeners();
            window.location.href = 'index.html';
        }
    }, true); // Capture phase per intercettare prima
}

	async function annullaPartita() {
    if (!confirm("Sicuro di voler CANCELLARE la partita per tutti?")) return;
    
    try {
        await db.collection("partite").doc(matchId).delete();
        alert("Partita cancellata per tutti!");
        window.location.href = "index.html";
    } catch (e) {
        console.error("Errore cancellazione:", e);
        alert("Errore durante la cancellazione");
    }
}
// Chiamalo dopo che il DOM esiste (puoi metterlo DOPO loadDictionary)
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupHomeButtonCleanup);
} else {
    setupHomeButtonCleanup();
}
</script>
</body>
</html>
